<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2018-11-28 Wed 16:03 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>Intro to Clojure</title>
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Clojure/core" />
<link rel="stylesheet" type="text/css" href="slide-assets/goog-common.css" />
<link rel="stylesheet" type="text/css" href="slide-assets/common.css" />
<link rel="stylesheet" type="text/css" href="slide-assets/screen.css" media="screen" />
<link rel="stylesheet" type="text/css" href="slide-assets/projection.css" media="projection" />
<link rel="stylesheet" type="text/css" href="slide-assets/presenter.css" media="presenter" />
<link rel="stylesheet" type="text/css" href="slide-assets/print.css" media="print" />
</head>
<body>
<div id="content">
<h1 class="title">Intro to Clojure</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline424">Intro to Clojure&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a>
<ul>
<li><a href="#orgheadline4">Overview of the Course&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#orgheadline5">Clojure Overview &amp; REPL&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#orgheadline48">LAB: Exploring the REPL&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#orgheadline60">Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#orgheadline87">LAB: Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#orgheadline131">Flow Control&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#orgheadline160">LAB: Flow Control&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#orgheadline183">Collections as Containers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#orgheadline228">Collections as Indexes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#orgheadline255">LAB: Collections&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#orgheadline279">Collections as Structured Data&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#orgheadline297">LAB: Structured Data&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#orgheadline314">Sequences&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#orgheadline385">LAB: Sums and Ciphers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
</ul>
</li>
<li><a href="#orgheadline781">Intermediate Topics</a>
<ul>
<li><a href="#orgheadline425">Transducers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#orgheadline439">Polymorphism&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#orgheadline465">LAB: Rock, Paper, Scissors&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#orgheadline488">Concurrency&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#orgheadline542">LAB: Concurrent Surgery&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#orgheadline560">Names and Namespaces&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#orgheadline591">LAB: Namespaces&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#orgheadline608">Spec&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#orgheadline739">Macros&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#orgheadline767">LAB: Macros&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
</ul>
</li>
<li><a href="#orgheadline865">Optional Topics</a>
<ul>
<li><a href="#orgheadline782">Testing&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#orgheadline799">LAB: Testing</a></li>
<li><a href="#orgheadline811">Life on the JVM&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
<li><a href="#orgheadline855">LAB: Type Hints and Primitive Arithmetic&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></a></li>
</ul>
</li>
<li><a href="#orgheadline866">The End</a></li>
</ul>
</div>
</div>
<p class="copyright">Copyright &copy; 2018<a href="http://cognitect.com">Cognitect, Inc</a>. All rights reserved. Not for distribution.</p>
<p>This HTML document contains <strong>both</strong> lecture slides and lab exercises. Press <strong>T</strong> to toggle slide-show mode. The lab exercises are <strong>not</strong> visible in slide-show mode.</p>

<div id="outline-container-orgheadline424" class="outline-2">
<h2 id="orgheadline424">Intro to Clojure&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h2>
<div class="outline-text-2" id="text-orgheadline424">
</div><div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4">Overview of the Course&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-orgheadline4">
</div><div id="outline-container-orgheadline1" class="outline-4">
<h4 id="orgheadline1">Intro Topics&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline1">
<ul class="org-ul">
<li>Clojure Overview &amp; REPL</li>
<li>Functions</li>
<li>Flow Control</li>
<li>Collections</li>
<li>Sequences</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-4">
<h4 id="orgheadline2">Intermediate Topics&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline2">
<ul class="org-ul">
<li>Transducers</li>
<li>Polymorphism</li>
<li>Concurrency</li>
<li>Names and Namespaces</li>
<li>Spec</li>
<li>Macros</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-4">
<h4 id="orgheadline3">Optional Topics&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline3">
<ul class="org-ul">
<li>Testing</li>
<li>Life on the JVM</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-3">
<h3 id="orgheadline5">Clojure Overview &amp; REPL&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-orgheadline5">
</div>

<div id="outline-container-orgheadline6" class="outline-4">
<h4 id="orgheadline6">Clojure Objectives&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline6">
<ul class="org-ul">
<li>Lisp: small core, code-as-data, abstraction</li>
<li>Functional, emphasis on immutability</li>
<li>Support concurrency &amp; managed state</li>
<li>Expose and embrace host platforms</li>
</ul>
</div>

<div id="outline-container-orgheadline7" class="outline-5">
<h5 id="orgheadline7">Why Another Lisp?&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline7">
<ul class="org-ul">
<li>Limits to change post standardization</li>
<li>Core data structures mutable, not extensible</li>
<li>No concurrency in specs</li>
<li>Standard Lisps are their own platforms
<ul class="org-ul">
<li>Already have ABCL, Kawa, and more on the JVM</li>
<li>Impedance mismatch with the JVM as host platform</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline8" class="outline-5">
<h5 id="orgheadline8">Why the JVM?&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline8">
<ul class="org-ul">
<li>VM, not OS, is target platform of the future</li>
<li>Type system</li>
<li>Dynamic enforcement and safety</li>
<li>Garbage collection</li>
<li>Libraries</li>
<li>Bytecode, just-in-time compilation</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline9" class="outline-5">
<h5 id="orgheadline9">Why ClojureScript?&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline9">
<ul class="org-ul">
<li>JavaScript has reach
<ul class="org-ul">
<li>Web browsers</li>
<li>Mobile devices</li>
<li>Databases, PDF, etc.</li>
</ul></li>
<li>JavaScript VMs getting faster</li>
<li>Clojure is simpler, more powerful, &amp; more robust than JS</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline10" class="outline-5">
<h5 id="orgheadline10">Clojure and ClojureScript&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline10">
<ul class="org-ul">
<li>This course will focus on Clojure</li>
<li>Code with no interop calls mostly works in both</li>
<li>Host platforms are different
<ul class="org-ul">
<li>Interop calls</li>
<li>Native types (strings, numbers)</li>
</ul></li>
<li>Can exchange serialized data with both</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline21" class="outline-4">
<h4 id="orgheadline21">Basic Syntax and the REPL&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline21">
</div><div id="outline-container-orgheadline11" class="outline-5">
<h5 id="orgheadline11">Literals&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline11">
<div class="org-src-container">

<pre class="src src-clojure">42           <span class="org-comment">; Long</span>
6.022e23     <span class="org-comment">; Double</span>

42N          <span class="org-comment">; BigInt</span>
1.0M         <span class="org-comment">; BigDecimal</span>
22/7         <span class="org-comment">; Ratio</span>

<span class="org-string">"hello"</span>      <span class="org-comment">; String</span>
\e           <span class="org-comment">; Character</span>
#<span class="org-string">"[0-9]"</span>     <span class="org-comment">; Regular Expression</span>
</pre>
</div>
</div>

<div id="outline-container-orgheadline12" class="outline-6">
<h6 id="orgheadline12">Instructor Notes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="notes">notes</span></span></h6>
<div class="outline-text-6" id="text-orgheadline12">
<ul class="org-ul">
<li>Comments start with a semicolon and go to the end of the line</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline13" class="outline-5">
<h5 id="orgheadline13">Literals&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline13">
<div class="org-src-container">

<pre class="src src-clojure">true  false                  <span class="org-comment">; Booleans</span>

nil                          <span class="org-comment">; null</span>

call-me  +  <span class="org-preprocessor">Fred</span>  *bob*      <span class="org-comment">; Symbols</span>

<span class="org-constant">:alpha</span>  <span class="org-constant">:beta</span>  <span class="org-constant">::my-keyword</span>  <span class="org-comment">; Keywords</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline14" class="outline-5">
<h5 id="orgheadline14">Literals in the REPL&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline14">
<div class="org-src-container">

<pre class="src src-clojure">user=&gt; 42       <span class="org-comment">; Read</span>
                <span class="org-comment">; Eval</span>
42              <span class="org-comment">; Print</span>
user=&gt;          <span class="org-comment">; Loop</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline15" class="outline-5">
<h5 id="orgheadline15">Expressions in the REPL&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline15">
<div class="org-src-container">

<pre class="src src-clojure">user=&gt; (<span class="org-variable-name">+</span> 3 4)  <span class="org-comment">; Read</span>
                <span class="org-comment">; Eval</span>
7               <span class="org-comment">; Print</span>
user=&gt;          <span class="org-comment">; Loop</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline16" class="outline-5">
<h5 id="orgheadline16">Binding Names With <code>def</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline16">
<div class="org-src-container">

<pre class="src src-clojure">user=&gt; pi     <span class="org-comment">; Not defined yet!!</span>
<span class="org-preprocessor">CompilerException</span> java.lang.RuntimeException: <span class="org-preprocessor">Unable</span> 
to resolve symbol: pi in this context ...

user=&gt; (<span class="org-keyword">def</span> <span class="org-function-name">pi</span> 3.14159)
#'user/pi

user=&gt; pi
3.14159
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline17" class="outline-5">
<h5 id="orgheadline17">Hello, World!&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline17">
<pre class="example">
user=&gt; (println "Hello, World!")
Hello, World!              ; printed output
nil                        ; return value
</pre>

<ul class="org-ul">
<li>REPL always shows return value</li>
<li>Printing is a side effect, returns <code>nil</code></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline18" class="outline-5">
<h5 id="orgheadline18">REPL Memory&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline18">
<pre class="example">
user=&gt; (+ 3 4)
7
user=&gt; (+ 10 *1)     ; *1 is most recent return value
17
user=&gt; (+ 100 *2)    ; *2 is next most recent
107
</pre>
</div>

<div id="outline-container-orgheadline19" class="outline-6">
<h6 id="orgheadline19">Instructor Notes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="notes">notes</span></span></h6>
<div class="outline-text-6" id="text-orgheadline19">
<ul class="org-ul">
<li>Our examples use these conventions:
<ul class="org-ul">
<li><code>;;</code> before printed output</li>
<li><code>;;=&gt;</code> before return values</li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline20" class="outline-5">
<h5 id="orgheadline20">Variants on Printing&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline20">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">Human-Readable</th>
<th scope="col" class="org-left">Machine-Readable</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">With newline</td>
<td class="org-left">&nbsp; <code>println</code></td>
<td class="org-left">&nbsp; <code>prn</code></td>
</tr>

<tr>
<td class="org-left">Without newline</td>
<td class="org-left">&nbsp; <code>print</code></td>
<td class="org-left">&nbsp; <code>pr</code></td>
</tr>
</tbody>
</table>

<pre class="example">
user=&gt; (println "one\ntwo")
one
two
nil

user=&gt; (prn "one\ntwo")
"one\ntwo"   ; quoted string, escaped newline
nil
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline31" class="outline-4">
<h4 id="orgheadline31">Evaluation and Data&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline31">
</div><div id="outline-container-orgheadline22" class="outline-5">
<h5 id="orgheadline22">Traditional Evaluation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline22">

<div class="figure">
<p><object type="image/svg+xml" data="slide-assets/traditional-evaluation.svg" >
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline23" class="outline-5">
<h5 id="orgheadline23">Clojure Evaluation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline23">

<div class="figure">
<p><object type="image/svg+xml" data="slide-assets/clojure-interactive-evaluation.svg" >
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline24" class="outline-5">
<h5 id="orgheadline24">Data Structures&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline24">
<div class="org-src-container">

<pre class="src src-clojure">(4 <span class="org-constant">:alpha</span> 3.0)     <span class="org-comment">; List</span>

[2 <span class="org-string">"hello"</span> 99]     <span class="org-comment">; Vector</span>

{<span class="org-constant">:a</span> 1, <span class="org-constant">:b</span> 2}       <span class="org-comment">; Map</span>

#{alice jim bob}   <span class="org-comment">; Set</span>
</pre>
</div>

<ul class="org-ul">
<li>Note: commas are whitespace</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline25" class="outline-5">
<h5 id="orgheadline25">Structure vs. Semantics&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline25">

<div class="figure">
<p><object type="image/svg+xml" data="slide-assets/structure-and-semantics.svg" >
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline26" class="outline-5">
<h5 id="orgheadline26">Operation Forms&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline26">
<div class="org-src-container">

<pre class="src src-clojure">(op ... )
</pre>
</div>

<ul class="org-ul">
<li><code>op</code> is "function position," can be any of:
<ul class="org-ul">
<li>Function: <code>+</code>, <code>mod</code>, <code>println</code></li>
<li>Macro: <code>when</code>, <code>cond</code>, <code>and</code></li>
<li>Special operator: <code>do</code>, <code>if</code>, <code>def</code></li>
<li>An expression which yields a function</li>
<li>More generally, something invocable (<code>clojure.lang.IFn</code>)</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline27" class="outline-5">
<h5 id="orgheadline27">Function Calls Always Use Parens&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline27">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">hello</span> [] <span class="org-string">"Hello, world!"</span>)  <span class="org-comment">; hello is a function</span>

hello                            <span class="org-comment">; return the function</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #&lt;user$hello user$hello@bda96b&gt;</span>

(hello)                          <span class="org-comment">; invoke the function</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "Hello, world!"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline28" class="outline-5">
<h5 id="orgheadline28">Values Never Use Parens&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline28">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">my-name</span> <span class="org-string">"Kelly Q. Programmer"</span>)  <span class="org-comment">; my-name is a value</span>

my-name                              <span class="org-comment">; return the value</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "Kelly Q. Programmer"</span>

(my-name)                            <span class="org-comment">; invoke the value</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">ClassCastException java.lang.String cannot be cast to clojure.lang.IFn</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline29" class="outline-5">
<h5 id="orgheadline29">Quote: Preventing Evaluation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline29">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">x</span> 3)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #'user/x</span>

(<span class="org-variable-name">+</span> x 2)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 5</span>

(quote (<span class="org-variable-name">+</span> x 2)) <span class="org-comment">; quoted list</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; (+ x 2)    ; returns list, unevaluated</span>

'(<span class="org-variable-name">+</span> x 2)        <span class="org-comment">; same as above</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; (+ x 2)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline30" class="outline-5">
<h5 id="orgheadline30">Quote: Preventing Evaluation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline30">
<div class="org-src-container">

<pre class="src src-clojure">(1 2 3)
<span class="org-comment-delimiter">;; </span><span class="org-comment">ClassCastException java.lang.Long cannot</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">be cast to clojure.lang.IFn</span>

'(1 2 3)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; (1 2 3)</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline38" class="outline-4">
<h4 id="orgheadline38">Discovering the Environment&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline38">
</div><div id="outline-container-orgheadline32" class="outline-5">
<h5 id="orgheadline32"><code>doc</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline32">
<div class="org-src-container">

<pre class="src src-clojure">user=&gt; (<span class="org-variable-name">use</span> 'clojure.repl)    <span class="org-comment">; quoted symbol</span>

user=&gt; (<span class="org-variable-name">doc</span> when)
<span class="org-comment-delimiter">;; </span><span class="org-comment">-------------------------</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">clojure.core/when</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">([test &amp; body])</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Macro</span>
<span class="org-comment-delimiter">;;   </span><span class="org-comment">Evaluates test. If logical true, evaluates</span>
<span class="org-comment-delimiter">;;   </span><span class="org-comment">body in an implicit do.</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; nil</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline33" class="outline-5">
<h5 id="orgheadline33"><code>find-doc</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline33">
<div class="org-src-container">

<pre class="src src-clojure">user=&gt; (<span class="org-variable-name">find-doc</span> <span class="org-string">"sequence"</span>)
<span class="org-comment-delimiter">;; </span><span class="org-comment">... all definitions with "sequence"</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">in their documentation ...</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; nil</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline34" class="outline-5">
<h5 id="orgheadline34"><code>apropos</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline34">
<div class="org-src-container">

<pre class="src src-clojure">user=&gt; (apropos <span class="org-string">"map"</span>)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; (clojure.core/Throwable-&gt;map clojure.core/amap clojure.core/array-map</span>
<span class="org-comment-delimiter">;;    </span><span class="org-comment">clojure.core/hash-map clojure.core/map clojure.core/map-entry?</span>
<span class="org-comment-delimiter">;;    </span><span class="org-comment">clojure.core/map-indexed clojure.core/map? clojure.core/mapcat</span>
<span class="org-comment-delimiter">;;    </span><span class="org-comment">clojure.core/mapv clojure.core/ns-map clojure.core/ns-unmap</span>
<span class="org-comment-delimiter">;;    </span><span class="org-comment">clojure.core/pmap clojure.core/proxy-mappings clojure.core/sorted-map</span>
<span class="org-comment-delimiter">;;    </span><span class="org-comment">clojure.core/sorted-map-by clojure.core/struct-map clojure.core/zipmap)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline35" class="outline-5">
<h5 id="orgheadline35"><code>source</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline35">
<div class="org-src-container">

<pre class="src src-clojure">user=&gt; (source not)
<span class="org-comment-delimiter">;; </span><span class="org-comment">(defn not</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">"Returns true if x is logical false, false otherwise."</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">{:tag Boolean</span>
<span class="org-comment-delimiter">;;   </span><span class="org-comment">:added "1.0"</span>
<span class="org-comment-delimiter">;;   </span><span class="org-comment">:static true}</span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">[x] (if x false true))</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; nil</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline36" class="outline-5">
<h5 id="orgheadline36"><code>dir</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline36">
<div class="org-src-container">

<pre class="src src-clojure">user=&gt; (dir clojure.repl)
<span class="org-comment-delimiter">;; </span><span class="org-comment">apropos</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">demunge</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">dir</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">dir-fn</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">doc</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">find-doc</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">pst</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">root-cause</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">set-break-handler!</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">source</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">source-fn</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">stack-element-str</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">thread-stopper</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; nil</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline37" class="outline-5">
<h5 id="orgheadline37">Cheat Sheet&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline37">
<ul class="org-ul">
<li><a href="http://clojure.org/api/cheatsheet">http://clojure.org/api/cheatsheet</a></li>
<li><code>cheatsheet.pdf</code> in supplied files</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline47" class="outline-4">
<h4 id="orgheadline47">Project Management&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline47">
</div><div id="outline-container-orgheadline39" class="outline-5">
<h5 id="orgheadline39">clj&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline39">
<ul class="org-ul">
<li>Command-line tool for:
<ul class="org-ul">
<li>Running interactive REPL</li>
<li>Running Clojure programs</li>
<li>Evaluating Clojure expressions</li>
</ul></li>
<li>For installation, see:
<ul class="org-ul">
<li><a href="https://clojure.org/guides/getting_started">https://clojure.org/guides/getting_started</a></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline40" class="outline-5">
<h5 id="orgheadline40">clj modes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline40">
<div class="org-src-container">

<pre class="src src-shell-script">clj                   <span class="org-comment-delimiter"># </span><span class="org-comment">Start a REPL</span>
clj &lt;script&gt;          <span class="org-comment-delimiter"># </span><span class="org-comment">Run .clj script</span>
clj -m &lt;ns&gt;           <span class="org-comment-delimiter"># </span><span class="org-comment">Call -main in &lt;ns&gt;</span>
clj -e &lt;expr&gt;         <span class="org-comment-delimiter"># </span><span class="org-comment">Run Clojure expression</span>
clj -h                <span class="org-comment-delimiter"># </span><span class="org-comment">Help</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline41" class="outline-5">
<h5 id="orgheadline41">Using Libraries&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline41">
<ul class="org-ul">
<li>Find the library</li>
<li>Specify library name and version</li>
<li>Download the library</li>
<li>Add the library to the JVM classpath</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline42" class="outline-5">
<h5 id="orgheadline42">Finding Libraries&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline42">
<ul class="org-ul">
<li>Clojure Toolbox: <a href="http://www.clojure-toolbox.com/">http://www.clojure-toolbox.com/</a></li>
<li>Clojure-contrib: <a href="https://clojure.org/api/api">https://clojure.org/api/api</a></li>
<li>Clojure community libs: <a href="http://clojars.org">Clojars.org</a></li>
<li>Java libs: <a href="http://search.maven.org/">search.maven.org</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline43" class="outline-5">
<h5 id="orgheadline43">Specify library name and version&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline43">
<ul class="org-ul">
<li>deps.edn can be used to specify one or more deps:</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">{<span class="org-constant">:deps</span>
 {clj-time {<span class="org-constant">:mvn/version</span> <span class="org-string">"0.14.2"</span>}}}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline44" class="outline-5">
<h5 id="orgheadline44">Specify Clojure version&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline44">
<ul class="org-ul">
<li>Clojure included automatically via user-level deps.edn</li>
<li>Or override in deps.edn:</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">{<span class="org-constant">:deps</span>
 {org.clojure/clojure {<span class="org-constant">:mvn/version</span> <span class="org-string">"1.10.0-beta8"</span>}
  clj-time {<span class="org-constant">:mvn/version</span> <span class="org-string">"0.14.2"</span>}}}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline45" class="outline-5">
<h5 id="orgheadline45">Other clj features&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline45">
<ul class="org-ul">
<li>Automatic library download and classpath caching</li>
<li>Dep types: Maven, git, local files, local jar</li>
<li>pom.xml generation</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline46" class="outline-5">
<h5 id="orgheadline46">Other clj tools&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline46">
<ul class="org-ul">
<li>List of tools: <a href="https://github.com/clojure/tools.deps.alpha/wiki/Tools">https://github.com/clojure/tools.deps.alpha/wiki/Tools</a></li>
<li>Test runners - test-runner, Kaocha</li>
<li>Finding out of date deps - depot</li>
<li>Packaging - depstar, Pack, Cambada</li>
<li>Deployment - deps-deploy</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline48" class="outline-3">
<h3 id="orgheadline48">LAB: Exploring the REPL&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-orgheadline48">
</div>

<div id="outline-container-orgheadline49" class="outline-4">
<h4 id="orgheadline49">Simple Arithmetic</h4>
<div class="outline-text-4" id="text-orgheadline49">
<p>
Using the REPL, compute the sum of 7654 and 1234.
</p>
</div>

<div id="outline-container-orgheadline50" class="outline-5">
<h5 id="orgheadline50">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline50">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">+</span> 7654 1234)
</pre>
</div>

<pre class="example">
;;=&gt; 8888
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline51" class="outline-4">
<h4 id="orgheadline51">Order of Operations</h4>
<div class="outline-text-4" id="text-orgheadline51">
<p>
Rewrite the following arithmetic expression as a Clojure expression and evaluate it at the REPL:
</p>

<p>
( 7 + 3 * 4 + 5 ) / 10
</p>
</div>

<div id="outline-container-orgheadline52" class="outline-5">
<h5 id="orgheadline52">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline52">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">/</span> (<span class="org-variable-name">+</span> 7 (<span class="org-variable-name">*</span> 3 4) 5) 10)
</pre>
</div>

<pre class="example">
;;=&gt; 12/5
</pre>
</div>
</div>

<div id="outline-container-orgheadline53" class="outline-5">
<h5 id="orgheadline53">Notes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline53">
<ul class="org-ul">
<li>Clojure does not need an operator precedence table</li>
<li>Division of integers returns a ratio</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline54" class="outline-4">
<h4 id="orgheadline54">Finding Documentation by Name</h4>
<div class="outline-text-4" id="text-orgheadline54">
<p>
Using REPL documentation functions, find the documentation for the <b>rem</b> and <b>mod</b> functions. Evaluate some expressions that demonstrate the difference between these two functions.
</p>
</div>

<div id="outline-container-orgheadline55" class="outline-5">
<h5 id="orgheadline55">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline55">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">use</span> 'clojure.repl)
(<span class="org-variable-name">doc</span> mod)
(<span class="org-variable-name">doc</span> rem)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">rem</span> 10 -8)
</pre>
</div>

<pre class="example">
;;=&gt; 2
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">mod</span> 10 -8)
</pre>
</div>

<pre class="example">
;;=&gt; -6
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline56" class="outline-4">
<h4 id="orgheadline56">Discovering Exceptions</h4>
<div class="outline-text-4" id="text-orgheadline56">
<p>
Using <b>find-doc</b>, find the function that prints the stack trace of the most recent REPL exception.
</p>
</div>

<div id="outline-container-orgheadline57" class="outline-5">
<h5 id="orgheadline57">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline57">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">find-doc</span> <span class="org-string">"stack trace"</span>)
<span class="org-comment-delimiter">;; </span><span class="org-comment">-------------------------</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">clojure.repl/pst</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">([] [e-or-depth] [e depth])</span>
<span class="org-comment-delimiter">;;   </span><span class="org-comment">Prints a stack trace of the exception, to the</span>
<span class="org-comment-delimiter">;;   </span><span class="org-comment">depth requested. If none supplied, uses the root</span>
<span class="org-comment-delimiter">;;   </span><span class="org-comment">cause of the most recent repl exception (*e),</span>
<span class="org-comment-delimiter">;;   </span><span class="org-comment">and a depth of 12.</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline58" class="outline-4">
<h4 id="orgheadline58">Creating &amp; Viewing Exceptions</h4>
<div class="outline-text-4" id="text-orgheadline58">
<p>
Evaluate an expression that throws an exception. Then print the stack trace of that exception.
</p>
</div>

<div id="outline-container-orgheadline59" class="outline-5">
<h5 id="orgheadline59">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline59">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">/</span> 1 0)
<span class="org-comment-delimiter">;; </span><span class="org-comment">ArithmeticException Divide by zero</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">clojure.lang.Numbers.divide (Numbers.java:156)</span>

(pst)
<span class="org-comment-delimiter">;; </span><span class="org-comment">ArithmeticException Divide by zero</span>
<span class="org-comment-delimiter">;;      </span><span class="org-comment">clojure.lang.Numbers.divide (Numbers.java:156)</span>
<span class="org-comment-delimiter">;;      </span><span class="org-comment">clojure.lang.Numbers.divide (Numbers.java:3677)</span>
<span class="org-comment-delimiter">;;      </span><span class="org-comment">user/eval15 (NO_SOURCE_FILE:4)</span>
<span class="org-comment-delimiter">;;      </span><span class="org-comment">...</span>
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline60" class="outline-3">
<h3 id="orgheadline60">Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-orgheadline60">
</div>

<div id="outline-container-orgheadline61" class="outline-4">
<h4 id="orgheadline61">Motivation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline61">
<ul class="org-ul">
<li>Clojure is a functional language</li>
<li>Functions are a first-class abstraction
<ul class="org-ul">
<li>Can be stored, passed as arguments, invoked</li>
</ul></li>
<li>Ubiquitous support for high-order functions</li>
<li>Core code (almost) entirely pure functions
<ul class="org-ul">
<li>i.e., no side-effects</li>
</ul></li>
<li>The obvious place to start&#x2026;</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline72" class="outline-4">
<h4 id="orgheadline72">Creating Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline72">
</div><div id="outline-container-orgheadline62" class="outline-5">
<h5 id="orgheadline62"><code>defn</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline62">
<ul class="org-ul">
<li><code>defn</code> defines a named function</li>
</ul>
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;;    </span><span class="org-comment">name   params         body</span>
<span class="org-comment-delimiter">;;    </span><span class="org-comment">-----  ------  -------------------</span>
(<span class="org-keyword">defn</span> <span class="org-function-name">greet</span>  [name]  (<span class="org-variable-name">str</span> <span class="org-string">"Hello, "</span> name) )
</pre>
</div>

<ul class="org-ul">
<li>Invoke with the name in "function position"</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(greet <span class="org-string">"students"</span>)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "Hello, students"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline63" class="outline-5">
<h5 id="orgheadline63">Multi-arity functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline63">
<ul class="org-ul">
<li>Can overload function by <b>arity</b> (number of arguments)</li>
<li>Each arity is a list <code>([<i style="font-family:serif">args*</i>] <i style="font-family:serif">body*</i>)</code></li>
<li>One arity can invoke another</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">messenger</span>
  ([]                             <span class="org-comment">; no args</span>
     (messenger <span class="org-string">"Hello world!"</span>))  <span class="org-comment">; call self with default</span>
  ([msg]              <span class="org-comment">; one arg</span>
     (<span class="org-variable-name">println</span> msg)))  <span class="org-comment">; print it</span>

(messenger)
<span class="org-comment-delimiter">;; </span><span class="org-comment">Hello world!</span>
(messenger <span class="org-string">"Hello class!"</span>)
<span class="org-comment-delimiter">;; </span><span class="org-comment">Hello class!</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline64" class="outline-5">
<h5 id="orgheadline64">Variadic Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline64">
<ul class="org-ul">
<li><b>Variadic:</b> any number of arguments</li>
<li>Specified by <code>&amp;</code> symbol in params 
<ul class="org-ul">
<li>Next param collects all remaining arguments</li>
<li>Collected arguments represented as sequence</li>
</ul></li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">messenger</span> [greeting &amp; who]
  (<span class="org-variable-name">println</span> greeting who))

(messenger <span class="org-string">"Hello"</span> <span class="org-string">"world"</span> <span class="org-string">"class"</span>)
<span class="org-comment-delimiter">;; </span><span class="org-comment">Hello (world class)</span>
</pre>
</div>
</div>

<div id="outline-container-orgheadline65" class="outline-6">
<h6 id="orgheadline65">Instructor Notes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="notes">notes</span></span></h6>
<div class="outline-text-6" id="text-orgheadline65">
<ul class="org-ul">
<li>Sequences look and behave like lists</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline66" class="outline-5">
<h5 id="orgheadline66">Anonymous Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline66">
<ul class="org-ul">
<li><code>fn</code> creates <i>anonymous</i> function with no name</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;;      </span><span class="org-comment">params         body</span>
<span class="org-comment-delimiter">;;     </span><span class="org-comment">---------  ---------------</span>
  (<span class="org-variable-name">fn</span>  [message]  (<span class="org-variable-name">println</span> message) )
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline67" class="outline-5">
<h5 id="orgheadline67">Invoking Anonymous Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline67">
<ul class="org-ul">
<li><code>(op ...)</code></li>
<li>Invoke a function with <code>fn</code> itself in function position</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;;     </span><span class="org-comment">operation (function)             argument</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">--------------------------------  --------------</span>
(  (<span class="org-variable-name">fn</span> [message] (<span class="org-variable-name">println</span> message))  <span class="org-string">"Hello world!"</span> )

<span class="org-comment-delimiter">;; </span><span class="org-comment">Hello world!</span>
</pre>
</div>
</div>

<div id="outline-container-orgheadline68" class="outline-6">
<h6 id="orgheadline68">Instructor notes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="notes">notes</span></span></h6>
<div class="outline-text-6" id="text-orgheadline68">
<ul class="org-ul">
<li>Extra whitespace to show structure</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline69" class="outline-5">
<h5 id="orgheadline69"><code>defn</code> and <code>fn</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline69">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">greet</span> [name] (<span class="org-variable-name">str</span> <span class="org-string">"Hello, "</span> name))

<span class="org-comment-delimiter">;; </span><span class="org-comment">is just a shortcut for</span>
(<span class="org-keyword">def</span> <span class="org-function-name">greet</span> (<span class="org-variable-name">fn</span> [name] (<span class="org-variable-name">str</span> <span class="org-string">"Hello, "</span> name)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline70" class="outline-5">
<h5 id="orgheadline70">Function Reader Macro&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline70">
<ul class="org-ul">
<li>Terse form <code>#()</code> for short functions defined inline
<ul class="org-ul">
<li>Single argument: <code>%</code></li>
<li>Multiple arguments: <code>%1</code>, <code>%2</code>, <code>%3</code>, &#x2026;</li>
<li>Variadic: <code>%&amp;</code> for remaining arguments</li>
</ul></li>
<li>Can't nest</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">A function to add 6 to arg:</span>
#(<span class="org-variable-name">+</span> 6 %)
<span class="org-comment-delimiter">;; </span><span class="org-comment">Equivalent to:</span>
(<span class="org-variable-name">fn</span> [x] (<span class="org-variable-name">+</span> 6 x))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline71" class="outline-5">
<h5 id="orgheadline71">Function Reader Macro&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline71">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">Wrong way to make a vector:</span>
#([%])

<span class="org-comment-delimiter">;; </span><span class="org-comment">Because it expands to:</span>
(<span class="org-variable-name">fn</span> [x] ([x]))
<span class="org-comment-delimiter">;; </span><span class="org-comment">Which tries to invoke the vector.</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">What you really wanted:</span>
(<span class="org-variable-name">fn</span> [x]  [x])
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline78" class="outline-4">
<h4 id="orgheadline78">Applying Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline78">
</div><div id="outline-container-orgheadline73" class="outline-5">
<h5 id="orgheadline73"><code>apply</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline73">
<ul class="org-ul">
<li>Invokes function on arguments</li>
<li>Final argument is a sequence</li>
<li>"Unpacks" remaining arguments from a sequence</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(f 1 2 3 4)                  <span class="org-comment-delimiter">;; </span><span class="org-comment">this calls f with args 1 2 3 4</span>

(<span class="org-variable-name">apply</span> f '(1 2 3 4))         <span class="org-comment-delimiter">;; </span><span class="org-comment">so does this</span>

(<span class="org-variable-name">apply</span> f 1 '(2 3 4))         <span class="org-comment-delimiter">;; </span><span class="org-comment">and so does this</span>

(<span class="org-variable-name">apply</span> f 1 2 '(3 4))         <span class="org-comment-delimiter">;; </span><span class="org-comment">and so does this</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline74" class="outline-5">
<h5 id="orgheadline74"><code>apply</code> and Variadics&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline74">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">&amp; puts rest of args into sequence</span>
(<span class="org-keyword">defn</span> <span class="org-function-name">messenger</span> [greeting &amp; who]
  <span class="org-comment-delimiter">;; </span><span class="org-comment">apply gets args from sequence</span>
  (<span class="org-variable-name">apply</span> println greeting who))

(messenger <span class="org-string">"Hello"</span> <span class="org-string">"world"</span> <span class="org-string">"class"</span>)
<span class="org-comment-delimiter">;; </span><span class="org-comment">Hello world class</span>
</pre>
</div>
</div>

<div id="outline-container-orgheadline75" class="outline-6">
<h6 id="orgheadline75">Instructor Notes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="notes">notes</span></span></h6>
<div class="outline-text-6" id="text-orgheadline75">
<ul class="org-ul">
<li>Similar to <code>*splat</code> in Ruby</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline76" class="outline-5">
<h5 id="orgheadline76">Partial Application&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline76">
<p>
Sometimes we want to "bake in" one or more arguments to a
new function call:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">x10</span> [&amp; nums]
  (<span class="org-variable-name">apply</span> * 10 nums))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline77" class="outline-5">
<h5 id="orgheadline77"><code>partial</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline77">
<ul class="org-ul">
<li><code>partial</code> - partially applies a function f with a subset of the args</li>
<li>returns a new function that takes the remaining args and invokes with apply</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">*</span> 10 5)                      <span class="org-comment-delimiter">;; </span><span class="org-comment">50</span>

(<span class="org-keyword">def</span> <span class="org-function-name">x10</span> (<span class="org-variable-name">partial</span> * 10))

(x10 5)                       <span class="org-comment-delimiter">;; </span><span class="org-comment">50</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline83" class="outline-4">
<h4 id="orgheadline83">Locals and Closures&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline83">
</div><div id="outline-container-orgheadline79" class="outline-5">
<h5 id="orgheadline79"><code>let</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline79">
<ul class="org-ul">
<li><code>let</code> binds <i>symbols</i> to immutable <i>values</i>
<ul class="org-ul">
<li>Values may be literals or expressions</li>
</ul></li>
<li>Bound symbols are available in <i>lexical scope</i></li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;;      </span><span class="org-comment">bindings    code that uses name</span>
<span class="org-comment-delimiter">;;    </span><span class="org-comment">------------  -------------------</span>
(<span class="org-builtin">let</span>  [name value]         ...        )
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline80" class="outline-5">
<h5 id="orgheadline80"><code>let</code> Example&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline80">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">messenger</span> [msg]
  (<span class="org-builtin">let</span> [a 7
        b 5
        c (capitalize msg)]
    (<span class="org-variable-name">println</span> a b c)
  )  <span class="org-comment">; end of 'let' scope</span>
)  <span class="org-comment">; end of function</span>
</pre>
</div>
</div>

<div id="outline-container-orgheadline81" class="outline-6">
<h6 id="orgheadline81">Instructor Notes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="notes">notes</span></span></h6>
<div class="outline-text-6" id="text-orgheadline81">
<ul class="org-ul">
<li>Extra whitespace to show structure</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline82" class="outline-5">
<h5 id="orgheadline82">Closures&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline82">
<ul class="org-ul">
<li><code>fn</code> creates a <i>closure</i>
<ul class="org-ul">
<li>"closes" over surrounding lexical scope</li>
</ul></li>
<li>Closed-over locals persist beyond lexical scope</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">messenger-builder</span> [greeting]
  (<span class="org-variable-name">fn</span> [who] (<span class="org-variable-name">println</span> greeting who))) <span class="org-comment">; closes over greeting</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">greeting provided here, then goes out of scope</span>
(<span class="org-keyword">def</span> <span class="org-function-name">hello-er</span> (messenger-builder <span class="org-string">"Hello"</span>))

<span class="org-comment-delimiter">;; </span><span class="org-comment">greeting still available because hello-er is closure</span>
(hello-er <span class="org-string">"world!"</span>)
<span class="org-comment-delimiter">;; </span><span class="org-comment">Hello world!</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline86" class="outline-4">
<h4 id="orgheadline86">Java Interop&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline86">
</div><div id="outline-container-orgheadline84" class="outline-5">
<h5 id="orgheadline84">Invoking Java Code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline84">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Task</th>
<th scope="col" class="org-left">Java</th>
<th scope="col" class="org-left">Clojure</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Instantiation</td>
<td class="org-left"><code>new Widget("foo")</code></td>
<td class="org-left"><code>(Widget. "foo")</code></td>
</tr>

<tr>
<td class="org-left">Instance method</td>
<td class="org-left"><code>rnd.nextInt()</code></td>
<td class="org-left"><code>(.nextInt rnd)</code></td>
</tr>

<tr>
<td class="org-left">Instance field</td>
<td class="org-left"><code>object.field</code></td>
<td class="org-left"><code>(.-field object)</code></td>
</tr>

<tr>
<td class="org-left">Static method</td>
<td class="org-left"><code>Math.sqrt(25)</code></td>
<td class="org-left"><code>(Math/sqrt 25)</code></td>
</tr>

<tr>
<td class="org-left">Static field</td>
<td class="org-left"><code>Math.PI</code></td>
<td class="org-left"><code>Math/PI</code></td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>Note: <code>(.-field obj)</code> syntax added in Clojure 1.4
<ul class="org-ul">
<li>Previously was <code>(.field obj)</code> - still works with either</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline85" class="outline-5">
<h5 id="orgheadline85">Java Methods vs Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline85">
<ul class="org-ul">
<li>Java methods are not Clojure functions</li>
<li>Can't store them, pass them as arguments</li>
<li>Can wrap them in functions when necessary</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">make a function to invoke .length on arg</span>
(<span class="org-variable-name">fn</span> [obj] (<span class="org-preprocessor">.length</span> obj))

<span class="org-comment-delimiter">;; </span><span class="org-comment">same thing</span>
#(<span class="org-preprocessor">.length</span> %)
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline87" class="outline-3">
<h3 id="orgheadline87">LAB: Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-orgheadline87">
</div>

<div id="outline-container-orgheadline88" class="outline-4">
<h4 id="orgheadline88">Defining a function</h4>
<div class="outline-text-4" id="text-orgheadline88">
<p>
Define a function <code>greet</code> that takes no arguments and prints "Hello".
</p>
</div>

<div id="outline-container-orgheadline89" class="outline-5">
<h5 id="orgheadline89">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline89">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">greet</span> []
  (<span class="org-variable-name">println</span> <span class="org-string">"Hello"</span>))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline90" class="outline-4">
<h4 id="orgheadline90">Different ways to define functions</h4>
<div class="outline-text-4" id="text-orgheadline90">
<p>
Redefine <code>greet</code> using <code>def</code>, first with the <code>fn</code> special form and then with the <code>#()</code> reader macro.
</p>
</div>

<div id="outline-container-orgheadline91" class="outline-5">
<h5 id="orgheadline91">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline91">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">greet</span> (<span class="org-variable-name">fn</span> [] (<span class="org-variable-name">println</span> <span class="org-string">"Hello"</span>)))

(<span class="org-keyword">def</span> <span class="org-function-name">greet</span> #(<span class="org-variable-name">println</span> <span class="org-string">"Hello"</span>))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline92" class="outline-4">
<h4 id="orgheadline92">Arities with defaults</h4>
<div class="outline-text-4" id="text-orgheadline92">
<p>
Define a function <code>greeting</code> which:
</p>

<ul class="org-ul">
<li>Given no arguments, returns "Hello, World!"</li>
<li>Given one argument <i>x</i>, returns "Hello, <i>x</i>!"</li>
<li>Given two arguments <i>x</i> and <i>y</i>, returns "<i>x</i>, <i>y</i>!"</li>
</ul>

<p>
Hint: use the <code>str</code> function to concatenate strings.
</p>
</div>

<div id="outline-container-orgheadline93" class="outline-5">
<h5 id="orgheadline93">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline93">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">greeting</span>
  ([] (greeting <span class="org-string">"Hello"</span> <span class="org-string">"World"</span>))
  ([x] (greeting <span class="org-string">"Hello"</span> x))
  ([x y] (<span class="org-variable-name">str</span> x <span class="org-string">", "</span> y <span class="org-string">"!"</span>)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline94" class="outline-5">
<h5 id="orgheadline94">Tests&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline94">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">assert</span> (<span class="org-variable-name">=</span> <span class="org-string">"Hello, World!"</span> (greeting)))
(<span class="org-variable-name">assert</span> (<span class="org-variable-name">=</span> <span class="org-string">"Hello, Clojure!"</span> (greeting <span class="org-string">"Clojure"</span>)))
(<span class="org-variable-name">assert</span> (<span class="org-variable-name">=</span> <span class="org-string">"Good morning, Clojure!"</span>
           (greeting <span class="org-string">"Good morning"</span> <span class="org-string">"Clojure"</span>)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline95" class="outline-4">
<h4 id="orgheadline95">Do nothing</h4>
<div class="outline-text-4" id="text-orgheadline95">
<p>
Define a function <code>do-nothing</code> which takes a single argument <code>x</code> and returns it, unchanged.
</p>
</div>

<div id="outline-container-orgheadline96" class="outline-5">
<h5 id="orgheadline96">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline96">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">do-nothing</span> [x] x)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline97" class="outline-5">
<h5 id="orgheadline97">Notes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline97">
<p>
In Clojure, this is the <code>identity</code> function.
</p>

<p>
By itself, <code>identity</code> is not very useful, but it can be helpful when working with higher-order functions.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">identity</span>
  <span class="org-doc">"Returns its argument."</span>
  [x] x)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline98" class="outline-4">
<h4 id="orgheadline98">Do one thing well</h4>
<div class="outline-text-4" id="text-orgheadline98">
<p>
Define a function <code>always-thing</code> which takes <i>any</i> number of arguments, ignores all of them, and returns the keyword <code>:thing</code>.
</p>
</div>

<div id="outline-container-orgheadline99" class="outline-5">
<h5 id="orgheadline99">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline99">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">always-thing</span> [&amp; args] <span class="org-constant">:thing</span>)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline100" class="outline-4">
<h4 id="orgheadline100">Do many things</h4>
<div class="outline-text-4" id="text-orgheadline100">
<p>
Define a function <code>make-thingy</code> which takes a single argument <code>x</code>. It should return <i>another function</i> which takes <i>any</i> number of arguments and always returns <i>x</i>.
</p>
</div>

<div id="outline-container-orgheadline101" class="outline-5">
<h5 id="orgheadline101">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline101">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">make-thingy</span> [x]
  (<span class="org-variable-name">fn</span> [&amp; args] x))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline102" class="outline-5">
<h5 id="orgheadline102">Tests&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline102">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">let</span> [n (<span class="org-variable-name">rand-int</span> <span class="org-preprocessor">Integer/MAX_VALUE</span>)
      f (make-thingy n)]
  (<span class="org-variable-name">assert</span> (<span class="org-variable-name">=</span> n (f)))
  (<span class="org-variable-name">assert</span> (<span class="org-variable-name">=</span> n (f <span class="org-constant">:foo</span>)))
  (<span class="org-variable-name">assert</span> (<span class="org-variable-name">=</span> n (<span class="org-variable-name">apply</span> f <span class="org-constant">:foo</span> (<span class="org-variable-name">range</span>)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline103" class="outline-5">
<h5 id="orgheadline103">Notes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline103">
<p>
In Clojure, this is the <code>constantly</code> function.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">constantly</span>
  <span class="org-doc">"Returns a function that takes any number of arguments and returns x."</span>
  [x] (<span class="org-variable-name">fn</span> [&amp; args] x))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline104" class="outline-4">
<h4 id="orgheadline104">In triplicate</h4>
<div class="outline-text-4" id="text-orgheadline104">
<p>
Define a function <code>triplicate</code> which takes another function and calls it three times, without any arguments.
</p>
</div>

<div id="outline-container-orgheadline105" class="outline-5">
<h5 id="orgheadline105">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline105">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">triplicate</span> [f]
  (f) (f) (f))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline106" class="outline-4">
<h4 id="orgheadline106">Do the opposite</h4>
<div class="outline-text-4" id="text-orgheadline106">
<p>
Define a function <code>opposite</code> which takes a single argument <code>f</code>. It should return <i>another function</i> which takes <i>any number</i> of arguments, applies <code>f</code> on them, and then calls <code>not</code> on the result.
</p>

<p>
The <code>not</code> function in Clojure does logical negation.
</p>
</div>

<div id="outline-container-orgheadline107" class="outline-5">
<h5 id="orgheadline107">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline107">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">opposite</span> [f]
  (<span class="org-variable-name">fn</span> [&amp; args] (<span class="org-variable-name">not</span> (<span class="org-variable-name">apply</span> f args))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline108" class="outline-5">
<h5 id="orgheadline108">Notes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline108">
<p>
In Clojure, this is the <code>complement</code> function.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">complement</span>
  <span class="org-doc">"Takes a fn f and returns a fn that takes the same arguments as f,</span>
<span class="org-doc">  has the same effects, if any, and returns the opposite truth value."</span>
  [f] 
  (<span class="org-variable-name">fn</span> 
    ([] (<span class="org-variable-name">not</span> (f)))
    ([x] (<span class="org-variable-name">not</span> (f x)))
    ([x y] (<span class="org-variable-name">not</span> (f x y)))
    ([x y &amp; zs] (<span class="org-variable-name">not</span> (<span class="org-variable-name">apply</span> f x y zs)))))
</pre>
</div>

<p>
Many functions in <code>clojure.core</code> have multiple arities as a performance optimization.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline109" class="outline-4">
<h4 id="orgheadline109">In triplicate redux</h4>
<div class="outline-text-4" id="text-orgheadline109">
<p>
Define a function <code>triplicate2</code> which takes another function and any number of arguments, then calls that function three times on those arguments. Re-use the function you defined in the earlier "Triplicate" exercise.
</p>
</div>

<div id="outline-container-orgheadline110" class="outline-5">
<h5 id="orgheadline110">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline110">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">triplicate2</span> [f &amp; args]
  (triplicate (<span class="org-variable-name">fn</span> [] (<span class="org-variable-name">apply</span> f args))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline111" class="outline-4">
<h4 id="orgheadline111">Squaring the circle</h4>
<div class="outline-text-4" id="text-orgheadline111">
<p>
Using the <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Math.html">java.lang.Math</a> class, demonstrate the following mathematical facts:
</p>

<ul class="org-ul">
<li>The cosine of Pi is -1</li>
<li>For some <i>x</i>, sin(x) ^ 2 + cos(x) ^ 2 = 1</li>
</ul>
</div>

<div id="outline-container-orgheadline112" class="outline-5">
<h5 id="orgheadline112">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline112">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-preprocessor">Math/cos</span> <span class="org-preprocessor">Math/PI</span>)
</pre>
</div>

<pre class="example">
;;=&gt; -1.0
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">+</span> (<span class="org-preprocessor">Math/pow</span> (<span class="org-preprocessor">Math/sin</span> <span class="org-preprocessor">Math/PI</span>) 2)
   (<span class="org-preprocessor">Math/pow</span> (<span class="org-preprocessor">Math/cos</span> <span class="org-preprocessor">Math/PI</span>) 2))
</pre>
</div>

<pre class="example">
;;=&gt; 1.0
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline113" class="outline-4">
<h4 id="orgheadline113">Go fetch</h4>
<div class="outline-text-4" id="text-orgheadline113">
<p>
Define a function that takes an HTTP URL as a string, fetches that URL from the web, and returns the content as a string.
</p>

<p>
Hint: Using the <a href="http://docs.oracle.com/javase/7/docs/api/java/net/URL.html">java.net.URL</a> class and its <code>openStream</code> method. Then use the Clojure <code>slurp</code> function to get the content as a string.
</p>
</div>

<div id="outline-container-orgheadline114" class="outline-5">
<h5 id="orgheadline114">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline114">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">http-get</span> [url]
  (<span class="org-variable-name">slurp</span> (<span class="org-preprocessor">.openStream</span> (<span class="org-preprocessor">java.net.URL.</span> url))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline115" class="outline-5">
<h5 id="orgheadline115">Tests&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline115">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">assert</span> (<span class="org-preprocessor">.contains</span> (http-get <span class="org-string">"http://www.w3.org/"</span>) <span class="org-string">"html"</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline116" class="outline-5">
<h5 id="orgheadline116">Notes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline116">
<p>
In fact, the Clojure <code>slurp</code> function is all that is needed, because it interprets its argument as a URL first and, failing that, as a file name.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline117" class="outline-4">
<h4 id="orgheadline117">Getting into the Swing of things</h4>
<div class="outline-text-4" id="text-orgheadline117">
<p>
Translate the following Java code into a single Clojure function <code>sample-app</code>. Don't worry if you aren't familiar with the Java Swing API: the point is to practice using interop forms.
</p>

<div class="org-src-container">

<pre class="src src-fundamental">import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;

public class SampleApp {
    public static void main(String[] args) {
        JPanel panel = new JPanel();
        panel.setOpaque(true);

        JLabel label = new JLabel(<span class="org-string">"Click the button!"</span>);
        panel.add(label);

        JButton button = new JButton(<span class="org-string">"Go"</span>);
        panel.add(button);

        JFrame frame = new JFrame(<span class="org-string">"Sample Application"</span>);
        frame.setContentPane(panel);
        frame.setSize(300, 100);
        frame.setVisible(true);
    }
}
</pre>
</div>
</div>

<div id="outline-container-orgheadline118" class="outline-5">
<h5 id="orgheadline118">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline118">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">import</span> (javax.swing <span class="org-preprocessor">JLabel</span> <span class="org-preprocessor">JButton</span> <span class="org-preprocessor">JPanel</span> <span class="org-preprocessor">JFrame</span>))

(<span class="org-keyword">defn</span> <span class="org-function-name">sample-app</span> []
  (<span class="org-builtin">let</span> [label (<span class="org-preprocessor">JLabel.</span> <span class="org-string">"Click the button!"</span>)
        button (<span class="org-preprocessor">JButton.</span> <span class="org-string">"Go"</span>)
        panel (<span class="org-preprocessor">JPanel.</span>)
        frame (<span class="org-preprocessor">JFrame.</span> <span class="org-string">"Sample Application"</span>)]
    (<span class="org-preprocessor">.setOpaque</span> panel true)
    (<span class="org-preprocessor">.add</span> panel label)
    (<span class="org-preprocessor">.add</span> panel button)
    (<span class="org-preprocessor">.setContentPane</span> frame panel)
    (<span class="org-preprocessor">.setSize</span> frame 300 100)
    (<span class="org-preprocessor">.setVisible</span> frame true)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline130" class="outline-4">
<h4 id="orgheadline130">Bonus Questions</h4>
<div class="outline-text-4" id="text-orgheadline130">
</div><div id="outline-container-orgheadline119" class="outline-5">
<h5 id="orgheadline119">Partial Function Application</h5>
<div class="outline-text-5" id="text-orgheadline119">
<p>
Define a function <code>one-less-arg</code> that takes two arguments:
</p>

<ul class="org-ul">
<li><code>f</code>, a function</li>
<li><code>x</code>, a value</li>
</ul>

<p>
It returns <i>another function</i> which calls <code>f</code> on <code>x</code> plus any additional arguments.
</p>
</div>

<div id="outline-container-orgheadline120" class="outline-6">
<h6 id="orgheadline120">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline120">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">one-less-arg</span> [f x]
  (<span class="org-variable-name">fn</span> [&amp; args] (<span class="org-variable-name">apply</span> f x args)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline121" class="outline-6">
<h6 id="orgheadline121">Notes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline121">
<p>
In Clojure, the <code>partial</code> function is a more general version of this.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">partial</span>
  <span class="org-doc">"Takes a function f and fewer than the normal arguments to f, and</span>
<span class="org-doc">  returns a fn that takes a variable number of additional args. When</span>
<span class="org-doc">  called, the returned function calls f with args + additional args."</span>
  ([f arg1]
   (<span class="org-variable-name">fn</span> [&amp; args] (<span class="org-variable-name">apply</span> f arg1 args)))
  ([f arg1 arg2]
   (<span class="org-variable-name">fn</span> [&amp; args] (<span class="org-variable-name">apply</span> f arg1 arg2 args)))
  ([f arg1 arg2 arg3]
   (<span class="org-variable-name">fn</span> [&amp; args] (<span class="org-variable-name">apply</span> f arg1 arg2 arg3 args)))
  ([f arg1 arg2 arg3 &amp; more]
   (<span class="org-variable-name">fn</span> [&amp; args] (<span class="org-variable-name">apply</span> f arg1 arg2 arg3 (<span class="org-variable-name">concat</span> more args)))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline122" class="outline-5">
<h5 id="orgheadline122">Function Composition</h5>
<div class="outline-text-5" id="text-orgheadline122">
<p>
Define a function <code>two-fns</code> which takes two functions as arguments, <code>f</code> and <code>g</code>.
It returns <i>another function</i> which takes <i>one</i> argument, calls <code>g</code> on it, then calls <code>f</code> on the result, and returns that.
</p>

<p>
That is, your function returns the <i>composition</i> of <code>f</code> and <code>g</code>.
</p>
</div>

<div id="outline-container-orgheadline123" class="outline-6">
<h6 id="orgheadline123">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline123">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">two-fns</span> [f g]
  (<span class="org-variable-name">fn</span> [x] (f (g x))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline124" class="outline-6">
<h6 id="orgheadline124">Notes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline124">
<p>
In Clojure, the <code>comp</code> (for "composition") function is a more general version of this.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">comp</span>
  <span class="org-doc">"Takes a set of functions and returns a fn that is the composition</span>
<span class="org-doc">  of those fns.  The returned fn takes a variable number of args,</span>
<span class="org-doc">  applies the rightmost of fns to the args, the next</span>
<span class="org-doc">  fn (right-to-left) to the result, etc."</span>
  ([] identity)
  ([f] f)
  ([f g] 
     (<span class="org-variable-name">fn</span> 
       ([] (f (g)))
       ([x] (f (g x)))
       ([x y] (f (g x y)))
       ([x y z] (f (g x y z)))
       ([x y z &amp; args] (f (<span class="org-variable-name">apply</span> g x y z args)))))
  ([f g h] 
     (<span class="org-variable-name">fn</span> 
       ([] (f (g (h))))
       ([x] (f (g (h x))))
       ([x y] (f (g (h x y))))
       ([x y z] (f (g (h x y z))))
       ([x y z &amp; args] (f (g (<span class="org-variable-name">apply</span> h x y z args))))))
  ([f1 f2 f3 &amp; fs]
    (<span class="org-builtin">let</span> [fs (<span class="org-variable-name">reverse</span> (<span class="org-variable-name">list*</span> f1 f2 f3 fs))]
      (<span class="org-variable-name">fn</span> [&amp; args]
        (<span class="org-builtin">loop</span> [ret (<span class="org-variable-name">apply</span> (<span class="org-variable-name">first</span> fs) args) fs (<span class="org-variable-name">next</span> fs)]
          (<span class="org-builtin">if</span> fs
            (<span class="org-builtin">recur</span> ((<span class="org-variable-name">first</span> fs) ret) (<span class="org-variable-name">next</span> fs))
            ret))))))
</pre>
</div>

<p>
Don't worry about understanding the implementation of <code>comp</code> just yet.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline125" class="outline-5">
<h5 id="orgheadline125">Let over Lambda</h5>
<div class="outline-text-5" id="text-orgheadline125">
<p>
Rewrite the following expression using <code>fn</code> instead of <code>let</code>.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">let</span> [x 5
      y 7]
  (<span class="org-variable-name">+</span> x y))
</pre>
</div>
</div>

<div id="outline-container-orgheadline126" class="outline-6">
<h6 id="orgheadline126">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline126">
<div class="org-src-container">

<pre class="src src-clojure">((<span class="org-variable-name">fn</span> [x y] (<span class="org-variable-name">+</span> x y)) 5 7)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline127" class="outline-6">
<h6 id="orgheadline127">Notes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline127">
<p>
The <code>let</code> special form is functionally equivalent to creating and invoking an anonymous function, but it is easier to read and more efficient.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline128" class="outline-5">
<h5 id="orgheadline128">Lots of Swinging to do</h5>
<div class="outline-text-5" id="text-orgheadline128">
<p>
Rewrite your solution to the "Getting into the Swing of things" exercise without using <code>let</code>.
</p>

<p>
Hint: use Clojure's <code>doto</code> macro.
</p>
</div>

<div id="outline-container-orgheadline129" class="outline-6">
<h6 id="orgheadline129">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline129">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">import</span> (javax.swing <span class="org-preprocessor">JLabel</span> <span class="org-preprocessor">JButton</span> <span class="org-preprocessor">JPanel</span> <span class="org-preprocessor">JFrame</span>))

(<span class="org-keyword">defn</span> <span class="org-function-name">sample-app</span> []
  (<span class="org-builtin">doto</span> (<span class="org-preprocessor">JFrame.</span> <span class="org-string">"Sample Application"</span>)
    (<span class="org-preprocessor">.setContentPane</span> (<span class="org-builtin">doto</span> (<span class="org-preprocessor">JPanel.</span>)
                       (<span class="org-preprocessor">.setOpaque</span> true)
                       (<span class="org-preprocessor">.add</span> (<span class="org-preprocessor">JLabel.</span> <span class="org-string">"Click the button!"</span>))
                       (<span class="org-preprocessor">.add</span> (<span class="org-preprocessor">JButton.</span> <span class="org-string">"Go"</span>))))
    (<span class="org-preprocessor">.setSize</span> 300 100)
    (<span class="org-preprocessor">.setVisible</span> true)))
</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline131" class="outline-3">
<h3 id="orgheadline131">Flow Control&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-orgheadline131">
</div>

<div id="outline-container-orgheadline144" class="outline-4">
<h4 id="orgheadline144">Introduction</h4>
<div class="outline-text-4" id="text-orgheadline144">
</div><div id="outline-container-orgheadline132" class="outline-5">
<h5 id="orgheadline132">Statements vs. Expressions in Java&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline132">
<ul class="org-ul">
<li>Expressions return values, statements do not</li>
</ul>

<div class="org-src-container">

<pre class="src src-java"><span class="org-comment-delimiter">// </span><span class="org-comment">"if" is a statement because it doesn't return a value:</span>
<span class="org-type">String</span> <span class="org-variable-name">s</span>;
<span class="org-keyword">if</span> (x &gt; 10) {
    s = <span class="org-string">"greater"</span>;
} <span class="org-keyword">else</span> {
    s = <span class="org-string">"greater or equal"</span>;
}
obj.someMethod(s);

<span class="org-comment-delimiter">// </span><span class="org-comment">Ternary operator is an expression; it returns a value:</span>
obj.someMethod(x &gt; 10 ? <span class="org-string">"greater"</span> : <span class="org-string">"greater or equal"</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline133" class="outline-5">
<h5 id="orgheadline133">Expressions in Clojure&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline133">
<ul class="org-ul">
<li>Everything in Clojure is an expression
<ul class="org-ul">
<li>Always returns a value</li>
<li>A block of multiple expressions returns the last value
<ul class="org-ul">
<li>E.g., <code>let</code>, <code>do</code>, <code>fn</code></li>
</ul></li>
<li>Expressions exclusively for side-effects return <code>nil</code></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline134" class="outline-5">
<h5 id="orgheadline134">Flow Control Expressions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline134">
<ul class="org-ul">
<li>Flow control operators are expressions too</li>
<li>Composable, can use them anywhere
<ul class="org-ul">
<li>Less duplicate code</li>
<li>Fewer intermediate variables</li>
</ul></li>
<li>Extensible, via macros
<ul class="org-ul">
<li>E.g., <code>when-let</code></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline135" class="outline-5">
<h5 id="orgheadline135"><code>if</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline135">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">even?</span> 2)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; true</span>

(<span class="org-builtin">if</span> (<span class="org-variable-name">even?</span> 2) <span class="org-string">"even"</span> <span class="org-string">"odd"</span>)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "even"</span>

(<span class="org-variable-name">str</span> <span class="org-string">"2 is "</span> (<span class="org-builtin">if</span> (<span class="org-variable-name">even?</span> 2) <span class="org-string">"even"</span> <span class="org-string">"odd"</span>))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "2 is even"</span>

<span class="org-comment-delimiter">; </span><span class="org-comment">else-expression is optional</span>
(<span class="org-builtin">if</span> (<span class="org-variable-name">true?</span> false) <span class="org-string">"impossible!"</span>)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; nil</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline136" class="outline-5">
<h5 id="orgheadline136">Truthiness&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline136">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">if</span> true <span class="org-constant">:truthy</span> <span class="org-constant">:falsey</span>)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; :truthy</span>
(<span class="org-builtin">if</span> (<span class="org-preprocessor">Object.</span>) <span class="org-constant">:truthy</span> <span class="org-constant">:falsey</span>) <span class="org-comment">; objects are true</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; :truthy</span>
(<span class="org-builtin">if</span> [] <span class="org-constant">:truthy</span> <span class="org-constant">:falsey</span>) <span class="org-comment">; empty collections are true</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; :truthy</span>
(<span class="org-builtin">if</span> 0 <span class="org-constant">:truthy</span> <span class="org-constant">:falsey</span>) <span class="org-comment">; zero is true</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; :truthy</span>

(<span class="org-builtin">if</span> false <span class="org-constant">:truthy</span> <span class="org-constant">:falsey</span>)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; :falsey</span>
(<span class="org-builtin">if</span> nil <span class="org-constant">:truthy</span> <span class="org-constant">:falsey</span>) <span class="org-comment">; nil is false</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; :falsey</span>
(<span class="org-builtin">if</span> (<span class="org-variable-name">seq</span> []) <span class="org-constant">:truthy</span> <span class="org-constant">:falsey</span>) <span class="org-comment">; seq on empty coll is nil</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; :falsey</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline137" class="outline-5">
<h5 id="orgheadline137"><code>if</code> and <code>do</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline137">
<ul class="org-ul">
<li>Multiple expressions per branch</li>
<li>Last value in branch returned</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">if</span> (<span class="org-variable-name">even?</span> 5)
  (<span class="org-builtin">do</span> (<span class="org-variable-name">println</span> <span class="org-string">"even"</span>)
      true)
  (<span class="org-builtin">do</span> (<span class="org-variable-name">println</span> <span class="org-string">"odd"</span>)
      false))
<span class="org-comment-delimiter">;; </span><span class="org-comment">odd         ; printed</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; false     ; return value</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline138" class="outline-5">
<h5 id="orgheadline138"><code>when</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline138">
<ul class="org-ul">
<li>If condition is true, execute body</li>
<li>Otherwise, return <code>nil</code></li>
<li>Shortcut for <code>(if test (do body))</code> with no "else"</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">when</span> condition
  ... body of expressions ...)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline139" class="outline-5">
<h5 id="orgheadline139"><code>cond</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline139">
<ul class="org-ul">
<li>Series of tests and expressions</li>
<li><code>:else</code> expression is optional
<ul class="org-ul">
<li>Could be any truthy value, <code>:else</code> is standard</li>
</ul></li>
<li>Returns <code>nil</code> if no match and no <code>:else</code></li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">cond</span>
 test1 expression1
 test2 expression2
 ...
 <span class="org-constant">:else</span> else-expression)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline140" class="outline-5">
<h5 id="orgheadline140"><code>cond</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline140">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">let</span> [x 5]
  (<span class="org-builtin">cond</span>
   (<span class="org-variable-name">&lt;</span> x 2) <span class="org-string">"x is less than 2"</span>
   (<span class="org-variable-name">&lt;</span> x 10) <span class="org-string">"x is less than 10"</span>))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "x is less than 10"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline141" class="outline-5">
<h5 id="orgheadline141"><code>cond</code> and <code>:else</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline141">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">let</span> [x 11]
  (<span class="org-builtin">cond</span>
   (<span class="org-variable-name">&lt;</span> x 2)  <span class="org-string">"x is less than 2"</span>
   (<span class="org-variable-name">&lt;</span> x 10) <span class="org-string">"x is less than 10"</span>
   <span class="org-constant">:else</span>    <span class="org-string">"x is greater than or equal to 10"</span>))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "x is greater than or equal to 10"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline142" class="outline-5">
<h5 id="orgheadline142"><code>case</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline142">
<ul class="org-ul">
<li>Compare argument to test values in O(1) time</li>
<li>Test values must be compile-time literals
(e.g. numbers, strings, keywords)</li>
<li>Error if no match</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">foo</span> [x]
  (<span class="org-builtin">case</span> x
    5  <span class="org-string">"x is 5"</span>
    10 <span class="org-string">"x is 10"</span>))

(foo 10)  <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "x is 10"</span>

(foo 11)  <span class="org-comment-delimiter">;; </span><span class="org-comment">ERROR</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline143" class="outline-5">
<h5 id="orgheadline143"><code>case</code> with else-expression&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline143">
<ul class="org-ul">
<li>With an odd number of expressions&#x2026;</li>
<li>The last expression is the "else"</li>
<li>Prevents error on no match</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">foo</span> [x]
  (<span class="org-builtin">case</span> x
    5  <span class="org-string">"x is 5"</span>
    10 <span class="org-string">"x is 10"</span>
    <span class="org-string">"x isn't 5 or 10"</span>))

(foo 5)  <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "x is 5"</span>

(foo 11) <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "x isn't 5 or 10"</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline148" class="outline-4">
<h4 id="orgheadline148">Iteration for Side Effects&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline148">
</div><div id="outline-container-orgheadline145" class="outline-5">
<h5 id="orgheadline145"><code>dotimes</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline145">
<ul class="org-ul">
<li>Evaluate expression n times</li>
<li>Returns <code>nil</code></li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">dotimes</span> [i 3]
  (<span class="org-variable-name">println</span> i))
<span class="org-comment-delimiter">;; </span><span class="org-comment">0</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">1</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">2</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; nil</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline146" class="outline-5">
<h5 id="orgheadline146"><code>doseq</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline146">
<ul class="org-ul">
<li>Iterates over a sequence
<ul class="org-ul">
<li>Similar to Java's for-each loop</li>
</ul></li>
<li>If a lazy sequence, <code>doseq</code> forces evaluation</li>
<li>Returns <code>nil</code></li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">doseq</span> [n (<span class="org-variable-name">range</span> 3)]
  (<span class="org-variable-name">println</span> n))
<span class="org-comment-delimiter">;; </span><span class="org-comment">0</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">1</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">2</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; nil</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline147" class="outline-5">
<h5 id="orgheadline147"><code>doseq</code> with multiple bindings&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline147">
<ul class="org-ul">
<li>Similar to nested foreach loops</li>
<li>Processes all permutations of sequence content</li>
<li>Returns <code>nil</code></li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">doseq</span> [letter [<span class="org-constant">:a</span> <span class="org-constant">:b</span>]
        number (<span class="org-variable-name">range</span> 3)]  <span class="org-comment">; list of 0,1,2</span>
  (<span class="org-variable-name">pr</span> [letter number]))
<span class="org-comment-delimiter">;; </span><span class="org-comment">[:a 0][:a 1][:a 2][:b 0][:b 1][:b 2]=&gt; nil</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline149" class="outline-4">
<h4 id="orgheadline149">Clojure's <code>for</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline149">
<ul class="org-ul">
<li>List comprehension, NOT a for-loop</li>
<li>Generator function for sequence permutation</li>
<li>Bindings behave like <code>doseq</code></li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">for</span> [letter [<span class="org-constant">:a</span> <span class="org-constant">:b</span>]
      number (<span class="org-variable-name">range</span> 3)]  <span class="org-comment">; list of 0,1,2</span>
  [letter number])
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; ([:a 0] [:a 1] [:a 2] [:b 0] [:b 1] [:b 2])</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline154" class="outline-4">
<h4 id="orgheadline154">Recursion&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline154">
</div><div id="outline-container-orgheadline150" class="outline-5">
<h5 id="orgheadline150">Recursion and Iteration&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline150">
<ul class="org-ul">
<li>Clojure provides <code>recur</code> and the sequence abstraction</li>
<li><code>recur</code> is "classic" recursion
<ul class="org-ul">
<li>Closed to consumers, lower-level</li>
</ul></li>
<li>Sequences represent iteration as values
<ul class="org-ul">
<li>Consumers can partially iterate</li>
</ul></li>
<li>Reducers and Transducers represent iteration as function composition
<ul class="org-ul">
<li>More on Reducers (not covered here): <a href="https://clojure.org/reference/reducers">https://clojure.org/reference/reducers</a></li>
<li>More on Transducers later</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline151" class="outline-5">
<h5 id="orgheadline151"><code>loop</code> and <code>recur</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline151">
<ul class="org-ul">
<li>Functional looping construct
<ul class="org-ul">
<li><code>loop</code> defines bindings</li>
<li><code>recur</code> re-executes <code>loop</code> with new bindings</li>
</ul></li>
<li>Prefer higher-order library fns</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">loop</span> [i 0]
  (<span class="org-builtin">if</span> (<span class="org-variable-name">&lt;</span> i 10)
    (<span class="org-builtin">recur</span> (<span class="org-variable-name">inc</span> i))
    i)) <span class="org-comment">;=&gt; 10</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline152" class="outline-5">
<h5 id="orgheadline152"><code>defn</code> and <code>recur</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline152">
<ul class="org-ul">
<li>fn arguments are implicit <code>loop</code> bindings</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">increase</span> [i]
  (<span class="org-builtin">if</span> (<span class="org-variable-name">&lt;</span> i 10)
    (<span class="org-builtin">recur</span> (<span class="org-variable-name">inc</span> i))
    i))

(increase 1) <span class="org-comment">;=&gt; 10</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline153" class="outline-5">
<h5 id="orgheadline153"><code>recur</code> for recursion&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline153">
<ul class="org-ul">
<li><code>recur</code> must be in "tail position"
<ul class="org-ul">
<li>The last expression in a branch</li>
</ul></li>
<li><code>recur</code> must provide values for all bound symbols by position
<ul class="org-ul">
<li>Loop bindings</li>
<li>defn/fn args</li>
</ul></li>
<li>Recursion via <code>recur</code> does not consume stack</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline159" class="outline-4">
<h4 id="orgheadline159">Exceptions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline159">
</div><div id="outline-container-orgheadline155" class="outline-5">
<h5 id="orgheadline155">Exception handling&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline155">
<ul class="org-ul">
<li>try/catch/finally as in Java</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">try</span>
  (<span class="org-variable-name">/</span> 2 1)
  (<span class="org-builtin">catch</span> <span class="org-preprocessor">ArithmeticException</span> e
    <span class="org-string">"divide by zero"</span>)
  (<span class="org-builtin">finally</span>
   (<span class="org-variable-name">println</span> <span class="org-string">"cleanup"</span>)))
<span class="org-comment-delimiter">;; </span><span class="org-comment">cleanup</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 2</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline156" class="outline-5">
<h5 id="orgheadline156">Throwing exceptions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline156">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">try</span>
  (<span class="org-builtin">throw</span> (<span class="org-preprocessor">Exception.</span> <span class="org-string">"something went wrong"</span>))
  (<span class="org-builtin">catch</span> <span class="org-preprocessor">Exception</span> e (<span class="org-preprocessor">.getMessage</span> e)))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "something went wrong"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline157" class="outline-5">
<h5 id="orgheadline157">Exceptions with Clojure data&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline157">
<ul class="org-ul">
<li><code>ex-info</code> takes a message and a map</li>
<li><code>ex-data</code> gets the map back out
<ul class="org-ul">
<li>Or <code>nil</code> if not created with <code>ex-info</code></li>
</ul></li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">try</span>
  (<span class="org-builtin">throw</span> (ex-info <span class="org-string">"There was a problem"</span> {<span class="org-constant">:detail</span> 42}))
  (<span class="org-builtin">catch</span> <span class="org-preprocessor">Exception</span> e
    (<span class="org-variable-name">prn</span> (<span class="org-constant">:detail</span> (ex-data e)))))
<span class="org-comment-delimiter">;; </span><span class="org-comment">42</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; nil</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline158" class="outline-5">
<h5 id="orgheadline158"><code>with-open</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline158">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">let</span> [f (clojure.java.io/writer <span class="org-string">"/tmp/new"</span>)]
  (<span class="org-builtin">try</span>
    (<span class="org-preprocessor">.write</span> f <span class="org-string">"some text"</span>)
    (<span class="org-builtin">finally</span>
      (<span class="org-preprocessor">.close</span> f))))

<span class="org-comment-delimiter">;; </span><span class="org-comment">Can be written:</span>
(<span class="org-builtin">with-open</span> [f (clojure.java.io/writer <span class="org-string">"/tmp/new"</span>)]
  (<span class="org-preprocessor">.write</span> f <span class="org-string">"some text"</span>))
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline160" class="outline-3">
<h3 id="orgheadline160">LAB: Flow Control&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-orgheadline160">
</div>

<div id="outline-container-orgheadline161" class="outline-4">
<h4 id="orgheadline161">I am thinking of a number</h4>
<div class="outline-text-4" id="text-orgheadline161">
<p>
Let's play a number-guessing game. Define a function <code>check-guess</code> that takes two arguments:
</p>

<ul class="org-ul">
<li><code>secret</code>, the number the player is trying to guess</li>
<li><code>guess</code>, the player's most recent guess</li>
</ul>

<p>
The function should <b>return</b> a string:
</p>

<ul class="org-ul">
<li>"You win!" if the numbers are equal</li>
<li>"Too low" if the guess is less than the secret</li>
<li>"Too high" if the guess is greater than the secret</li>
</ul>

<p>
Use only <code>if</code>, not <code>cond</code>.
</p>
</div>

<div id="outline-container-orgheadline162" class="outline-5">
<h5 id="orgheadline162">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline162">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">check-guess</span> [secret guess]
  (<span class="org-builtin">if</span> (<span class="org-variable-name">=</span> guess secret)
    <span class="org-string">"You win!"</span>
    (<span class="org-builtin">if</span> (<span class="org-variable-name">&lt;</span> guess secret)
      <span class="org-string">"Too low"</span>
      <span class="org-string">"Too high"</span>)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline163" class="outline-4">
<h4 id="orgheadline163">I am thinking of another number</h4>
<div class="outline-text-4" id="text-orgheadline163">
<p>
Repeat the previous exercise using <code>cond</code> instead of <code>if</code>.
</p>
</div>

<div id="outline-container-orgheadline164" class="outline-5">
<h5 id="orgheadline164">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline164">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">check-guess</span> [secret guess]
  (<span class="org-builtin">cond</span> (<span class="org-variable-name">=</span> guess secret)
          <span class="org-string">"You win!"</span>
        (<span class="org-variable-name">&lt;</span> guess secret)
          <span class="org-string">"Too low"</span>
        <span class="org-constant">:else</span>
          <span class="org-string">"Too high"</span>))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline165" class="outline-4">
<h4 id="orgheadline165">Triplicate redux</h4>
<div class="outline-text-4" id="text-orgheadline165">
<p>
Define a function <code>triplicate</code> that takes a single argument, a function <code>f</code>, and calls that function three times. Use <code>dotimes</code>.
</p>

<p>
Test it with an anonymous function that prints <code>:hi</code>.
</p>
</div>

<div id="outline-container-orgheadline166" class="outline-5">
<h5 id="orgheadline166">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline166">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">triplicate</span> [f]
  (<span class="org-builtin">dotimes</span> [i 3]
    (f)))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-clojure">(triplicate #(<span class="org-variable-name">prn</span> <span class="org-constant">:hi</span>))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline167" class="outline-4">
<h4 id="orgheadline167">Printing Numbers</h4>
<div class="outline-text-4" id="text-orgheadline167">
<p>
Define a function <code>numbers</code> that takes a single argument <code>n</code> and prints all the numbers from <b>zero</b> to <b>n-1</b> (inclusive), one per line.
</p>
</div>

<div id="outline-container-orgheadline168" class="outline-5">
<h5 id="orgheadline168">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline168">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">numbers</span> [n]
  (<span class="org-builtin">dotimes</span> [i n]
    (<span class="org-variable-name">println</span> i)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline169" class="outline-4">
<h4 id="orgheadline169">Counting Numbers</h4>
<div class="outline-text-4" id="text-orgheadline169">
<p>
Define a function <code>counting</code> that takes a single argument <code>n</code> and prints all the numbers from <b>one</b> to <code>n</code> (inclusive), one per line.
</p>

<p>
Hint: Use <code>doseq</code> and <code>range</code>.
</p>
</div>

<div id="outline-container-orgheadline170" class="outline-5">
<h5 id="orgheadline170">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline170">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">counting</span> [n]
  (<span class="org-builtin">doseq</span> [i (<span class="org-variable-name">range</span> 1 (<span class="org-variable-name">inc</span> n))]
    (<span class="org-variable-name">println</span> i)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline171" class="outline-4">
<h4 id="orgheadline171">Garage band</h4>
<div class="outline-text-4" id="text-orgheadline171">
<p>
Let's start a band! Define a function <code>print-bands</code> that takes three arguments:
</p>

<ul class="org-ul">
<li><code>guitars</code>, a vector of guitarists' names</li>
<li><code>basses</code>, a vector of bass players' names</li>
<li><code>drums</code>, a vector of drummers' names</li>
</ul>

<p>
The function should print all the possible 3-piece combinations you can make with those players, like this:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(print-bands [<span class="org-string">"Gary"</span> <span class="org-string">"Gus"</span>]
             [<span class="org-string">"Bill"</span> <span class="org-string">"Bob"</span> <span class="org-string">"Buster"</span>]
             [<span class="org-string">"Darrell"</span>])
<span class="org-comment-delimiter">;; </span><span class="org-comment">Gary Bill Darrell</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Gary Bob Darrell</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Gary Buster Darrell</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Gus Bill Darrell</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Gus Bob Darrell</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Gus Buster Darrell</span>
</pre>
</div>
</div>

<div id="outline-container-orgheadline172" class="outline-5">
<h5 id="orgheadline172">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline172">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">print-bands</span> [guitars basses drums]
  (<span class="org-builtin">doseq</span> [g guitars
          b basses
          d drums]
    (<span class="org-variable-name">println</span> g b d)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline173" class="outline-4">
<h4 id="orgheadline173">Return of the garage band</h4>
<div class="outline-text-4" id="text-orgheadline173">
<p>
Define a function <code>all-bands</code> that takes the same arguments as <code>print-bands</code>, but instead of printing all the combinations it <b>returns</b> them in a sequence. Each item in the sequence should be a vector like <code>[guitarist bass drummer]</code>.
</p>

<p>
Hint: use <code>for</code>
</p>
</div>

<div id="outline-container-orgheadline174" class="outline-5">
<h5 id="orgheadline174">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline174">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">all-bands</span> [guitars basses drums]
  (<span class="org-builtin">for</span> [g guitars
        b basses
        d drums]
    [g b d]))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline175" class="outline-4">
<h4 id="orgheadline175">Fizzbuzz</h4>
<div class="outline-text-4" id="text-orgheadline175">
<p>
It's everybody's favorite programming problem!  Define a function <code>fizzbuzz</code> that prints the numbers from 1 to 100 (inclusive), subject to the following rules:
</p>

<ul class="org-ul">
<li>If the number is a multiple of three, print "Fizz".</li>
<li>If the number is a multiple of five, print "Buzz".</li>
<li>If the number is a multiple of <b>both</b> three and five print "FizzBuzz".</li>
<li>If the number is <b>not</b> a multiple of three or five, print the number.</li>
</ul>

<p>
Hint: the <code>rem</code> function (short for "remainder") computes the remainder of dividing two numbers, like Java's <code>%</code> operator. Clojure also has a <code>zero?</code> function to test if a number is equal to zero.
</p>
</div>

<div id="outline-container-orgheadline176" class="outline-5">
<h5 id="orgheadline176">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline176">
<p>
There are infinitely many solutions to this problem. Here is the most straightforward. Remember that conditional expressions such as <code>cond</code> return a value. 
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">fizzbuzz</span> []
  (<span class="org-builtin">doseq</span> [i (<span class="org-variable-name">range</span> 1 101)]
    (<span class="org-variable-name">println</span> (<span class="org-builtin">cond</span> (<span class="org-builtin">and</span> (zero? (<span class="org-variable-name">rem</span> i 3))
                        (zero? (<span class="org-variable-name">rem</span> i 5)))
                     <span class="org-string">"FizzBuzz"</span>
                   (zero? (<span class="org-variable-name">rem</span> i 3))
                     <span class="org-string">"Fizz"</span>
                   (zero? (<span class="org-variable-name">rem</span> i 5))
                     <span class="org-string">"Buzz"</span>
                   <span class="org-constant">:else</span> i))))
</pre>
</div>

<p>
If you want to avoid repeating the <code>rem</code> operation, here's one way to do it:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">fizzbuzz</span> []
  (<span class="org-builtin">doseq</span> [i (<span class="org-variable-name">range</span> 1 101)]
    (<span class="org-builtin">let</span> [fizz (<span class="org-builtin">if</span> (zero? (<span class="org-variable-name">rem</span> i 3)) <span class="org-string">"Fizz"</span>)
          buzz (<span class="org-builtin">if</span> (zero? (<span class="org-variable-name">rem</span> i 5)) <span class="org-string">"Buzz"</span>)
          number (<span class="org-builtin">if</span> (<span class="org-variable-name">not</span> (<span class="org-builtin">or</span> fizz buzz)) i)]
      (<span class="org-variable-name">println</span> (<span class="org-variable-name">str</span> fizz buzz number)))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline177" class="outline-4">
<h4 id="orgheadline177">Euclid's Algorithm</h4>
<div class="outline-text-4" id="text-orgheadline177">
<p>
<a href="http://en.wikipedia.org/wiki/Euclidean_algorithm">Euclid's Algorithm</a> finds the greatest common divisor of two integers using only subtraction. In imperative pseudo-code, it looks like this:
</p>

<pre class="example">
function gcd(A, B):
    do loop:
        if A == 0
            return B

        if B == 0
            return A

        if A &gt; B
            A := A - B
        else
            B := B - A
</pre>

<p>
Define a function <code>gcd</code> that implements Euclid's algorithm. Use <code>recur</code>.
</p>
</div>

<div id="outline-container-orgheadline178" class="outline-5">
<h5 id="orgheadline178">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline178">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">gcd</span> [a b]
  (<span class="org-builtin">cond</span> (zero? a) b
        (zero? b) a
        (<span class="org-variable-name">&gt;</span> a b)   (<span class="org-builtin">recur</span> (<span class="org-variable-name">-</span> a b) b)
        <span class="org-constant">:else</span>     (<span class="org-builtin">recur</span> a (<span class="org-variable-name">-</span> b a))))
</pre>
</div>

<p>
Some tests:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">assert</span> (<span class="org-variable-name">=</span> 1 (gcd 3 4)))
(<span class="org-variable-name">assert</span> (<span class="org-variable-name">=</span> 3 (gcd 3 6)))
(<span class="org-variable-name">assert</span> (<span class="org-variable-name">=</span> 3 (gcd 6 3)))
(<span class="org-variable-name">assert</span> (<span class="org-variable-name">=</span> 25 (gcd 100 25)))
(<span class="org-variable-name">assert</span> (<span class="org-variable-name">=</span> 4 (gcd 100 8)))
(<span class="org-variable-name">assert</span> (<span class="org-variable-name">=</span> 8 (gcd 16 24)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline179" class="outline-4">
<h4 id="orgheadline179">Bonus: I am thinking of a number</h4>
<div class="outline-text-4" id="text-orgheadline179">
<p>
Define a function which <b>returns</b> another function to play the number-guessing game.
</p>

<p>
That is, define a function <code>guessing-game</code> that picks a random number and <b>returns</b> a function which takes a <b>single</b> argument, the player's guess. The returned function should return the same strings as in the first exercise.
</p>

<p>
Hint: Clojure's <code>rand-int</code> function returns a random integer.
</p>
</div>

<div id="outline-container-orgheadline180" class="outline-5">
<h5 id="orgheadline180">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline180">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">guessing-game</span> []
  (<span class="org-builtin">let</span> [secret (<span class="org-variable-name">rand-int</span> 100)]
    (<span class="org-variable-name">fn</span> [guess]
      (<span class="org-builtin">cond</span> (<span class="org-variable-name">=</span> guess secret)
              <span class="org-string">"You win!"</span>
            (<span class="org-variable-name">&lt;</span> guess secret)
              <span class="org-string">"Too low"</span>
            <span class="org-constant">:else</span>
              <span class="org-string">"Too high"</span>))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline181" class="outline-4">
<h4 id="orgheadline181">Bonus: Binary search</h4>
<div class="outline-text-4" id="text-orgheadline181">
<p>
Use <code>loop</code> and <code>recur</code> to implement a binary search. Define a function <code>binary-search</code> that takes two arguments:
</p>

<ul class="org-ul">
<li><code>n</code>, a number</li>
<li><code>nums</code>, a sorted vector of numbers</li>
</ul>

<p>
The function should return <code>true</code> if <code>nums</code> contains <code>n</code> and <code>false</code> if it does not.
</p>
</div>

<div id="outline-container-orgheadline182" class="outline-5">
<h5 id="orgheadline182">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline182">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">binary-search</span> [n nums]
  (<span class="org-builtin">loop</span> [start 0
         end (<span class="org-variable-name">count</span> nums)]
    (<span class="org-builtin">if</span> (<span class="org-variable-name">=</span> start end)
      false
      (<span class="org-builtin">let</span> [index (<span class="org-variable-name">+</span> start (<span class="org-variable-name">int</span> (<span class="org-variable-name">/</span> (<span class="org-variable-name">-</span> end start) 2)))
            x (<span class="org-variable-name">nth</span> nums index)]
        (<span class="org-builtin">cond</span> (<span class="org-variable-name">=</span> n x) true
              (<span class="org-variable-name">&lt;</span> n x) (<span class="org-builtin">recur</span> start index)
              <span class="org-constant">:else</span>   (<span class="org-builtin">recur</span> (<span class="org-variable-name">inc</span> index) end))))))
</pre>
</div>

<p>
And some tests:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">assert</span> (<span class="org-variable-name">false?</span> (binary-search 4 [1 3 5 7 9])))
(<span class="org-variable-name">assert</span> (<span class="org-variable-name">false?</span> (binary-search 11 [1 3 5 7 9])))
(<span class="org-variable-name">assert</span> (<span class="org-variable-name">true?</span> (binary-search 7 [1 3 5 7 9])))
(<span class="org-variable-name">assert</span> (<span class="org-variable-name">true?</span> (binary-search 1 [1 3 5 7 9])))
(<span class="org-variable-name">assert</span> (<span class="org-variable-name">true?</span> (binary-search 9 [1 3 5 7 9])))

(<span class="org-variable-name">assert</span> (<span class="org-variable-name">true?</span> (binary-search 54 (<span class="org-variable-name">range</span> 0 100 2))))
(<span class="org-variable-name">assert</span> (<span class="org-variable-name">true?</span> (binary-search 98 (<span class="org-variable-name">range</span> 0 100 2))))
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline183" class="outline-3">
<h3 id="orgheadline183">Collections as Containers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-orgheadline183">
</div>

<div id="outline-container-orgheadline184" class="outline-5">
<h5 id="orgheadline184">Immutability&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline184">
<ul class="org-ul">
<li>Cannot "overwrite" or "update in-place"</li>
<li>Never changes unexpectedly</li>
<li>Simple values (numbers, strings) are immutable</li>
<li>In Clojure, <i>compound</i> values are immutable too</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline185" class="outline-5">
<h5 id="orgheadline185">Data Structures&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline185">
<div class="org-src-container">

<pre class="src src-clojure">#{42 <span class="org-string">"Bob"</span> 98.6 <span class="org-constant">:foo</span>}    <span class="org-comment">; Set</span>
[<span class="org-constant">:alpha</span> <span class="org-string">"beta"</span> 3.14]     <span class="org-comment">; Vector</span>
(1 2 3 4)                <span class="org-comment">; List</span>
{<span class="org-constant">:pi</span> 3.14159, <span class="org-string">"pie"</span> 3}   <span class="org-comment">; Map</span>
</pre>
</div>

<p>
"It is better to have 100 functions operate on one data structure than
to have 10 functions operate on 10 data structures." -Alan Perlis
</p>

<p>
<a href="http://clojure.org/cheatsheet">http://clojure.org/cheatsheet</a>
</p>
</div>
</div>

<div id="outline-container-orgheadline186" class="outline-5">
<h5 id="orgheadline186">Collection Use Cases&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline186">
<ul class="org-ul">
<li>Unordered containers: sets</li>
<li>Ordered containers: vectors, lists</li>
<li>Indexed data: maps, vectors</li>
<li>Structured data: maps, records</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline187" class="outline-4">
<h4 id="orgheadline187">Collections as Containers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline187">
<ul class="org-ul">
<li>You need to collect many elements</li>
<li>Usually all the same "type"</li>
<li>Choose collection type by the operations it supports efficiently
<ul class="org-ul">
<li>Set</li>
<li>Vector</li>
<li>List</li>
</ul></li>
</ul>
</div>

<div id="outline-container-orgheadline188" class="outline-5">
<h5 id="orgheadline188">Common Functions for Collections&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline188">
<div class="org-src-container">

<pre class="src src-clojure">count     - size of collection
conj      - <span class="org-string">"conjoin"</span> (add) a new value
into      - pour one collection into another

<span class="org-comment-delimiter">;; </span><span class="org-comment">Only for vectors and lists:</span>
peek      - retrieve the value at the insertion point
pop       - remove the value at the insertion point

<span class="org-comment-delimiter">;; </span><span class="org-comment">Only for sets:</span>
disj      - <span class="org-string">"disjoin"</span> (<span class="org-variable-name">remove</span>) a value
contains? - does this collection contain this key? 
clojure.set/union        - set union
clojure.set/intersection - set intersection
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline189" class="outline-5">
<h5 id="orgheadline189">Set&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline189">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">players</span> #{<span class="org-string">"Alice"</span> <span class="org-string">"Bob"</span> <span class="org-string">"Kelly"</span>})
</pre>
</div>

<ul class="org-ul">
<li>No order (but sorted sets are available)</li>
<li>No duplicates</li>
</ul>
</div>

<div id="outline-container-orgheadline190" class="outline-6">
<h6 id="orgheadline190">Uses for a Set&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline190">
<ul class="org-ul">
<li>You just need a collection of stuff</li>
<li>You don't care about order</li>
<li>You need to efficiently check if something is in the collection</li>
<li>You need to efficiently add or remove any item</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline191" class="outline-6">
<h6 id="orgheadline191">Add to a Set&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline191">
<div class="org-src-container">

<pre class="src src-clojure">players
</pre>
</div>

<pre class="example">
;;=&gt; #{"Alice" "Bob" "Kelly"}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">conj</span> players <span class="org-string">"Una"</span>)
</pre>
</div>

<pre class="example">
;;=&gt; #{"Alice" "Una" "Bob" "Kelly"}
</pre>

<p>
Note original remains unchanged:
</p>

<div class="org-src-container">

<pre class="src src-clojure">players
</pre>
</div>

<pre class="example">
;;=&gt; #{"Alice" "Bob" "Kelly"}
</pre>
</div>
</div>

<div id="outline-container-orgheadline192" class="outline-6">
<h6 id="orgheadline192">Add Multiple Things to a Set&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline192">
<div class="org-src-container">

<pre class="src src-clojure">players
</pre>
</div>

<pre class="example">
;;=&gt; #{"Alice" "Bob" "Kelly"}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">conj</span> players <span class="org-string">"Sal"</span> <span class="org-string">"Evan"</span> <span class="org-string">"Bob"</span>)
</pre>
</div>

<pre class="example">
;;=&gt; #{"Alice" "Bob" "Evan" "Sal" "Kelly"}
</pre>

<p>
Note: "Bob" was already in the set, so no effect.
</p>
</div>
</div>

<div id="outline-container-orgheadline193" class="outline-6">
<h6 id="orgheadline193">Remove from a Set&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline193">
<div class="org-src-container">

<pre class="src src-clojure">players
</pre>
</div>

<pre class="example">
;;=&gt; #{"Alice" "Bob" "Kelly"}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">disj</span> players <span class="org-string">"Bob"</span> <span class="org-string">"Sal"</span>)
</pre>
</div>

<pre class="example">
;;=&gt; #{"Alice" "Kelly"}
</pre>

<p>
Note: "Sal" wasn't in the set, so no effect.
</p>
</div>
</div>

<div id="outline-container-orgheadline194" class="outline-6">
<h6 id="orgheadline194">Find if Set Contains Item&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline194">
<div class="org-src-container">

<pre class="src src-clojure">players
</pre>
</div>

<pre class="example">
;;=&gt; #{"Alice" "Bob" "Kelly"}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">contains?</span> players <span class="org-string">"Kelly"</span>)
</pre>
</div>

<pre class="example">
;;=&gt; true
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">contains?</span> players <span class="org-string">"Samwise"</span>)
</pre>
</div>

<pre class="example">
;;=&gt; false
</pre>

<p>
Note: <code>contains?</code> doesn't work on vectors or lists.
</p>
</div>
</div>

<div id="outline-container-orgheadline195" class="outline-6">
<h6 id="orgheadline195">Sets are Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline195">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">s</span> #{3 7 9})

<span class="org-comment-delimiter">;; </span><span class="org-comment">Returns the element if it's in the set:</span>
(s 7)   <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 7</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">Returns nil otherwise:</span>
(s 20)  <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; nil</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline196" class="outline-5">
<h5 id="orgheadline196">Sorted Sets&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline196">
<ul class="org-ul">
<li>Preserves "natural" sort order of items</li>
<li>Uses Clojure's <code>compare</code></li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">conj</span> (<span class="org-variable-name">sorted-set</span>) <span class="org-string">"Bravo"</span> <span class="org-string">"Charlie"</span> <span class="org-string">"Sigma"</span> <span class="org-string">"Alpha"</span>)
</pre>
</div>

<pre class="example">
;;=&gt; #{"Alpha" "Bravo" "Charlie" "Sigma"}
</pre>
</div>

<div id="outline-container-orgheadline197" class="outline-6">
<h6 id="orgheadline197">Sorted Set with Comparator&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline197">
<p>
Provide your own <code>compare</code> function.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">doc</span> compare)
</pre>
</div>

<pre class="example">
;; -------------------------
;; clojure.core/compare
;; ([x y])
;;   Comparator. Returns a negative number, zero, or a positive number
;;   when x is logically 'less than', 'equal to', or 'greater than'
;;   y. Same as Java x.compareTo(y) except it also works for nil, and
;;   compares numbers and collections in a type-independent manner. x
;;   must implement Comparable
;;=&gt; nil
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">conj</span> (<span class="org-variable-name">sorted-set-by</span> (<span class="org-variable-name">fn</span> [x y] (<span class="org-variable-name">-</span> (<span class="org-variable-name">compare</span> x y))))
      <span class="org-string">"Bravo"</span> <span class="org-string">"Charlie"</span> <span class="org-string">"Sigma"</span> <span class="org-string">"Alpha"</span>)
</pre>
</div>

<pre class="example">
;;=&gt; #{"Sigma" "Charlie" "Bravo" "Alpha"}
</pre>

<p>
Note: If comparator says 2 elements are equal (it returns zero) then
one of them will be removed!
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">sorted-set-by</span> (<span class="org-variable-name">fn</span> [x y] (<span class="org-variable-name">compare</span> (<span class="org-constant">:age</span> x) (<span class="org-constant">:age</span> y)))
               {<span class="org-constant">:name</span> <span class="org-string">"Bob"</span> <span class="org-constant">:age</span> 30}
               {<span class="org-constant">:name</span> <span class="org-string">"Kim"</span> <span class="org-constant">:age</span> 30}
               {<span class="org-constant">:name</span> <span class="org-string">"Foo"</span> <span class="org-constant">:age</span> 24})
</pre>
</div>

<pre class="example">
;;=&gt; #{{:age 24, :name "Foo"} {:age 30, :name "Bob"}}
</pre>

<p>
In general, first compare the thing you care about, then compare
what's left.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline198" class="outline-5">
<h5 id="orgheadline198">Vector&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline198">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">callsigns</span> [<span class="org-string">"Alfa"</span> <span class="org-string">"Bravo"</span> <span class="org-string">"Charlie"</span>])
</pre>
</div>

<ul class="org-ul">
<li>Ordered</li>
<li>Indexed by position</li>
<li>Grows at the <b>tail</b> (end)</li>
</ul>
</div>

<div id="outline-container-orgheadline199" class="outline-6">
<h6 id="orgheadline199">Uses for a Vector&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline199">
<ul class="org-ul">
<li>You need to preserve some order of inputs</li>
<li>You need efficient access to the <i>nth</i> item</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline200" class="outline-6">
<h6 id="orgheadline200">Add to a Vector&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline200">
<div class="org-src-container">

<pre class="src src-clojure">callsigns
</pre>
</div>

<pre class="example">
;;=&gt; ["Alfa" "Bravo" "Charlie"]
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">conj</span> callsigns <span class="org-string">"Delta"</span>)
</pre>
</div>

<pre class="example">
;;=&gt; ["Alfa" "Bravo" "Charlie" "Delta"]
</pre>
</div>
</div>

<div id="outline-container-orgheadline201" class="outline-6">
<h6 id="orgheadline201">Get Nth Item&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline201">
<ul class="org-ul">
<li>Index starts at zero</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">callsigns
</pre>
</div>

<pre class="example">
;;=&gt; ["Alfa" "Bravo" "Charlie"]
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">nth</span> callsigns 2)  <span class="org-comment">; get 'third' item</span>
</pre>
</div>

<pre class="example">
;;=&gt; "Charlie"
</pre>
</div>
</div>

<div id="outline-container-orgheadline202" class="outline-6">
<h6 id="orgheadline202">Take Apart a Vector&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline202">
<div class="org-src-container">

<pre class="src src-clojure">callsigns
</pre>
</div>

<pre class="example">
;;=&gt; ["Alfa" "Bravo" "Charlie"]
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">peek</span> callsigns)  <span class="org-comment">; get last item</span>
</pre>
</div>

<pre class="example">
;;=&gt; "Charlie"
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">pop</span> callsigns)  <span class="org-comment">; everything but last item</span>
</pre>
</div>

<pre class="example">
;;=&gt; ["Alfa" "Bravo"]
</pre>

<p>
Note: <code>peek</code> on a vector is more efficient than <code>last</code>.
</p>
</div>
</div>

<div id="outline-container-orgheadline203" class="outline-6">
<h6 id="orgheadline203">Vectors are Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline203">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">v</span> [<span class="org-constant">:a</span> <span class="org-constant">:b</span> <span class="org-constant">:c</span>])

(v 2)   <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; :c</span>

(v 10)  <span class="org-comment">;&gt; ERROR</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline204" class="outline-5">
<h5 id="orgheadline204">List&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline204">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">cards</span> '(10 <span class="org-constant">:ace</span> <span class="org-constant">:jack</span> 9))
</pre>
</div>

<ul class="org-ul">
<li>Must <b>quote</b> in code</li>
<li>Ordered</li>
<li><b>Not</b> indexed
<ul class="org-ul">
<li>Just <code>first</code> and <code>rest</code></li>
<li>O(N) access to N'th element</li>
</ul></li>
<li>Grows at the <b>head</b> (front)</li>
</ul>
</div>

<div id="outline-container-orgheadline205" class="outline-6">
<h6 id="orgheadline205">Uses for a List&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline205">
<ul class="org-ul">
<li>You need efficient access to the first element</li>
<li>You need to efficiently remove ("pop") the first element off the list</li>
<li>You need to preserve <b>reverse</b> order of inputs ("last in, first out")</li>
<li>You need to simulate a stack</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline206" class="outline-6">
<h6 id="orgheadline206">Add to a List&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline206">
<div class="org-src-container">

<pre class="src src-clojure">cards
</pre>
</div>

<pre class="example">
;;=&gt; (10 :ace :jack 9)
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">conj</span> cards <span class="org-constant">:queen</span>)
</pre>
</div>

<pre class="example">
;;=&gt; (:queen 10 :ace :jack 9)
</pre>
</div>
</div>

<div id="outline-container-orgheadline207" class="outline-6">
<h6 id="orgheadline207">Examine a List&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline207">
<div class="org-src-container">

<pre class="src src-clojure">cards
</pre>
</div>

<pre class="example">
;;=&gt; (10 :ace :jack 9)
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">first</span> cards)  <span class="org-comment">; get first item</span>
</pre>
</div>

<pre class="example">
;;=&gt; 10
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">rest</span> cards)   <span class="org-comment">; everything but first item</span>
</pre>
</div>

<pre class="example">
;;=&gt; (:ace :jack 9)
</pre>

<p>
Note: <code>peek</code> and <code>pop</code> on a list are the same as <code>first</code> and <code>rest</code>,
respectively.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline208" class="outline-5">
<h5 id="orgheadline208">Adding One Collection to Another&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline208">
<div class="org-src-container">

<pre class="src src-clojure">players
</pre>
</div>

<pre class="example">
;;=&gt; #{"Alice" "Bob" "Kelly"}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">new-players</span> [<span class="org-string">"Tim"</span> <span class="org-string">"Sue"</span> <span class="org-string">"Grog"</span>])

(<span class="org-variable-name">into</span> players new-players)
</pre>
</div>

<pre class="example">
;;=&gt; #{"Alice" "Grog" "Sue" "Bob" "Tim" "Kelly"}
</pre>

<p>
Note: <code>into</code> returns a collection of the same type as its <b>first</b>
argument. Not the same as <code>concat</code>, see lazy sequences.
</p>
</div>
</div>
</div>


<div id="outline-container-orgheadline214" class="outline-4">
<h4 id="orgheadline214">Destructuring&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline214">
</div><div id="outline-container-orgheadline209" class="outline-5">
<h5 id="orgheadline209">Destructuring&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline209">
<ul class="org-ul">
<li>Declarative way to pull apart compound data
<ul class="org-ul">
<li>vs. explicit, verbose access</li>
</ul></li>
<li>Works for both sequential and associative data structures</li>
<li>Nests for deep, arbitrary access</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline210" class="outline-5">
<h5 id="orgheadline210">Destructuring is Concise&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline210">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">Without destructuring:</span>
(<span class="org-keyword">defn</span> <span class="org-function-name">next-fib-pair</span> [pair]
  [(<span class="org-variable-name">second</span> pair) (<span class="org-variable-name">+</span> (<span class="org-variable-name">first</span> pair) (<span class="org-variable-name">second</span> pair))])

<span class="org-comment-delimiter">;; </span><span class="org-comment">With destructuring:</span>
(<span class="org-keyword">defn</span> <span class="org-function-name">next-fib-pair</span> [[a b]]
  [b (<span class="org-variable-name">+</span> a b)])
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline211" class="outline-5">
<h5 id="orgheadline211">Sequential Destructuring&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline211">
<ul class="org-ul">
<li>Provide vector of symbols to bind by position
<ul class="org-ul">
<li>Binds to <code>nil</code> if there's no data</li>
</ul></li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">stuff</span> [7 8 9 10 11]) <span class="org-comment">;=&gt; #'user/stuff</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">Bind a, b, c to first 3 values in stuff</span>
(<span class="org-builtin">let</span> [[a b c] stuff]
  (<span class="org-variable-name">list</span> (<span class="org-variable-name">+</span> a b) (<span class="org-variable-name">+</span> b c)))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; (15 17)</span>

(<span class="org-builtin">let</span> [[a b c d e f] stuff]
  (<span class="org-variable-name">list</span> d e f))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; (10 11 nil)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline212" class="outline-5">
<h5 id="orgheadline212">Sequential Destructuring&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline212">
<ul class="org-ul">
<li>Can get "everything else" with <code>&amp;</code>
<ul class="org-ul">
<li>Value is a sequence</li>
</ul></li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">stuff</span> [7 8 9 10 11]) <span class="org-comment">;=&gt; #'user/stuff</span>

(<span class="org-builtin">let</span> [[a &amp; others] stuff]
  (<span class="org-variable-name">println</span> a)
  (<span class="org-variable-name">println</span> others))
<span class="org-comment-delimiter">;; </span><span class="org-comment">7</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">(8 9 10 11)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline213" class="outline-5">
<h5 id="orgheadline213">Where You Can Destructure&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline213">
<ul class="org-ul">
<li>Destructuring works in <code>fn</code> and <code>defn</code> params, <code>let</code> bindings
<ul class="org-ul">
<li>And anything built on top of them</li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline221" class="outline-4">
<h4 id="orgheadline221">Performance&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline221">
</div><div id="outline-container-orgheadline215" class="outline-5">
<h5 id="orgheadline215">Persistent Data Structures&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline215">
<ul class="org-ul">
<li>"Change" always creates new copy</li>
<li>Old versions remain available</li>
<li>All Clojure data structures are persistent</li>
<li>Clojure does this efficiently</li>
<li>Nothing to do with "persistent storage" on disk</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline216" class="outline-5">
<h5 id="orgheadline216">Example: Linked List&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline216">

<div class="figure">
<p><object type="image/svg+xml" data="slide-assets/collections-linked-list-1.svg" >
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline217" class="outline-5">
<h5 id="orgheadline217">Example: Linked List&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline217">

<div class="figure">
<p><object type="image/svg+xml" data="slide-assets/collections-linked-list-2.svg" >
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline218" class="outline-5">
<h5 id="orgheadline218">Example: Binary Tree&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline218">

<div class="figure">
<p><object type="image/svg+xml" data="slide-assets/collections-tree-1.svg" >
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline219" class="outline-5">
<h5 id="orgheadline219">Example: Binary Tree&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline219">

<div class="figure">
<p><object type="image/svg+xml" data="slide-assets/collections-tree-2.svg" >
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline220" class="outline-5">
<h5 id="orgheadline220">Example: Shared Structure&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline220">

<div class="figure">
<p><object type="image/svg+xml" data="slide-assets/collections-structural-sharing.svg" >
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline222" class="outline-4">
<h4 id="orgheadline222">Choosing a Collection&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline222">
<ul class="org-ul">
<li>Each data structure operation has specific performance guarantees</li>
<li>Most operations either <i>linear time</i> or <i>constant time</i></li>
<li>Choose data structure by operations you need</li>
</ul>
</div>

<div id="outline-container-orgheadline223" class="outline-5">
<h5 id="orgheadline223">Linear Time&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline223">
<ul class="org-ul">
<li>O( <i>n</i> ) in size of collection</li>
<li><code>nth</code> on lists</li>
<li><code>last</code> on anything</li>
<li>Almost anything using sequences</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline224" class="outline-5">
<h5 id="orgheadline224">Constant Time&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline224">
<ul class="org-ul">
<li>O(1)</li>
<li><code>first</code>, <code>rest</code>, <code>peek</code>, <code>pop</code> on lists</li>
<li><code>conj</code> on lists</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline225" class="outline-5">
<h5 id="orgheadline225">Near-Constant Time&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline225">
<ul class="org-ul">
<li>O(log <sub>32</sub> <i>n</i>)
<ul class="org-ul">
<li>Which is <b>really close</b> to O(1)</li>
<li>And actually <b>is</b> O(1) for <i>n</i> &lt; 1 billion</li>
</ul></li>
<li>Most operations on vectors, sets, &amp; maps</li>
<li><code>nth</code> on vectors but not on lists</li>
<li><code>peek</code> on vectors but not <code>last</code></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline226" class="outline-5">
<h5 id="orgheadline226">Summary&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline226">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">If you need&#x2026;</th>
<th scope="col" class="org-left">Then use&#x2026;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Preserve input order</td>
<td class="org-left">vector</td>
</tr>

<tr>
<td class="org-left">Lookup by index</td>
<td class="org-left">vector</td>
</tr>

<tr>
<td class="org-left">"Does it contain X?"</td>
<td class="org-left">set</td>
</tr>

<tr>
<td class="org-left">Remove item</td>
<td class="org-left">set</td>
</tr>

<tr>
<td class="org-left">Sort order</td>
<td class="org-left">sorted set</td>
</tr>

<tr>
<td class="org-left">Last in, first out</td>
<td class="org-left">list</td>
</tr>
</tbody>
</table>
</div>
</div>



<div id="outline-container-orgheadline227" class="outline-5">
<h5 id="orgheadline227">Review&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline227">
<ul class="org-ul">
<li>What function do you use to add an element to a collection?</li>
<li>What function pours one collection into another?</li>
<li>What function removes an element from a set?</li>
<li>What does (contains? #{1 2} 1) return?</li>
<li>What does (contains? [1 2] 2) return?</li>
<li>How do you split [1 2 3] into 1 and (2 3)?</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline228" class="outline-3">
<h3 id="orgheadline228">Collections as Indexes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-orgheadline228">
</div>

<div id="outline-container-orgheadline229" class="outline-4">
<h4 id="orgheadline229">Collections as Indexes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline229">
<ul class="org-ul">
<li>You need to <b>associate</b> one type of stuff with another type of stuff</li>
<li>"Given an X, find me its Y"</li>
<li>Make a <b>mapping</b> from X's to Y's</li>
<li>Use a map</li>
</ul>
</div>

<div id="outline-container-orgheadline230" class="outline-5">
<h5 id="orgheadline230">Common Functions for Maps&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline230">
<div class="org-src-container">

<pre class="src src-clojure">assoc      - associate a new key-value mapping
dissoc     - dissociate a mapping by key
into       - pour one map into another
reduce     - apply a function to each mapping to accumulate result
keys       - sequence of map's keys
vals       - sequence of map's values
merge      - merge maps together
merge-with - merge maps and combine keys with fn
update-in  - update a value in nested map
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline231" class="outline-5">
<h5 id="orgheadline231">Map Example&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline231">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">scores</span> {<span class="org-string">"Una"</span> 1400
             <span class="org-string">"Bob"</span> 1240
             <span class="org-string">"Cid"</span> 1024})
</pre>
</div>
</div>

<div id="outline-container-orgheadline232" class="outline-6">
<h6 id="orgheadline232">Look Up in a Map&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline232">
<div class="org-src-container">

<pre class="src src-clojure">scores
</pre>
</div>

<pre class="example">
;;=&gt; {"Una" 1400, "Bob" 1240, "Cid" 1024}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">get</span> scores <span class="org-string">"Cid"</span>)
</pre>
</div>

<pre class="example">
;;=&gt; 1024
</pre>

<p>
Alternative:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(scores <span class="org-string">"Cid"</span>)   <span class="org-comment">; Note: error if scores is nil</span>
</pre>
</div>

<pre class="example">
;;=&gt; 1024
</pre>
</div>
</div>

<div id="outline-container-orgheadline233" class="outline-6">
<h6 id="orgheadline233">Look Up with Default&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline233">
<div class="org-src-container">

<pre class="src src-clojure">scores
</pre>
</div>

<pre class="example">
;;=&gt; {"Una" 1400, "Bob" 1240, "Cid" 1024}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">get</span> scores <span class="org-string">"Samwise"</span> 0)
</pre>
</div>

<pre class="example">
;;=&gt; 0
</pre>

<p>
Alternative:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(scores <span class="org-string">"Samwise"</span> 0)   <span class="org-comment">; Note: error if scores is nil</span>
</pre>
</div>

<pre class="example">
;;=&gt; 0
</pre>
</div>
</div>

<div id="outline-container-orgheadline234" class="outline-6">
<h6 id="orgheadline234">Maps and Keywords are Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline234">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">m</span> {<span class="org-constant">:a</span> 1 <span class="org-constant">:b</span> 2})

<span class="org-comment-delimiter">;; </span><span class="org-comment">Maps are functions of their keys</span>
(m <span class="org-constant">:b</span>)       <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 2</span>
(m <span class="org-constant">:foo</span>)     <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; nil</span>
(m <span class="org-constant">:foo</span> 50)  <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 50    ; default</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">Keywords are functions of maps</span>
(<span class="org-constant">:a</span> m)    <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 1</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline235" class="outline-6">
<h6 id="orgheadline235">Does the Map Contain Item&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline235">
<div class="org-src-container">

<pre class="src src-clojure">scores
</pre>
</div>

<pre class="example">
;;=&gt; {"Una" 1400, "Bob" 1240, "Cid" 1024}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">contains?</span> scores <span class="org-string">"Una"</span>)
</pre>
</div>

<pre class="example">
;;=&gt; true
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">find</span> scores <span class="org-string">"Una"</span>)
</pre>
</div>

<pre class="example">
;;=&gt; ["Una" 1400]
</pre>

<p>
Note: <code>contains?</code> only works on indexed collections.
</p>
<ul class="org-ul">
<li>sets, maps</li>
<li>vectors are indexed, too!</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline236" class="outline-6">
<h6 id="orgheadline236">Get Just Keys or Values&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline236">
<div class="org-src-container">

<pre class="src src-clojure">scores
</pre>
</div>

<pre class="example">
;;=&gt; {"Una" 1400, "Bob" 1240, "Cid" 1024}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">keys</span> scores)
</pre>
</div>

<pre class="example">
;;=&gt; ("Una" "Bob" "Cid")
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">vals</span> scores)
</pre>
</div>

<pre class="example">
;;=&gt; (1400 1240 1024)
</pre>
</div>
</div>

<div id="outline-container-orgheadline237" class="outline-6">
<h6 id="orgheadline237">Building a Map&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline237">
<div class="org-src-container">

<pre class="src src-clojure">players
</pre>
</div>

<pre class="example">
;;=&gt; #{"Alice" "Bob" "Kelly"}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">zipmap</span> players (<span class="org-variable-name">repeat</span> 0))
</pre>
</div>

<pre class="example">
;;=&gt; {"Kelly" 0, "Bob" 0, "Alice" 0}
</pre>

<p>
Alternative:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">into</span> {} (<span class="org-variable-name">map</span> (<span class="org-variable-name">fn</span> [player] [player 0]) players))
</pre>
</div>

<pre class="example">
;;=&gt; {"Alice" 0, "Bob" 0, "Kelly" 0}
</pre>

<p>
Note: this doesn't work:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">into</span> {} (<span class="org-variable-name">map</span> #([% 0]) players))
</pre>
</div>

<pre class="example">
;; ArityException Wrong number of args (0) passed to: PersistentVector  clojure.lang.AFn.throwArity (AFn.java:437)
</pre>
</div>
</div>

<div id="outline-container-orgheadline238" class="outline-6">
<h6 id="orgheadline238">Building a Map with <code>reduce</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline238">
<div class="org-src-container">

<pre class="src src-clojure">players
</pre>
</div>

<pre class="example">
;;=&gt; #{"Alice" "Bob" "Kelly"}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">reduce</span> (<span class="org-variable-name">fn</span> [m player]
          (<span class="org-variable-name">assoc</span> m player 0))
        {}  <span class="org-comment">; initial value</span>
        players)
</pre>
</div>

<pre class="example">
;;=&gt; {"Kelly" 0, "Bob" 0, "Alice" 0}
</pre>
</div>
</div>

<div id="outline-container-orgheadline239" class="outline-6">
<h6 id="orgheadline239">Combining Maps&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline239">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">new-scores</span> {<span class="org-string">"Cid"</span> 300 <span class="org-string">"Baz"</span> 900})

(<span class="org-variable-name">merge</span> scores new-scores)
</pre>
</div>

<pre class="example">
;;=&gt; {"Una" 1400, "Bob" 1240, "Baz" 900, "Cid" 300}
</pre>

<p>
If both maps contain the same key, second one wins.
</p>
</div>
</div>

<div id="outline-container-orgheadline240" class="outline-6">
<h6 id="orgheadline240">Combining Maps with Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline240">
<div class="org-src-container">

<pre class="src src-clojure">scores
</pre>
</div>

<pre class="example">
;;=&gt; {"Una" 1400, "Bob" 1240, "Cid" 1024}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">new-scores</span> {<span class="org-string">"Una"</span> 550 <span class="org-string">"Cid"</span> 900 <span class="org-string">"Samwise"</span> 1000})

(<span class="org-variable-name">merge-with</span> + scores new-scores)
</pre>
</div>

<pre class="example">
;;=&gt; {"Samwise" 1000, "Una" 1950, "Bob" 1240, "Cid" 1924}
</pre>

<p>
If both maps contain the same <b>key</b>, call the function on both
<b>values</b> to get the new value.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline241" class="outline-5">
<h5 id="orgheadline241">Sorted Map&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline241">
<ul class="org-ul">
<li>Maintains <b>keys</b> in natural sort order</li>
<li>Uses Clojure's <code>compare</code></li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">sm</span> (<span class="org-variable-name">sorted-map</span>
         <span class="org-string">"Bravo"</span> 204
         <span class="org-string">"Alfa"</span> 35
         <span class="org-string">"Sigma"</span> 99
         <span class="org-string">"Charlie"</span> 100))

sm
</pre>
</div>

<pre class="example">
;;=&gt; {"Alfa" 35, "Bravo" 204, "Charlie" 100, "Sigma" 99}
</pre>
</div>

<div id="outline-container-orgheadline242" class="outline-6">
<h6 id="orgheadline242">Keys and Vals of Sorted Map&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline242">
<p>
<code>keys</code> and <code>vals</code> return in sorted order
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">keys</span> sm)
</pre>
</div>

<pre class="example">
;;=&gt; ("Alfa" "Bravo" "Charlie" "Sigma")
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">vals</span> sm)
</pre>
</div>

<pre class="example">
;;=&gt; (35 204 100 99)
</pre>
</div>
</div>

<div id="outline-container-orgheadline243" class="outline-6">
<h6 id="orgheadline243">Sorted Map with Comparator&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline243">
<p>
Like <code>sorted-set-by</code>
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">smb</span> (<span class="org-variable-name">sorted-map-by</span> (<span class="org-variable-name">fn</span> [x y] (<span class="org-variable-name">-</span> (<span class="org-variable-name">compare</span> x y)))
                        <span class="org-string">"Bravo"</span> 204
                        <span class="org-string">"Alfa"</span> 35
                        <span class="org-string">"Sigma"</span> 99
                        <span class="org-string">"Charlie"</span> 100))

smb
</pre>
</div>

<pre class="example">
;;=&gt; {"Sigma" 99, "Charlie" 100, "Bravo" 204, "Alfa" 35}
</pre>
</div>
</div>
</div>


<div id="outline-container-orgheadline244" class="outline-5">
<h5 id="orgheadline244">Map Destructuring&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline244">
<p>
{ } as left side of binding will initiate map destructuring
</p>

<ul class="org-ul">
<li>{new :old} - extracts :old from map and binds as new</li>
<li>{:keys [a]} - extracts :a and binds as a</li>
<li>{:syms [a b]} - extracts a and binds as a</li>
<li>{:strs [a b]} - extracts "a" and binds as a</li>
<li>{:as m} - binds entire map as m</li>
<li>{:keys [a] :or {a 5}} - extracts :a if found and binds as a, else binds as 5</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline245" class="outline-5">
<h5 id="orgheadline245">:keys example&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline245">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">stuff</span> {<span class="org-constant">:a</span> 8 <span class="org-constant">:b</span> 9})

(<span class="org-builtin">let</span> [{<span class="org-constant">:keys</span> [a b c] <span class="org-constant">:or</span> {c 5} <span class="org-constant">:as</span> m} stuff]
  (<span class="org-variable-name">println</span> a b c m))
<span class="org-comment-delimiter">;; </span><span class="org-comment">8 9 5 {:a 8 :b 9}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline246" class="outline-5">
<h5 id="orgheadline246">Map Destructuring&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline246">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">stuff</span> {<span class="org-constant">:a</span> 8 <span class="org-constant">:b</span> 9 <span class="org-constant">:c</span> 10})

(<span class="org-builtin">let</span> [{<span class="org-constant">:keys</span> [a b c]} stuff]
  (<span class="org-variable-name">println</span> a b c))
<span class="org-comment-delimiter">;; </span><span class="org-comment">8 9 10</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline247" class="outline-5">
<h5 id="orgheadline247">Named Arguments&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline247">
<ul class="org-ul">
<li>Applying vector of keys to <code>&amp;</code> binding emulates named args</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">game</span> [planet &amp; {<span class="org-constant">:keys</span> [human-players computer-players]}]
  (<span class="org-variable-name">println</span> <span class="org-string">"Total players: "</span> (<span class="org-variable-name">+</span> human-players computer-players)))

(game <span class="org-string">"Mars"</span> <span class="org-constant">:human-players</span> 1 <span class="org-constant">:computer-players</span> 2)
<span class="org-comment-delimiter">;; </span><span class="org-comment">Total players: 3</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline252" class="outline-4">
<h4 id="orgheadline252">Transients&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline252">
</div><div id="outline-container-orgheadline248" class="outline-5">
<h5 id="orgheadline248">Fast Accumulation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline248">
<ul class="org-ul">
<li>Consider rapidly accumulating values into a collection</li>
<li>Each new value creates a new persistent collection</li>
<li>What if we could safely use mutation while we were accumulating,
then switch back to persistent collections?</li>
<li>Supported with transient hash-sets, vectors, and hash-maps</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline249" class="outline-5">
<h5 id="orgheadline249">Creating Transient Collections&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline249">
<ul class="org-ul">
<li>Create from existing collection with <code>transient</code></li>
<li>O(1) time</li>
<li>Original collection is still immutable</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline250" class="outline-5">
<h5 id="orgheadline250">Using Transient Collections&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline250">
<ul class="org-ul">
<li>Transient collection supports "read" methods - <code>get</code>, <code>nth</code>, etc</li>
<li>Transient collection do not support "write" methods like <code>conj</code>,
<code>assoc</code>, etc</li>
<li>Instead use <code>conj!</code>, <code>assoc!</code>, etc</li>
<li>Convert back with <code>persistent!</code> (also O(1))</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline251" class="outline-5">
<h5 id="orgheadline251">Transient Example&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline251">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">vrange</span> [n]
  (<span class="org-builtin">loop</span> [i 0
         v (<span class="org-variable-name">transient</span> [])]
    (<span class="org-builtin">if</span> (<span class="org-variable-name">&lt;</span> i n)
      (<span class="org-builtin">recur</span> (<span class="org-variable-name">inc</span> i) (<span class="org-variable-name">conj!</span> v i))
      (<span class="org-variable-name">persistent!</span> v))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline254" class="outline-4">
<h4 id="orgheadline254">Map</h4>
<div class="outline-text-4" id="text-orgheadline254">
</div><div id="outline-container-orgheadline253" class="outline-5">
<h5 id="orgheadline253">Review&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline253">
<ul class="org-ul">
<li>What are the keys in {:a 1 :b 2 :c 3} ?</li>
<li>What are all the ways to get 1 from {:a 1}?</li>
</ul>

<p>
Given:  (def m {:x 5})
</p>

<ul class="org-ul">
<li>How do we add a new mapping :y 10 to m?</li>
<li>How do we get a modified m with :x mapped to 4?</li>
<li>How do we remove the :x mapping from m?</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline255" class="outline-3">
<h3 id="orgheadline255">LAB: Collections&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-orgheadline255">
</div>

<div id="outline-container-orgheadline264" class="outline-4">
<h4 id="orgheadline264">Building Collections</h4>
<div class="outline-text-4" id="text-orgheadline264">
</div><div id="outline-container-orgheadline256" class="outline-5">
<h5 id="orgheadline256">Representing scores in a game</h5>
<div class="outline-text-5" id="text-orgheadline256">
<p>
What collection would be best to represent a table of scores
(represented by a number) for players (represented by a string) in a
game?
</p>
</div>

<div id="outline-container-orgheadline257" class="outline-6">
<h6 id="orgheadline257">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline257">
<p>
This is an index of string to number and is best represented as a map.
</p>

<pre class="example">
{"Una" 1400
 "Bob" 1240
 "Cid" 1024}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline258" class="outline-5">
<h5 id="orgheadline258">Add a new player to the scores</h5>
<div class="outline-text-5" id="text-orgheadline258">
<p>
Given a scores table:
</p>

<p>
<code>(def scores {"Una" 1400, "Bob" 1240, "Cid" 1024})</code>
</p>

<p>
write an expression that adds a new player "Mel" to the table.
</p>
</div>

<div id="outline-container-orgheadline259" class="outline-6">
<h6 id="orgheadline259">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline259">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">assoc</span> scores <span class="org-string">"Mel"</span> 0)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline260" class="outline-5">
<h5 id="orgheadline260">Representing a player</h5>
<div class="outline-text-5" id="text-orgheadline260">
<p>
How would you represent a player with the attributes <code>name</code> and <code>ranking</code>?
</p>
</div>

<div id="outline-container-orgheadline261" class="outline-6">
<h6 id="orgheadline261">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline261">
<p>
There are two reasonable answers: maps and records. A map would look
like this:
</p>

<div class="org-src-container">

<pre class="src src-clojure">{<span class="org-constant">:name</span> <span class="org-string">"Una"</span> <span class="org-constant">:ranking</span> 43}
</pre>
</div>

<p>
Given that we have known attributes representing an entity, it's also
reasonable to use a record:
</p>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">define the record</span>
(<span class="org-keyword">defrecord</span> <span class="org-function-name">Player</span> [name ranking])

<span class="org-comment-delimiter">;; </span><span class="org-comment">define a player</span>
(-&gt;<span class="org-preprocessor">Player</span> <span class="org-string">"Una"</span> 43)
</pre>
</div>

<p>
For the rest of this lab, we'll stick with the map representation for
players as the examples are easier to read.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline262" class="outline-5">
<h5 id="orgheadline262">Retrieving the a player's ranking</h5>
<div class="outline-text-5" id="text-orgheadline262">
<p>
Given either a map or record instance of a player like this:
</p>

<div class="org-src-container">

<pre class="src src-clojure">{<span class="org-constant">:name</span> <span class="org-string">"Una"</span> <span class="org-constant">:ranking</span> 43}
</pre>
</div>

<p>
What are three ways to retrieve the ranking given a player?
</p>
</div>

<div id="outline-container-orgheadline263" class="outline-6">
<h6 id="orgheadline263">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline263">
<p>
Here are three different ways to do a lookup of a keyword key in a
map:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">get</span> player <span class="org-constant">:ranking</span>)
(player <span class="org-constant">:ranking</span>)
(<span class="org-constant">:ranking</span> player)
</pre>
</div>

<p>
The last option where the keyword is used as a function is the most
common usage.
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-orgheadline271" class="outline-4">
<h4 id="orgheadline271">Modifying Nested Collections</h4>
<div class="outline-text-4" id="text-orgheadline271">
</div><div id="outline-container-orgheadline265" class="outline-5">
<h5 id="orgheadline265">Advance to the next round</h5>
<div class="outline-text-5" id="text-orgheadline265">
<p>
A game's state is represented in a data structure like this:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">game</span>
  {<span class="org-constant">:round</span> 2
   <span class="org-constant">:players</span> #{{<span class="org-constant">:name</span> <span class="org-string">"Una"</span> <span class="org-constant">:ranking</span> 43}
              {<span class="org-constant">:name</span> <span class="org-string">"Bob"</span> <span class="org-constant">:ranking</span> 77}
              {<span class="org-constant">:name</span> <span class="org-string">"Cid"</span> <span class="org-constant">:ranking</span> 33}}
   <span class="org-constant">:scores</span> {<span class="org-string">"Una"</span> 1400
            <span class="org-string">"Bob"</span> 1240
            <span class="org-string">"Cid"</span> 1024}})
</pre>
</div>

<p>
Write a function <code>next-round</code> that takes a game and returns it with
the round incremented.
</p>

<p>
<i>Note:</i> Clojure has a function <code>update-in</code> that applies a function to a
value in a nested associative structure and returns the updated map:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">update-in</span> {<span class="org-constant">:a</span> {<span class="org-constant">:b</span> 1}} [<span class="org-constant">:a</span> <span class="org-constant">:b</span>] inc)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; {:a {:b 2}}</span>
</pre>
</div>

<p>
The <code>[:a :b]</code> vector is a series of keys that are applied from the
root of the map to locate the value that will be passed to the
function.
</p>
</div>

<div id="outline-container-orgheadline266" class="outline-6">
<h6 id="orgheadline266">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline266">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">next-round</span> [game]
  (<span class="org-variable-name">update-in</span> game [<span class="org-constant">:round</span>] inc))
</pre>
</div>

<p>
Example use:
</p>

<pre class="example">
(next-round game)
;; =&gt; {:round 3
;;     :players #{{:name "Una" :ranking 43}
;;                {:name "Bob" :ranking 77}
;;                {:name "Cid" :ranking 33}}
;;     :scores {"Una" 1400
;;              "Bob" 1240
;;              "Cid" 1024}}
</pre>
</div>
</div>
</div>


<div id="outline-container-orgheadline267" class="outline-5">
<h5 id="orgheadline267">Update the scores</h5>
<div class="outline-text-5" id="text-orgheadline267">
<p>
Write a function <code>add-score</code> that increments a players score by a
specified amount.
</p>
</div>

<div id="outline-container-orgheadline268" class="outline-6">
<h6 id="orgheadline268">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline268">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">add-score</span> [game name score]
  (<span class="org-variable-name">update-in</span> game [<span class="org-constant">:scores</span> name] + score))
</pre>
</div>

<p>
Example:
</p>
<pre class="example">
(add-score game "Cid" 500)
;; =&gt; {:round 3
;;     :players #{{:name "Una" :ranking 43}
;;                {:name "Bob" :ranking 77}
;;                {:name "Cid" :ranking 33}}
;;     :scores {"Una" 1400
;;              "Bob" 1240
;;              "Cid" 1524}}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline269" class="outline-5">
<h5 id="orgheadline269">Add a new player</h5>
<div class="outline-text-5" id="text-orgheadline269">
<p>
Write a function <code>add-player</code> that adds a new player and initializes
their score.
</p>
</div>

<div id="outline-container-orgheadline270" class="outline-6">
<h6 id="orgheadline270">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline270">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">add-player</span> [game name ranking]
  (<span class="org-variable-name">update-in</span> (<span class="org-variable-name">update-in</span> game [<span class="org-constant">:players</span>] conj {<span class="org-constant">:name</span> name <span class="org-constant">:ranking</span> ranking})
             [<span class="org-constant">:scores</span>] assoc name 0))
</pre>
</div>

<p>
or with the thread-first <code>-&gt;</code>: 
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">add-player</span> [game name ranking]
  (<span class="org-builtin">-&gt;</span> game
      (<span class="org-variable-name">update-in</span> [<span class="org-constant">:players</span>] conj {<span class="org-constant">:name</span> name <span class="org-constant">:ranking</span> ranking})
      (<span class="org-variable-name">update-in</span> [<span class="org-constant">:scores</span>] assoc name 0)))
</pre>
</div>

<p>
Example:
</p>
<pre class="example">
(add-player game "Mel" 24)
;; =&gt; {:round 3
;;     :players #{{:name "Una" :ranking 43}
;;                {:name "Bob" :ranking 77}
;;                {:name "Cid" :ranking 33}
;;                {:name "Mel" :ranking 24}}
;;     :scores {"Una" 1400
;;              "Bob" 1240
;;              "Cid" 1524
;;              "Mel" 0}}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline278" class="outline-4">
<h4 id="orgheadline278">Index Lookup</h4>
<div class="outline-text-4" id="text-orgheadline278">
</div><div id="outline-container-orgheadline272" class="outline-5">
<h5 id="orgheadline272">Looking up a player</h5>
<div class="outline-text-5" id="text-orgheadline272">
<p>
We'd like to be able to look up a player's ranking based on their
name. This is currently difficult. What data structure would make
this easier?
</p>
</div>

<div id="outline-container-orgheadline273" class="outline-6">
<h6 id="orgheadline273">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline273">
<p>
Currently player information is stored in a set and there is no way
to look up a player by name. Alternatively we could index the players
by name like we do with scores:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">game</span>
  {<span class="org-constant">:round</span> 2
   <span class="org-constant">:players</span> {<span class="org-string">"Una"</span> {<span class="org-constant">:name</span> <span class="org-string">"Una"</span> <span class="org-constant">:ranking</span> 43}
             <span class="org-string">"Bob"</span> {<span class="org-constant">:name</span> <span class="org-string">"Bob"</span> <span class="org-constant">:ranking</span> 77}
             <span class="org-string">"Cid"</span> {<span class="org-constant">:name</span> <span class="org-string">"Cid"</span> <span class="org-constant">:ranking</span> 33}}
   <span class="org-constant">:scores</span> {<span class="org-string">"Una"</span> 1400
            <span class="org-string">"Bob"</span> 1240
            <span class="org-string">"Cid"</span> 1024}})
</pre>
</div>

<p>
Since we now have two maps with the same keys, it makes sense to
combine them into a single player index:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">game</span>
  {<span class="org-constant">:round</span> 2
   <span class="org-constant">:players</span> {<span class="org-string">"Una"</span> {<span class="org-constant">:name</span> <span class="org-string">"Una"</span> <span class="org-constant">:ranking</span> 43 <span class="org-constant">:score</span> 1400}
             <span class="org-string">"Bob"</span> {<span class="org-constant">:name</span> <span class="org-string">"Bob"</span> <span class="org-constant">:ranking</span> 77 <span class="org-constant">:score</span> 1240}
             <span class="org-string">"Cid"</span> {<span class="org-constant">:name</span> <span class="org-string">"Cid"</span> <span class="org-constant">:ranking</span> 33 <span class="org-constant">:score</span> 1024}}})
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline274" class="outline-5">
<h5 id="orgheadline274">Find a player</h5>
<div class="outline-text-5" id="text-orgheadline274">
<p>
Using the game definition defined in the prior section, how can we
implement <code>find-player</code> for a game?
</p>
</div>

<div id="outline-container-orgheadline275" class="outline-6">
<h6 id="orgheadline275">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline275">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">find-player</span> [game name]
  (<span class="org-variable-name">get-in</span> game [<span class="org-constant">:players</span> name]))
</pre>
</div>

<p>
Example:
</p>
<div class="org-src-container">

<pre class="src src-clojure">(find-player game <span class="org-string">"Una"</span>)
<span class="org-comment-delimiter">;; </span><span class="org-comment">=&gt; {:name "Una", :score 1400, :ranking 43}</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline276" class="outline-5">
<h5 id="orgheadline276">Remove a player</h5>
<div class="outline-text-5" id="text-orgheadline276">
<p>
Write a function <code>remove-player</code> that removes a player from a game,
including their score. 
</p>
</div>

<div id="outline-container-orgheadline277" class="outline-6">
<h6 id="orgheadline277">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline277">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">remove-player</span> [game name]
  (<span class="org-variable-name">update-in</span> game [<span class="org-constant">:players</span>] dissoc name))
</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline279" class="outline-3">
<h3 id="orgheadline279">Collections as Structured Data&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-orgheadline279">
</div>

<div id="outline-container-orgheadline280" class="outline-4">
<h4 id="orgheadline280">Collections as Structured Data&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline280">
<ul class="org-ul">
<li>Small set of named "fields"</li>
<li>Field names known in advance</li>
<li>Use a map
<ul class="org-ul">
<li>Keys are keywords</li>
<li>Values are any type</li>
</ul></li>
</ul>
</div>

<div id="outline-container-orgheadline281" class="outline-5">
<h5 id="orgheadline281">Common Functions for Structured Data&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline281">
<div class="org-src-container">

<pre class="src src-clojure">assoc
assoc-in
dissoc
update-in
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline282" class="outline-5">
<h5 id="orgheadline282">Structured Data Example&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline282">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">person</span>
  {<span class="org-constant">:first-name</span> <span class="org-string">"Kelly"</span>
   <span class="org-constant">:last-name</span> <span class="org-string">"Keen"</span>
   <span class="org-constant">:age</span> 32
   <span class="org-constant">:occupation</span> <span class="org-string">"Programmer"</span>})
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline283" class="outline-5">
<h5 id="orgheadline283">Get Values Out of Structures&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline283">
<ul class="org-ul">
<li>Use keywords as functions
<ul class="org-ul">
<li>When the map represents structured data</li>
<li>And the keyword is a literal</li>
</ul></li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-constant">:occupation</span> person)
</pre>
</div>

<pre class="example">
;;=&gt; "Programmer"
</pre>
</div>
</div>

<div id="outline-container-orgheadline284" class="outline-5">
<h5 id="orgheadline284">Get Values With Default&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline284">
<div class="org-src-container">

<pre class="src src-clojure">(pprint person)
</pre>
</div>

<pre class="example">
;; {:age 32,
;;  :last-name "Keen",
;;  :first-name "Kelly",
;;  :occupation "Programmer"}
;;=&gt; nil
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-constant">:favorite-color</span> person <span class="org-string">"beige"</span>)
</pre>
</div>

<pre class="example">
;;=&gt; "beige"
</pre>
</div>
</div>

<div id="outline-container-orgheadline285" class="outline-5">
<h5 id="orgheadline285">"Change" a Structure&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline285">
<div class="org-src-container">

<pre class="src src-clojure">(pprint (<span class="org-variable-name">assoc</span> person <span class="org-constant">:occupation</span> <span class="org-string">"Baker"</span>))
</pre>
</div>

<pre class="example">
;; {:age 32,
;;  :last-name "Keen",
;;  :first-name "Kelly",
;;  :occupation "Baker"}
;;=&gt; nil
</pre>

<p>
Note: original is unchanged
</p>

<div class="org-src-container">

<pre class="src src-clojure">(pprint person)
</pre>
</div>

<pre class="example">
;; {:age 32,
;;  :last-name "Keen",
;;  :first-name "Kelly",
;;  :occupation "Programmer"}
;;=&gt; nil
</pre>
</div>
</div>

<div id="outline-container-orgheadline286" class="outline-5">
<h5 id="orgheadline286">"Remove" a Key&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline286">
<div class="org-src-container">

<pre class="src src-clojure">(pprint (<span class="org-variable-name">dissoc</span> person <span class="org-constant">:age</span>))
</pre>
</div>

<pre class="example">
;; {:last-name "Keen",
;;  :first-name "Kelly",
;;  :occupation "Programmer"}
;;=&gt; nil
</pre>
</div>
</div>

<div id="outline-container-orgheadline287" class="outline-5">
<h5 id="orgheadline287">Nested Structure Example&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline287">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">company</span>
  {<span class="org-constant">:name</span> <span class="org-string">"WidgetCo"</span>
   <span class="org-constant">:address</span> {<span class="org-constant">:street</span> <span class="org-string">"123 Main St"</span>
             <span class="org-constant">:city</span> <span class="org-string">"Springfield"</span>
             <span class="org-constant">:state</span> <span class="org-string">"IL"</span>}})
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline288" class="outline-5">
<h5 id="orgheadline288">Reach Inside Nested Structures&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline288">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">get-in</span> company [<span class="org-constant">:address</span> <span class="org-constant">:city</span>])
</pre>
</div>

<pre class="example">
;;=&gt; "Springfield"
</pre>
</div>
</div>

<div id="outline-container-orgheadline289" class="outline-5">
<h5 id="orgheadline289">Thread-first For Nested Access&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline289">
<ul class="org-ul">
<li>"Thread-first"</li>
<li>Invoke each step with the prior result as the first argument</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">get</span> (<span class="org-variable-name">get</span> company <span class="org-constant">:address</span>) <span class="org-constant">:city</span>)
</pre>
</div>

<ul class="org-ul">
<li>Rewrite as:</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">-&gt;</span> company <span class="org-constant">:address</span> <span class="org-constant">:city</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline290" class="outline-5">
<h5 id="orgheadline290">"Change" a Nested Structure&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline290">
<div class="org-src-container">

<pre class="src src-clojure">(pprint (<span class="org-variable-name">assoc-in</span> company [<span class="org-constant">:address</span> <span class="org-constant">:street</span>] <span class="org-string">"303 Broadway"</span>))
</pre>
</div>

<pre class="example">
;; {:name "WidgetCo",
;;  :address
;;  {:state "IL",
;;   :city "Springfield",
;;   :street "303 Broadway"}}
;;=&gt; nil
</pre>
</div>
</div>

<div id="outline-container-orgheadline291" class="outline-5">
<h5 id="orgheadline291">Records&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline291">
<ul class="org-ul">
<li>Better performance</li>
<li>Have named "type"</li>
<li>Can have polymorphic behavior by implementing protocols</li>
<li>Usage like maps
<ul class="org-ul">
<li>Different way of constructing</li>
<li>Cannot be invoked like functions</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline292" class="outline-5">
<h5 id="orgheadline292">Constructing Records&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline292">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defrecord</span> <span class="org-function-name">Person</span> [first-name last-name age occupation])

<span class="org-comment-delimiter">;; </span><span class="org-comment">Positional constructor - generated</span>
(<span class="org-keyword">def</span> <span class="org-function-name">kelly</span> (-&gt;<span class="org-preprocessor">Person</span> <span class="org-string">"Kelly"</span> <span class="org-string">"Keen"</span> 32 <span class="org-string">"Programmer"</span>))

<span class="org-comment-delimiter">;; </span><span class="org-comment">Map constructor - generated</span>
(<span class="org-keyword">def</span> <span class="org-function-name">kelly</span> (map-&gt;<span class="org-preprocessor">Person</span>
             {<span class="org-constant">:first-name</span> <span class="org-string">"Kelly"</span>
              <span class="org-constant">:last-name</span> <span class="org-string">"Keen"</span>
              <span class="org-constant">:age</span> 32
              <span class="org-constant">:occupation</span> <span class="org-string">"Programmer"</span>}))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline293" class="outline-5">
<h5 id="orgheadline293">Record Literals&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline293">
<div class="org-src-container">

<pre class="src src-clojure">#<span class="org-preprocessor">user.Foo</span>{<span class="org-constant">:a</span> 1 <span class="org-constant">:b</span> 2}   <span class="org-comment">; fields by name</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #user.Foo{:a 1, :b 2, :c nil}</span>

#<span class="org-preprocessor">user.Foo</span>[1 2 3]       <span class="org-comment">; fields by position</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #user.Foo{:a 1, :b 2, :c 3}</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline296" class="outline-4">
<h4 id="orgheadline296">Data Structure Summary&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline296">
</div><div id="outline-container-orgheadline294" class="outline-5">
<h5 id="orgheadline294">Constructing&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline294">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-preprocessor">Literal</span>              <span class="org-preprocessor">Constructor</span>            <span class="org-preprocessor">From</span> another collection

[1 2]                (<span class="org-variable-name">vector</span> 1 2)           (<span class="org-variable-name">vec</span> '(1 2))

#{1 2}               (<span class="org-variable-name">hash-set</span> 1 2)         (<span class="org-variable-name">set</span> [1 2])

'(1 2)               (<span class="org-variable-name">list</span> 1 2)             (<span class="org-variable-name">list*</span> [1 2])

{<span class="org-constant">:a</span> 1 <span class="org-constant">:b</span> 2}          (<span class="org-variable-name">array-map</span> <span class="org-constant">:a</span> 1 <span class="org-constant">:b</span> 2)  (<span class="org-variable-name">apply</span> array-map [<span class="org-constant">:a</span> 1 <span class="org-constant">:b</span> 2])
                     (<span class="org-variable-name">hash-map</span> <span class="org-constant">:a</span> 1 <span class="org-constant">:b</span> 2)   (<span class="org-variable-name">apply</span> hash-map [<span class="org-constant">:a</span> 1 <span class="org-constant">:b</span> 2])
                                            (<span class="org-variable-name">into</span> {} [[<span class="org-constant">:a</span> 1] [<span class="org-constant">:b</span> 2]])

#<span class="org-preprocessor">user.Foo</span>{<span class="org-constant">:a</span> 1 <span class="org-constant">:b</span> 2} (-&gt;<span class="org-preprocessor">Foo</span> 1 2)            (map-&gt;<span class="org-preprocessor">Foo</span> {<span class="org-constant">:a</span> 1 <span class="org-constant">:b</span> 2})
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline295" class="outline-5">
<h5 id="orgheadline295">Using&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline295">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Add Item</th>
<th scope="col" class="org-left">Get Item</th>
<th scope="col" class="org-left">Remove Item</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Vector</td>
<td class="org-left">conj</td>
<td class="org-left">nth, peek</td>
<td class="org-left">pop</td>
</tr>

<tr>
<td class="org-left">Set</td>
<td class="org-left">conj</td>
<td class="org-left">contains?</td>
<td class="org-left">disj</td>
</tr>

<tr>
<td class="org-left">List</td>
<td class="org-left">conj</td>
<td class="org-left">first, rest</td>
<td class="org-left">pop</td>
</tr>

<tr>
<td class="org-left">Map</td>
<td class="org-left">assoc, conj</td>
<td class="org-left">get</td>
<td class="org-left">dissoc</td>
</tr>

<tr>
<td class="org-left">Nested Maps</td>
<td class="org-left">assoc-in</td>
<td class="org-left">get-in</td>
<td class="org-left">update-in &amp; dissoc</td>
</tr>

<tr>
<td class="org-left">Record</td>
<td class="org-left">assoc</td>
<td class="org-left">get</td>
<td class="org-left">dissoc</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline297" class="outline-3">
<h3 id="orgheadline297">LAB: Structured Data&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-orgheadline297">
</div>

<div id="outline-container-orgheadline313" class="outline-4">
<h4 id="orgheadline313">Structured Data</h4>
<div class="outline-text-4" id="text-orgheadline313">
</div><div id="outline-container-orgheadline298" class="outline-5">
<h5 id="orgheadline298">Modeling a Course Catalog</h5>
<div class="outline-text-5" id="text-orgheadline298">
<p>
Let's consider how to model a college course catalog. Create record
definitions representing the following domain types:
</p>

<ul class="org-ul">
<li>Course
<ul class="org-ul">
<li>course-id (ex: "ECON-101")</li>
<li>name (ex: "Economics 101")</li>
<li>prereqs - other course ids that are a prereq</li>
<li>hours - credit hours this is worth (ex: 3)</li>
</ul></li>

<li>Faculty
<ul class="org-ul">
<li>faculty-id (ex: "184826")</li>
<li>first</li>
<li>last</li>
</ul></li>

<li>Offering
<ul class="org-ul">
<li>offering-id (ex: "123123")</li>
<li>course - course id</li>
<li>teacher - faculty id</li>
<li>days - list of 2-char day of the week (Mo, Tu, &#x2026;)</li>
<li>start-time - "9:00am"</li>
<li>end-time - "10:00am"</li>
</ul></li>
</ul>
</div>

<div id="outline-container-orgheadline299" class="outline-6">
<h6 id="orgheadline299">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline299">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defrecord</span> <span class="org-function-name">Course</span> [course-id name prereqs hours])
(<span class="org-keyword">defrecord</span> <span class="org-function-name">Faculty</span> [faculty-id first last])
(<span class="org-keyword">defrecord</span> <span class="org-function-name">Offering</span> [offering-id course teacher days start-time end-time])
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline300" class="outline-5">
<h5 id="orgheadline300">Course catalog</h5>
<div class="outline-text-5" id="text-orgheadline300">
<p>
We'll work with the following example data, each represented as a 
map, keyed by the id for the entity type.
</p>

<p>
You can use this to initialize your course catalog data:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">courses</span>
  {<span class="org-string">"CS-101"</span> (-&gt;<span class="org-preprocessor">Course</span> <span class="org-string">"CS-101"</span> <span class="org-string">"Comp Sci Concepts"</span> nil 2)
   <span class="org-string">"CS-110"</span> (-&gt;<span class="org-preprocessor">Course</span> <span class="org-string">"CS-110"</span> <span class="org-string">"Data Structures"</span> #{<span class="org-string">"CS-101"</span>} 3)
   <span class="org-string">"CS-120"</span> (-&gt;<span class="org-preprocessor">Course</span> <span class="org-string">"CS-120"</span> <span class="org-string">"Intro to Algorithms"</span> #{<span class="org-string">"CS-101"</span>} 3)
   <span class="org-string">"CS-220"</span> (-&gt;<span class="org-preprocessor">Course</span> <span class="org-string">"CS-220"</span> <span class="org-string">"Compilers"</span> #{<span class="org-string">"CS-110"</span> <span class="org-string">"CS-120"</span>} 4)})

(<span class="org-keyword">def</span> <span class="org-function-name">faculty</span>
  {138138 (-&gt;<span class="org-preprocessor">Faculty</span> 138138 <span class="org-string">"John"</span> <span class="org-string">"Stringbean"</span>)
   293843 (-&gt;<span class="org-preprocessor">Faculty</span> 293843 <span class="org-string">"Maya"</span> <span class="org-string">"Mayfair"</span>)
   234232 (-&gt;<span class="org-preprocessor">Faculty</span> 234232 <span class="org-string">"Emily"</span> <span class="org-string">"Surcher"</span>)})

(<span class="org-keyword">def</span> <span class="org-function-name">offerings</span>
  {230203 (-&gt;<span class="org-preprocessor">Offering</span> 230203 <span class="org-string">"CS-101"</span> 138138 [<span class="org-string">"Mo"</span>,<span class="org-string">"We"</span>,<span class="org-string">"Fr"</span>] <span class="org-string">"8:00am"</span> <span class="org-string">"8:50am"</span>)
   234109 (-&gt;<span class="org-preprocessor">Offering</span> 234109 <span class="org-string">"CS-110"</span> 293843 [<span class="org-string">"Mo"</span>,<span class="org-string">"We"</span>,<span class="org-string">"Fr"</span>] <span class="org-string">"10:00am"</span> <span class="org-string">"10:50am"</span>)
   934934 (-&gt;<span class="org-preprocessor">Offering</span> 934934 <span class="org-string">"CS-120"</span> 138138 [<span class="org-string">"Tu"</span>, <span class="org-string">"Th"</span>] <span class="org-string">"1:00pm"</span> <span class="org-string">"3:00pm"</span>)})

(<span class="org-keyword">def</span> <span class="org-function-name">catalog</span>
  {<span class="org-constant">:courses</span> courses
   <span class="org-constant">:faculty</span> faculty
   <span class="org-constant">:offerings</span> offerings})
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline301" class="outline-5">
<h5 id="orgheadline301">Adding a course</h5>
<div class="outline-text-5" id="text-orgheadline301">
<p>
Write a function <code>add-course</code> that takes a catalog and a course
instance and returns a new catalog:
</p>
</div>

<div id="outline-container-orgheadline302" class="outline-6">
<h6 id="orgheadline302">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline302">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">add-course</span> [catalog course]
  (<span class="org-variable-name">assoc-in</span> catalog [<span class="org-constant">:courses</span> (<span class="org-constant">:course-id</span> course)] course))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline303" class="outline-5">
<h5 id="orgheadline303">Adding a faculty member</h5>
<div class="outline-text-5" id="text-orgheadline303">
<p>
Write a function <code>add-faculty</code> that takes a catalog and a
faculty member instance and returns a new catalog:
</p>
</div>

<div id="outline-container-orgheadline304" class="outline-6">
<h6 id="orgheadline304">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline304">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">add-faculty</span> [catalog faculty]
  (<span class="org-variable-name">assoc-in</span> catalog [<span class="org-constant">:faculty</span> (<span class="org-constant">:faculty-id</span> faculty)] faculty))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline305" class="outline-5">
<h5 id="orgheadline305">Adding a course offering</h5>
<div class="outline-text-5" id="text-orgheadline305">
<p>
Write a function <code>add-offering</code> that adds a new course offering
to the catalog.
</p>
</div>

<div id="outline-container-orgheadline306" class="outline-6">
<h6 id="orgheadline306">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline306">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">add-offering</span> [catalog offering]
  (<span class="org-variable-name">assoc-in</span> catalog [<span class="org-constant">:offerings</span> (<span class="org-constant">:offering-id</span> offering)] offering))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline307" class="outline-5">
<h5 id="orgheadline307">Offering to string</h5>
<div class="outline-text-5" id="text-orgheadline307">
<p>
Write a function that takes a catalog and offering-id and returns a
formatted string as shown:
</p>

<div class="org-src-container">

<pre class="src src-clojure">user&gt; (<span class="org-variable-name">println</span> (offer-&gt;str catalog 934934))
CS-120 <span class="org-preprocessor">Intro</span> to <span class="org-preprocessor">Algorithms</span> (3 hrs)
<span class="org-preprocessor">TuTh</span> 1:00pm-3:00pm <span class="org-preprocessor">John</span> <span class="org-preprocessor">Stringbean</span>
Prereqs: CS-101
</pre>
</div>
</div>

<div id="outline-container-orgheadline308" class="outline-6">
<h6 id="orgheadline308">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline308">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">offer-&gt;str</span> [catalog offer-id]
  (<span class="org-builtin">let</span> [offering (<span class="org-variable-name">get-in</span> catalog [<span class="org-constant">:offerings</span> offer-id])
        course-id (<span class="org-constant">:course</span> offering)
        course (<span class="org-variable-name">get-in</span> catalog [<span class="org-constant">:courses</span> course-id])
        faculty (<span class="org-variable-name">get-in</span> catalog [<span class="org-constant">:faculty</span> (<span class="org-constant">:teacher</span> offering)])
        prereqs (<span class="org-constant">:prereqs</span> course)
        reqstr (<span class="org-builtin">if</span> prereqs (clojure.string/<span class="org-type">join</span> <span class="org-string">", "</span> prereqs) <span class="org-string">"None"</span>)]
    (<span class="org-variable-name">format</span> <span class="org-string">"%s %s (%d hrs)\n%s %s-%s %s %s\nPrereqs: %s"</span>
      course-id (<span class="org-constant">:name</span> course) (<span class="org-constant">:hours</span> course) 
      (<span class="org-constant">:days</span> offering) (<span class="org-constant">:start-time</span> offering) (<span class="org-constant">:end-time</span> offering)
      (<span class="org-constant">:first</span> faculty) (<span class="org-constant">:last</span> faculty)
      reqstr)))

<span class="org-comment-delimiter">;; </span><span class="org-comment">or a version relying on destructuring:</span>

(<span class="org-keyword">defn</span> <span class="org-function-name">offer-&gt;str</span> [catalog offer-id]
  (<span class="org-builtin">let</span> [{<span class="org-constant">:keys</span> [course teacher days start-time end-time]}
        (<span class="org-variable-name">get-in</span> catalog [<span class="org-constant">:offerings</span> offer-id])

        {<span class="org-constant">:keys</span> [name hours prereqs]}
        (<span class="org-variable-name">get-in</span> catalog [<span class="org-constant">:courses</span> course])

        {<span class="org-constant">:keys</span> [first last]}
        (<span class="org-variable-name">get-in</span> catalog [<span class="org-constant">:faculty</span> teacher])

        reqstr 
        (<span class="org-builtin">if</span> prereqs (clojure.string/<span class="org-type">join</span> <span class="org-string">", "</span> prereqs) <span class="org-string">"None"</span>)]

    (<span class="org-variable-name">format</span> <span class="org-string">"%s %s (%d hrs)\n%s %s-%s %s %s\nPrereqs: %s"</span>
      course name hours days start-time end-time first last reqstr)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline309" class="outline-5">
<h5 id="orgheadline309">Bonus: Faculty course load</h5>
<div class="outline-text-5" id="text-orgheadline309">
<p>
Note: This question and the next are best completed with sequence
functions like <code>map</code>, <code>filter</code>, and <code>reduce</code> which we will learn more
about in Sequences.
</p>

<p>
Write a function <code>faculty-hours</code> that takes a catalog and a
faculty-id and produces a count of the total course credit hours the
faculty member is teaching this semester. Example:
</p>

<div class="org-src-container">

<pre class="src src-clojure">user&gt; (faculty-hours catalog 138138)
5
</pre>
</div>
</div>

<div id="outline-container-orgheadline310" class="outline-6">
<h6 id="orgheadline310">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline310">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">faculty-hours</span> [catalog faculty-id]
  (<span class="org-variable-name">reduce</span> + 0
    (<span class="org-variable-name">map</span> #(<span class="org-constant">:hours</span> (<span class="org-variable-name">get-in</span> catalog [<span class="org-constant">:courses</span> (<span class="org-constant">:course</span> %)]))
      (<span class="org-variable-name">filter</span> #(<span class="org-variable-name">=</span> faculty-id (<span class="org-constant">:teacher</span> %))
        (<span class="org-variable-name">vals</span> (<span class="org-constant">:offerings</span> catalog))))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline311" class="outline-5">
<h5 id="orgheadline311">Bonus: Faculty course load report</h5>
<div class="outline-text-5" id="text-orgheadline311">
<p>
Write a function using <code>faculty-hours</code> that reports the total number
of credit hours per faculty member for all faculty members as a map
from faculty-id to hours. For example:
</p>

<div class="org-src-container">

<pre class="src src-clojure">user&gt; (faculty-load catalog)
{234232 0, 293843 3, 138138 5}
</pre>
</div>
</div>

<div id="outline-container-orgheadline312" class="outline-6">
<h6 id="orgheadline312">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline312">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">faculty-load</span> [catalog]
  (<span class="org-builtin">let</span> [ids (<span class="org-variable-name">keys</span> (<span class="org-constant">:faculty</span> catalog))]
    (<span class="org-variable-name">zipmap</span> ids 
            (<span class="org-variable-name">map</span> #(faculty-hours catalog %) ids))))
</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline314" class="outline-3">
<h3 id="orgheadline314">Sequences&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-orgheadline314">
</div>

<div id="outline-container-orgheadline318" class="outline-4">
<h4 id="orgheadline318">Sequences Overview&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline318">
</div><div id="outline-container-orgheadline315" class="outline-5">
<h5 id="orgheadline315">Not Really a Data Structure&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline315">
<p>
But it <b>looks</b> like a list when you print it.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">range</span> 5)
</pre>
</div>

<pre class="example">
;;=&gt; (0 1 2 3 4)
</pre>

<p>
A list <b>is</b> a sequence (but a sequence is not necessarily a list).
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">seq?</span> (<span class="org-variable-name">list</span> <span class="org-constant">:a</span> <span class="org-constant">:b</span> <span class="org-constant">:c</span>))
</pre>
</div>

<pre class="example">
;;=&gt; true
</pre>
</div>
</div>

<div id="outline-container-orgheadline316" class="outline-5">
<h5 id="orgheadline316">A Sequence is a Source of Values&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline316">
<ul class="org-ul">
<li>In some order
<ul class="org-ul">
<li>Vector or list: same as collection order</li>
<li>Map or set: arbitrary, but consistent</li>
<li>Sorted map or set: in sort order</li>
</ul></li>
<li>Sort of like Java <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html">Iterator</a> or Ruby <a href="http://www.ruby-doc.org/core-2.1.1/Enumerator.html">Enumerator</a></li>
<li>May be <b>lazy</b></li>
</ul>
</div>
</div>


<div id="outline-container-orgheadline317" class="outline-5">
<h5 id="orgheadline317">Partial Computation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline317">
<ul class="org-ul">
<li>Most sequence functions return another sequence</li>
<li>Each sequence represents one step in the "job"</li>
<li>Compose a "stack" of lazy sequence operations</li>
<li>Consume the result non-lazily</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline324" class="outline-4">
<h4 id="orgheadline324">The Sequence Library: Generating&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline324">
</div><div id="outline-container-orgheadline319" class="outline-5">
<h5 id="orgheadline319">Generating a Sequence of Numbers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline319">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">range</span> 10)
</pre>
</div>

<pre class="example">
;;=&gt; (0 1 2 3 4 5 6 7 8 9)
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">range</span> 40 45)
</pre>
</div>

<pre class="example">
;;=&gt; (40 41 42 43 44)
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">range</span>)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; (0 1 2 3 4 ;... forever</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline320" class="outline-5">
<h5 id="orgheadline320">Sequence from Data Structure&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline320">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">seq</span> [1 2 3])
</pre>
</div>

<pre class="example">
;;=&gt; (1 2 3)
</pre>

<ul class="org-ul">
<li><code>seq</code> gets a sequence from any data structure</li>
<li>Also strings, Java arrays, and Iterable</li>
<li>Every sequence function calls <code>seq</code> for you</li>
<li>You rarely need to call <code>seq</code>, except to check for empty collection</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline321" class="outline-5">
<h5 id="orgheadline321"><code>seq</code> to Check for Empty&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline321">
<ul class="org-ul">
<li><code>seq</code> on empty collection returns <code>nil</code></li>
<li><code>nil</code> is logical false</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">if</span> (<span class="org-variable-name">seq</span> <span class="org-string">""</span>)
  <span class="org-constant">:not-empty</span>
  <span class="org-constant">:empty</span>)
</pre>
</div>

<pre class="example">
;;=&gt; :empty
</pre>
</div>
</div>

<div id="outline-container-orgheadline322" class="outline-5">
<h5 id="orgheadline322">Sequence from String&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline322">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">seq</span> <span class="org-string">"Hello, World!"</span>)
</pre>
</div>

<pre class="example">
;;=&gt; (\H \e \l \l \o \, \space \W \o \r \l \d \!)
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">remove</span> #{\a \e \i \o \u} <span class="org-string">"Hello, World!"</span>)
</pre>
</div>

<pre class="example">
;;=&gt; (\H \l \l \, \space \W \r \l \d \!)
</pre>
</div>
</div>

<div id="outline-container-orgheadline323" class="outline-5">
<h5 id="orgheadline323">More Sequences&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline323">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">file-seq</td>
<td class="org-left">Files in directory</td>
</tr>

<tr>
<td class="org-left">line-seq</td>
<td class="org-left">Lines from java.io.BufferedReader</td>
</tr>

<tr>
<td class="org-left">re-seq</td>
<td class="org-left">Regex matches</td>
</tr>

<tr>
<td class="org-left">tree-seq</td>
<td class="org-left">Generic tree walker</td>
</tr>

<tr>
<td class="org-left">resultset-seq</td>
<td class="org-left">SQL query results</td>
</tr>

<tr>
<td class="org-left">xml-seq</td>
<td class="org-left">XML document nodes</td>
</tr>

<tr>
<td class="org-left">enumeration-seq</td>
<td class="org-left">Java Enumeration</td>
</tr>

<tr>
<td class="org-left">iterator-seq</td>
<td class="org-left">Java Iterator</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-orgheadline341" class="outline-4">
<h4 id="orgheadline341">The Sequence Library: Operations&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline341">
</div><div id="outline-container-orgheadline325" class="outline-5">
<h5 id="orgheadline325">Iterating Over a Sequence&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline325">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">map</span> (<span class="org-variable-name">fn</span> [n] (<span class="org-variable-name">long</span> (<span class="org-preprocessor">Math/pow</span> 2 n)))
     (<span class="org-variable-name">range</span> 9))
</pre>
</div>

<pre class="example">
;;=&gt; (1 2 4 8 16 32 64 128 256)
</pre>
</div>
</div>

<div id="outline-container-orgheadline326" class="outline-5">
<h5 id="orgheadline326">Iterating Over Many Sequences&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline326">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">map</span> +
     [100 200 300 400 500]
     (<span class="org-variable-name">range</span> 1 999)
     [10 20 30])
</pre>
</div>

<pre class="example">
;;=&gt; (111 222 333)
</pre>

<p>
Note: stops at end of <b>shortest</b> sequence.
</p>
</div>
</div>

<div id="outline-container-orgheadline327" class="outline-5">
<h5 id="orgheadline327">Iterating with <code>for</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline327">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">for</span> [n (<span class="org-variable-name">range</span> 9)]
  (<span class="org-variable-name">long</span> (<span class="org-preprocessor">Math/pow</span> 2 n)))
</pre>
</div>

<pre class="example">
;;=&gt; (1 2 4 8 16 32 64 128 256)
</pre>

<p>
Note: Not an imperative for-loop; lazy like <code>map</code>.
</p>
</div>
</div>

<div id="outline-container-orgheadline328" class="outline-5">
<h5 id="orgheadline328">Nested Iteration with <code>for</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline328">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">for</span> [k [<span class="org-constant">:a</span> <span class="org-constant">:b</span>]
      n (<span class="org-variable-name">range</span> 1 4)]
  [k n])
</pre>
</div>

<pre class="example">
;;=&gt; ([:a 1] [:a 2] [:a 3] [:b 1] [:b 2] [:b 3])
</pre>

<p>
Note: different from <code>map</code> with multiple sequences.
</p>
</div>
</div>

<div id="outline-container-orgheadline329" class="outline-5">
<h5 id="orgheadline329">Shortening Sequences&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline329">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">take</span> 3 (<span class="org-variable-name">range</span>)) <span class="org-comment">;=&gt; (0 1 2)</span>

(<span class="org-variable-name">drop</span> 3 (<span class="org-variable-name">range</span>)) <span class="org-comment">;=&gt; (3 4 5 ... infinite</span>

(<span class="org-variable-name">take-while</span> #(<span class="org-variable-name">&lt;</span> % 5) (<span class="org-variable-name">range</span>)) <span class="org-comment">;=&gt; (0 1 2 3 4)</span>

(<span class="org-variable-name">drop-while</span> #(<span class="org-variable-name">&lt;</span> % 5) (<span class="org-variable-name">range</span>)) <span class="org-comment">;=&gt; (5 6 7 8 ... infinite</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline330" class="outline-5">
<h5 id="orgheadline330">Taking Out Items&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline330">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">filter</span> even? (<span class="org-variable-name">range</span> 10))
</pre>
</div>

<pre class="example">
;;=&gt; (0 2 4 6 8)
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">remove</span> even? (<span class="org-variable-name">range</span> 10))
</pre>
</div>

<pre class="example">
;;=&gt; (1 3 5 7 9)
</pre>
</div>
</div>

<div id="outline-container-orgheadline331" class="outline-5">
<h5 id="orgheadline331">Grouping Elements of a Sequence&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline331">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">partition</span> 3 (<span class="org-variable-name">range</span> 10))
</pre>
</div>

<pre class="example">
;;=&gt; ((0 1 2) (3 4 5) (6 7 8))
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(partition-all 3 (<span class="org-variable-name">range</span> 10))
</pre>
</div>

<pre class="example">
;;=&gt; ((0 1 2) (3 4 5) (6 7 8) (9))
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(group-by (<span class="org-variable-name">fn</span> [n] (<span class="org-builtin">if</span> (<span class="org-variable-name">even?</span> n) <span class="org-constant">:even</span> <span class="org-constant">:odd</span>))
          (<span class="org-variable-name">range</span> 10))
</pre>
</div>

<pre class="example">
;;=&gt; {:even [0 2 4 6 8], :odd [1 3 5 7 9]}
</pre>
</div>
</div>

<div id="outline-container-orgheadline337" class="outline-5">
<h5 id="orgheadline337">Re-Ordering a Sequence&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline337">
</div><div id="outline-container-orgheadline332" class="outline-6">
<h6 id="orgheadline332"><code>sort</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline332">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">sort</span> '(10 37 3 10 44 6))
</pre>
</div>

<pre class="example">
;;=&gt; (3 6 10 10 37 44)
</pre>

<p>
Note: <code>sort</code> is not lazy.
</p>
</div>
</div>

<div id="outline-container-orgheadline333" class="outline-6">
<h6 id="orgheadline333"><code>sort</code> with Comparator&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline333">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">sort</span> (<span class="org-variable-name">fn</span> [x y] (<span class="org-variable-name">-</span> (<span class="org-variable-name">compare</span> x y))) '(10 37 3 10 44 6))
</pre>
</div>

<pre class="example">
;;=&gt; (44 37 10 10 6 3)
</pre>
</div>
</div>

<div id="outline-container-orgheadline334" class="outline-6">
<h6 id="orgheadline334"><code>sort-by</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline334">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">Note: not a comparator</span>
(<span class="org-variable-name">sort-by</span> <span class="org-constant">:name</span> [{<span class="org-constant">:name</span> <span class="org-string">"Bob"</span> <span class="org-constant">:age</span> 33}
                {<span class="org-constant">:name</span> <span class="org-string">"Ali"</span> <span class="org-constant">:age</span> 39}
                {<span class="org-constant">:name</span> <span class="org-string">"Mel"</span> <span class="org-constant">:age</span> 22}
                {<span class="org-constant">:name</span> <span class="org-string">"Jim"</span> <span class="org-constant">:age</span> 58}])
</pre>
</div>

<pre class="example">
;;=&gt; ({:age 39, :name "Ali"} {:age 33, :name "Bob"} {:age 58, :name "Jim"} {:age 22, :name "Mel"})
</pre>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">Note: not a comparator</span>
(<span class="org-variable-name">sort-by</span> <span class="org-constant">:age</span> [{<span class="org-constant">:name</span> <span class="org-string">"Bob"</span> <span class="org-constant">:age</span> 33}
               {<span class="org-constant">:name</span> <span class="org-string">"Ali"</span> <span class="org-constant">:age</span> 39}
               {<span class="org-constant">:name</span> <span class="org-string">"Mel"</span> <span class="org-constant">:age</span> 22}
               {<span class="org-constant">:name</span> <span class="org-string">"Jim"</span> <span class="org-constant">:age</span> 58}])
</pre>
</div>

<pre class="example">
;;=&gt; ({:age 22, :name "Mel"} {:age 33, :name "Bob"} {:age 39, :name "Ali"} {:age 58, :name "Jim"})
</pre>
</div>
</div>

<div id="outline-container-orgheadline335" class="outline-6">
<h6 id="orgheadline335"><code>shuffle</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline335">
<div class="org-src-container">

<pre class="src src-clojure">(shuffle (<span class="org-variable-name">range</span> 10))
</pre>
</div>

<pre class="example">
;;=&gt; [9 3 4 2 6 1 0 5 8 7]
</pre>

<p>
Note: <code>shuffle</code> returns a vector, is not lazy.
</p>
</div>
</div>

<div id="outline-container-orgheadline336" class="outline-6">
<h6 id="orgheadline336"><code>reverse</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline336">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">reverse</span> (<span class="org-variable-name">range</span> 10))
</pre>
</div>

<pre class="example">
;;=&gt; (9 8 7 6 5 4 3 2 1 0)
</pre>

<p>
Note: <code>reverse</code> is not lazy.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline338" class="outline-5">
<h5 id="orgheadline338">Flattening Sequences&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline338">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">mapcat</span> (<span class="org-variable-name">fn</span> [i] (<span class="org-variable-name">range</span> i)) (<span class="org-variable-name">range</span> 7))
</pre>
</div>

<pre class="example">
;;=&gt; (0 0 1 0 1 2 0 1 2 3 0 1 2 3 4 0 1 2 3 4 5)
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">flatten</span> '(1 1 (2 3) (5 8 (13 21))))
</pre>
</div>

<pre class="example">
;;=&gt; (1 1 2 3 5 8 13 21)
</pre>

<p>
Note: <code>flatten</code> is usually a sign of poorly-constructed sequences.
Prefer <code>mapcat</code> where possible.
</p>
</div>
</div>

<div id="outline-container-orgheadline339" class="outline-5">
<h5 id="orgheadline339">Combining Sequences&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline339">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">concat</span> [<span class="org-constant">:a</span> <span class="org-constant">:b</span> <span class="org-constant">:c</span>] (<span class="org-variable-name">range</span> 5))
</pre>
</div>

<pre class="example">
;;=&gt; (:a :b :c 0 1 2 3 4)
</pre>

<p>
Note: Beware lazy "stacks".
</p>
</div>
</div>

<div id="outline-container-orgheadline340" class="outline-5">
<h5 id="orgheadline340">Utility Sequences&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline340">
<p>
Typically used in combination with <code>map</code> or <code>reduce</code>.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">repeat</span> <span class="org-constant">:b</span>)     <span class="org-comment">;=&gt; (:b :b :b ... infinite</span>

(<span class="org-variable-name">repeatedly</span> #(<span class="org-variable-name">rand-int</span> 100))   <span class="org-comment">;=&gt; (89 58 73 ... infinite</span>

(<span class="org-variable-name">cycle</span> [<span class="org-constant">:a</span> <span class="org-constant">:b</span> <span class="org-constant">:c</span>])  <span class="org-comment">;=&gt; (:a :b :c :a :b :c :a ... infinite</span>

(<span class="org-variable-name">interpose</span> \, <span class="org-string">"abc"</span>)  <span class="org-comment">;=&gt; (\a \, \b \, \c)</span>
(<span class="org-variable-name">apply</span> str *1)  <span class="org-comment">;=&gt; "a,b,c"</span>

(<span class="org-variable-name">interleave</span> [1 2 3] [<span class="org-constant">:a</span> <span class="org-constant">:b</span> <span class="org-constant">:c</span>])  <span class="org-comment">;=&gt; (1 :a 2 :b 3 :c)</span>

(<span class="org-variable-name">iterate</span> #(<span class="org-variable-name">*</span> 2 %) 2)  <span class="org-comment">;=&gt; (2 4 8 16 ... infinite</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline350" class="outline-4">
<h4 id="orgheadline350">The Sequence Library: Results&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline350">
</div><div id="outline-container-orgheadline342" class="outline-5">
<h5 id="orgheadline342">Collecting Result of a Sequence&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline342">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">vec</span> (<span class="org-variable-name">filter</span> even? (<span class="org-variable-name">range</span> 10)))
</pre>
</div>

<pre class="example">
;;=&gt; [0 2 4 6 8]
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">set</span> (<span class="org-variable-name">map</span> inc (<span class="org-variable-name">range</span> 10)))
</pre>
</div>

<pre class="example">
;;=&gt; #{1 2 3 4 5 6 7 8 9 10}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">apply</span> hash-map (<span class="org-variable-name">range</span> 10))
</pre>
</div>

<pre class="example">
;;=&gt; {0 1, 2 3, 4 5, 6 7, 8 9}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">apply</span> str (<span class="org-variable-name">interpose</span> \, (<span class="org-variable-name">range</span> 4)))
</pre>
</div>

<pre class="example">
;;=&gt; "0,1,2,3"
</pre>
</div>
</div>

<div id="outline-container-orgheadline343" class="outline-5">
<h5 id="orgheadline343">Seqs <code>into</code> Collections&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline343">
<ul class="org-ul">
<li><code>(into <i style="font-family:serif">coll</i> <i style="font-family:serif">seq</i>)</code></li>
<li>Adds elements of <i>seq</i> to <i>coll</i> using <code>conj</code></li>
<li>"Pours" <i>seq</i> into <i>coll</i></li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">into</span> #{} <span class="org-string">"hello"</span>)        <span class="org-comment">;=&gt; #{\e \h \l \o}</span>

(<span class="org-variable-name">into</span> {} [[<span class="org-constant">:x</span> 1] [<span class="org-constant">:y</span> 2]]) <span class="org-comment">;=&gt; {:x 1, :y 2}</span>

(<span class="org-variable-name">into</span> () [<span class="org-constant">:a</span> <span class="org-constant">:b</span> <span class="org-constant">:c</span>])      <span class="org-comment">;=&gt; (:c :b :a)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline344" class="outline-5">
<h5 id="orgheadline344">Consuming a Sequence for Side Effects&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline344">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">doseq</span> [i (<span class="org-variable-name">range</span> 5)]
  (<span class="org-variable-name">prn</span> i))
</pre>
</div>

<pre class="example">
;; 0
;; 1
;; 2
;; 3
;; 4
;;=&gt; nil
</pre>

<p>
Note: <code>doseq</code> always returns <code>nil</code>
</p>
</div>
</div>

<div id="outline-container-orgheadline345" class="outline-5">
<h5 id="orgheadline345"><code>doseq</code> Over Many Sequences&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline345">
<p>
Creates nested iteration like <code>for</code>.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">doseq</span> [c [<span class="org-constant">:a</span> <span class="org-constant">:b</span>]
        i (<span class="org-variable-name">range</span> 3)]
  (<span class="org-variable-name">prn</span> c i))
</pre>
</div>

<pre class="example">
;; :a 0
;; :a 1
;; :a 2
;; :b 0
;; :b 1
;; :b 2
;;=&gt; nil
</pre>
</div>
</div>

<div id="outline-container-orgheadline346" class="outline-5">
<h5 id="orgheadline346"><code>reduce</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline346">
<ul class="org-ul">
<li><code>(reduce <i style="font-family:serif">function</i> <i style="font-family:serif">init</i> <i style="font-family:serif">seq</i>)</code></li>
<li><i>function</i> takes two arguments
<ul class="org-ul">
<li><code>reduce</code> calls <code>(<i style="font-family:serif">function</i> <i style="font-family:serif">init</i> (first <i style="font-family:serif">seq</i>))</code></li>
<li>Return value becomes <i>init</i> for the next step</li>
</ul></li>
<li>Repeat until the end of the seq, return last init</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">reduce</span> (<span class="org-variable-name">fn</span> [total item] (<span class="org-variable-name">+</span> total (<span class="org-variable-name">*</span> 10 item)))
        0  <span class="org-comment">; init</span>
        [1 2 3 4])  <span class="org-comment">;=&gt; 100</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline347" class="outline-5">
<h5 id="orgheadline347"><code>reduce</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline347">
<ul class="org-ul">
<li>With no <i>init</i>, uses first element of seq</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">reduce</span> + [1 1 2 3 5])  <span class="org-comment">;=&gt; 12</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline348" class="outline-5">
<h5 id="orgheadline348"><code>some</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline348">
<ul class="org-ul">
<li><code>(some <i style="font-family:serif">function</i> <i style="font-family:serif">seq</i>)</code></li>
<li>Maps <i>function</i> over the seq</li>
<li>Returns <i>first</i> logical true value of function</li>
<li>Or <code>nil</code> if nothing true</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">some</span> #(zero? (<span class="org-variable-name">rem</span> % 5)) [9 22 35 76])  <span class="org-comment">;=&gt; true</span>

(<span class="org-variable-name">some</span> #(<span class="org-variable-name">=</span> 4 %) [1 3 5])  <span class="org-comment">;=&gt; nil</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline349" class="outline-5">
<h5 id="orgheadline349"><code>some</code> with a Set&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline349">
<ul class="org-ul">
<li>Sets are functions</li>
<li>Can be used as linear search</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">some</span> #{<span class="org-constant">:b</span>} [<span class="org-constant">:a</span> <span class="org-constant">:b</span> <span class="org-constant">:c</span>])    <span class="org-comment">;=&gt; :b</span>

(<span class="org-variable-name">some</span> #{<span class="org-constant">:foo</span>} [<span class="org-constant">:a</span> <span class="org-constant">:b</span> <span class="org-constant">:c</span>])  <span class="org-comment">;=&gt; nil</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline351" class="outline-4">
<h4 id="orgheadline351">Laziness&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline351">
<ul class="org-ul">
<li>Sequences can be <b>lazy</b></li>
<li>Compute results as needed</li>
<li>Only compute value once, then cached</li>
<li>Can be infinite!</li>
<li>Most Clojure functions which return sequences are lazy</li>
</ul>
</div>

<div id="outline-container-orgheadline352" class="outline-5">
<h5 id="orgheadline352">Don't Mix Side Effects and Laziness&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline352">
<p>
<b>Chunked sequences</b> lead to confusing results.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">take</span> 4 (<span class="org-variable-name">map</span> println (<span class="org-variable-name">range</span> 100)))
</pre>
</div>

<pre class="example">
;;=&gt; (0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
nil nil nil nil)
</pre>
</div>
</div>

<div id="outline-container-orgheadline353" class="outline-5">
<h5 id="orgheadline353">Use Side Effects at the End&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline353">
<ul class="org-ul">
<li>Usually <code>doseq</code></li>
<li>Sometimes <code>reduce</code></li>
<li>Rarely <code>doall</code> or <code>dorun</code>
<ul class="org-ul">
<li>"Force" complete evaluation of lazy seq</li>
<li>Sequence must be finite!</li>
<li><code>doall</code> returns entire sequence (must fit in memory!)</li>
<li><code>dorun</code> returns <code>nil</code></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline354" class="outline-5">
<h5 id="orgheadline354">Beware Lazy Stacks&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline354">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">build-sequence</span> [n]
  (<span class="org-variable-name">reduce</span> (<span class="org-variable-name">fn</span> [sequence i]
            (<span class="org-variable-name">concat</span> sequence (<span class="org-variable-name">range</span> i)))
          nil
          (<span class="org-variable-name">range</span> 1 (<span class="org-variable-name">inc</span> n))))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-clojure">(build-sequence 6)
</pre>
</div>

<pre class="example">
;;=&gt; (0 0 1 0 1 2 0 1 2 3 0 1 2 3 4 0 1 2 3 4 5)
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">first</span> (build-sequence 4000))
</pre>
</div>

<pre class="example">
;; StackOverflowError   clojure.lang.LazySeq.sval (LazySeq.java:42)
</pre>
</div>
</div>

<div id="outline-container-orgheadline355" class="outline-5">
<h5 id="orgheadline355">Non-Lazy Alternative&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline355">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">build-vector</span> [n]
  (<span class="org-variable-name">reduce</span> (<span class="org-variable-name">fn</span> [v i]
            (<span class="org-variable-name">into</span> v (<span class="org-variable-name">range</span> i)))
          []
          (<span class="org-variable-name">range</span> 1 (<span class="org-variable-name">inc</span> n))))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">take</span> 10 (build-vector 4000))
<span class="org-comment-delimiter">;; </span><span class="org-comment">Takes a while...</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; (0 0 1 0 1 2 0 1 2 3)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline356" class="outline-5">
<h5 id="orgheadline356">Non-Lazy Alternatives&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline356">
<p>
Many lazy sequence operations have non-lazy equivalents that return
vectors.
</p>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">Return Lazy Seq    ;; Return Vector</span>
map                   mapv
filter                filterv
concat                into []


<span class="org-comment-delimiter">;; </span><span class="org-comment">O(n) on a seq      ;; O(1) on a vector</span>
last                  peek
butlast               pop
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline377" class="outline-4">
<h4 id="orgheadline377">Sequence Theory&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline377">
</div><div id="outline-container-orgheadline357" class="outline-5">
<h5 id="orgheadline357">Sequence API&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline357">
<ul class="org-ul">
<li><code>(seq coll)</code>
<ul class="org-ul">
<li>If collection is not empty, return seq object on it</li>
<li>If collection is empty, return <code>nil</code></li>
</ul></li>
<li><code>(first coll)</code> returns the first element</li>
<li><code>(rest coll)</code> returns a sequence of the rest of the elements
<ul class="org-ul">
<li>Might be empty, but not <code>nil</code></li>
</ul></li>
<li><code>(next coll)</code> is same as <code>(seq (rest coll))</code></li>
<li><code>(cons x coll)</code> returns a new sequence: first is x, rest is coll</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline358" class="outline-5">
<h5 id="orgheadline358">Sequences Over Structures&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline358">
<ul class="org-ul">
<li>Can treat any Clojure data structure as a seq
<ul class="org-ul">
<li>Lists actually <i>are</i> seqs</li>
<li>Associative structures treated as sequence of pairs</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline359" class="outline-5">
<h5 id="orgheadline359">List as a Seq&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline359">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">x</span> '(1 2 3))  <span class="org-comment">; x is a list</span>
</pre>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="slide-assets/collections-seq-list-initial.svg" >
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline360" class="outline-5">
<h5 id="orgheadline360">List as a Seq&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline360">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">a</span> (<span class="org-variable-name">first</span> x))   <span class="org-comment">; a is 1</span>
</pre>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="slide-assets/collections-seq-list-first.svg" >
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline361" class="outline-5">
<h5 id="orgheadline361">List as a Seq&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline361">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">s</span> (<span class="org-variable-name">rest</span> x))   <span class="org-comment">; s is a seq</span>
</pre>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="slide-assets/collections-seq-list-rest.svg" >
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline362" class="outline-5">
<h5 id="orgheadline362">List as a Seq&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline362">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">b</span> (<span class="org-variable-name">first</span> (<span class="org-variable-name">rest</span> x))   <span class="org-comment">; b is 2</span>
(<span class="org-keyword">def</span> <span class="org-function-name">b</span> (<span class="org-variable-name">second</span> x))        <span class="org-comment">; same thing</span>
</pre>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="slide-assets/collections-seq-list-second.svg" >
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline363" class="outline-5">
<h5 id="orgheadline363">Seq Over Vector&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline363">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">v</span> [1 2 3]))  <span class="org-comment">; v is a vector</span>
</pre>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="slide-assets/collections-seq-vector-initial.svg" >
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline364" class="outline-5">
<h5 id="orgheadline364">Seq Over Vector&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline364">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">s1</span> (<span class="org-variable-name">seq</span> v))   <span class="org-comment">; s1 is a seq</span>
</pre>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="slide-assets/collections-seq-vector-seq.svg" >
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline365" class="outline-5">
<h5 id="orgheadline365">Seq Over Vector&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline365">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">a</span> (<span class="org-variable-name">first</span> v))   <span class="org-comment">; a is 1</span>
</pre>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="slide-assets/collections-seq-vector-first.svg" >
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline366" class="outline-5">
<h5 id="orgheadline366">Seq Over Vector&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline366">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">s2</span> (<span class="org-variable-name">rest</span> v))   <span class="org-comment">; s2 is a seq</span>
</pre>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="slide-assets/collections-seq-vector-rest.svg" >
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline367" class="outline-5">
<h5 id="orgheadline367">Seq Over Vector&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline367">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">b</span> (<span class="org-variable-name">first</span> (<span class="org-variable-name">rest</span> v))  <span class="org-comment">; b is 2</span>
(<span class="org-keyword">def</span> <span class="org-function-name">b</span> (<span class="org-variable-name">second</span> v))       <span class="org-comment">; same thing</span>
</pre>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="slide-assets/collections-seq-vector-second.svg" >
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline368" class="outline-5">
<h5 id="orgheadline368">Sequences Over Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline368">
<ul class="org-ul">
<li>Can map a generator function to a seq</li>
<li>Seq is lazy, can be infinite
<ul class="org-ul">
<li>Can process more than fits in memory</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline369" class="outline-5">
<h5 id="orgheadline369">Sequences Over Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline369">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">r</span> (<span class="org-variable-name">range</span> 1 100))   <span class="org-comment">; r is a lazy seq</span>
</pre>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="slide-assets/collections-seq-lazy-initial.svg" >
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline370" class="outline-5">
<h5 id="orgheadline370">Sequences Over Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline370">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">a</span> (<span class="org-variable-name">first</span> r))  <span class="org-comment">; a is 1</span>
</pre>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="slide-assets/collections-seq-lazy-first.svg" >
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline371" class="outline-5">
<h5 id="orgheadline371">Sequences Over Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline371">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">s</span> (<span class="org-variable-name">rest</span> r))    <span class="org-comment">; s is a lazy seq</span>
</pre>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="slide-assets/collections-seq-lazy-rest.svg" >
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline372" class="outline-5">
<h5 id="orgheadline372">Sequences Over Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline372">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">b</span> (<span class="org-variable-name">first</span> (<span class="org-variable-name">rest</span> r))  <span class="org-comment">; b is 2</span>
(<span class="org-keyword">def</span> <span class="org-function-name">b</span> (<span class="org-variable-name">second</span> r))       <span class="org-comment">; same thing</span>
</pre>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="slide-assets/collections-seq-lazy-second.svg" >
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline373" class="outline-5">
<h5 id="orgheadline373">Sequences Over Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline373">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">c</span> (<span class="org-variable-name">first</span> (<span class="org-variable-name">rest</span> (<span class="org-variable-name">rest</span> r))))  <span class="org-comment">; c is 3</span>
(<span class="org-keyword">def</span> <span class="org-function-name">c</span> (<span class="org-variable-name">nth</span> r 2))                <span class="org-comment">; same thing</span>
</pre>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="slide-assets/collections-seq-lazy-third.svg" >
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline374" class="outline-5">
<h5 id="orgheadline374">Sequences and GC&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline374">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">count</span> (<span class="org-variable-name">range</span> 10000000))  <span class="org-comment">;=&gt; 10000000</span>
</pre>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="slide-assets/collections-seq-lazy-GC-safe.svg" >
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline375" class="outline-5">
<h5 id="orgheadline375">Holding on to the Head&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline375">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">r</span> (<span class="org-variable-name">range</span> 10000000)) 
(<span class="org-variable-name">count</span> r)  <span class="org-comment">; out of memory error</span>
</pre>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="slide-assets/collections-seq-lazy-GC-unsafe.svg" >
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline376" class="outline-5">
<h5 id="orgheadline376">Sequences in the REPL&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline376">
<ul class="org-ul">
<li>REPL always prints sequences with parens
<ul class="org-ul">
<li>But it's not a list!</li>
</ul></li>
<li>Infinite sequences take a long time to print</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(set! *print-length* 10) <span class="org-comment">; only print 10 things</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline378" class="outline-4">
<h4 id="orgheadline378">Generating a Raw Sequence&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline378">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">pseudocode</span>
(<span class="org-keyword">defn</span> <span class="org-function-name">generate-seq</span> [input-source]
  (<span class="org-variable-name">lazy-seq</span>   <span class="org-comment">; macro creates lazy seq of body</span>
   (<span class="org-builtin">when</span> (more-available? input-source)   <span class="org-comment">; termination check</span>
     (<span class="org-variable-name">cons</span> (get-next-item input-source)   <span class="org-comment">; construct "next" seq</span>
           (generate-seq input-source)))))  <span class="org-comment">; recursive call (not recur)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline384" class="outline-4">
<h4 id="orgheadline384">Combining Sequence Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline384">
</div><div id="outline-container-orgheadline379" class="outline-5">
<h5 id="orgheadline379">Sequence Power&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline379">
<ul class="org-ul">
<li>Generators
<ul class="org-ul">
<li>list, vector, map, SQL ResultSet, Stream, Directory, Iterator, XML, &#x2026;</li>
</ul></li>
<li>Operations
<ul class="org-ul">
<li>map, filter, reduce, count, some, replace, &#x2026;</li>
</ul></li>
<li>Generators * Operations = Power!</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline380" class="outline-5">
<h5 id="orgheadline380">Adopting the Sequence Mindset&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline380">
<ul class="org-ul">
<li>Sequence library surface space is big</li>
<li>Most things you want to do are in there somewhere</li>
<li>If you find yourself explicitly iterating, look for a function
<ul class="org-ul">
<li>The Clojure Cheatsheet helps</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline381" class="outline-5">
<h5 id="orgheadline381">Combining Sequence Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline381">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">Sum of the first 50 odd integers</span>
(<span class="org-variable-name">reduce</span> + (<span class="org-variable-name">take</span> 50 (<span class="org-variable-name">filter</span> odd? (<span class="org-variable-name">range</span>))))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 2500</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">Frequency of vowels in the docstring of 'ns'</span>
(frequencies (<span class="org-variable-name">re-seq</span> #<span class="org-string">"[aeiou]"</span> (<span class="org-constant">:doc</span> (<span class="org-variable-name">meta</span> #'ns))))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; {"e" 109, "o" 48, "a" 49, "u" 32, "i" 49}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline382" class="outline-5">
<h5 id="orgheadline382">Thread-last For Readability&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline382">
<ul class="org-ul">
<li>"Thread-last"</li>
<li>Invoke each step with the prior result as the last argument</li>

<li>Example:</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">-&gt;&gt;</span> (<span class="org-variable-name">range</span>) (<span class="org-variable-name">filter</span> odd?) (<span class="org-variable-name">take</span> 50) (<span class="org-variable-name">reduce</span> +))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline383" class="outline-5">
<h5 id="orgheadline383">The Fibonacci Sequence&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline383">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">fibs</span>            <span class="org-comment">; define a sequence called fibs...</span>
  (<span class="org-variable-name">map</span> first         <span class="org-comment">; that maps the first value of a pair across...</span>
    (<span class="org-variable-name">iterate</span>         <span class="org-comment">; a lazy, infinite sequence that's generated by...</span>
      (<span class="org-variable-name">fn</span> [[a b]]    <span class="org-comment">; a function that destructures a pair of args...</span>
        [b (<span class="org-variable-name">+</span> a b)]) <span class="org-comment">; and returns the next pair in the sequence...</span>
      [0 1])))       <span class="org-comment">; starting at [0 1]</span>

(<span class="org-variable-name">take</span> 5 fibs)        <span class="org-comment">; consume as many as you'd like</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; (0 1 1 2 3)</span>
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline385" class="outline-3">
<h3 id="orgheadline385">LAB: Sums and Ciphers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-orgheadline385">
</div>

<div id="outline-container-orgheadline386" class="outline-4">
<h4 id="orgheadline386">Fibonacci sum</h4>
<div class="outline-text-4" id="text-orgheadline386">
<p>
Clojure's <code>take</code> function is commonly used to work with limited portions of infinite sequences.
</p>

<p>
Given this infinite, lazy sequence of Fibonacci numbers:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">fibs</span>
  (<span class="org-variable-name">map</span> first
       (<span class="org-variable-name">iterate</span> (<span class="org-variable-name">fn</span> [[a b]] [b (<span class="org-variable-name">+</span> a b)])
                [0 1])))
</pre>
</div>

<p>
Find the sum of the first fifty Fibonacci numbers.
</p>
</div>

<div id="outline-container-orgheadline387" class="outline-5">
<h5 id="orgheadline387">Expected answer&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline387">
<p>
The expected answer is 20365011073.
</p>
</div>
</div>

<div id="outline-container-orgheadline388" class="outline-5">
<h5 id="orgheadline388">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline388">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">reduce</span> + (<span class="org-variable-name">take</span> 50 fibs))
</pre>
</div>

<pre class="example">
;;=&gt; 20365011073
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline389" class="outline-4">
<h4 id="orgheadline389">Reduce vs. apply</h4>
<div class="outline-text-4" id="text-orgheadline389">
<p>
The solution to the previous exercise can be written with <code>apply</code> instead of <code>reduce</code>. Why? 
</p>

<p>
For most uses of <code>reduce</code>, this is not the case. Why not?
</p>
</div>

<div id="outline-container-orgheadline390" class="outline-5">
<h5 id="orgheadline390">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline390">
<p>
<code>reduce</code> is designed to be used with functions that take exactly two arguments. The <code>+</code> function is somewhat unique in that it takes any number of arguments. For the non-trivial cases, it is implemented in terms of <code>reduce</code>:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">+</span>
  ([] 0)
  ([x] (<span class="org-variable-name">cast</span> <span class="org-preprocessor">Number</span> x))
  ([x y] (<span class="org-preprocessor">clojure.lang.Numbers/add</span> x y))
  ([x y &amp; more]
     (<span class="org-variable-name">reduce</span> + (<span class="org-variable-name">+</span> x y) more)))
</pre>
</div>

<p>
When you call <code>(apply + some-collection)</code> you are actually reducing over successive pairs of elements from the collection.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline391" class="outline-4">
<h4 id="orgheadline391">Prime sum</h4>
<div class="outline-text-4" id="text-orgheadline391">
<p>
The <code>take</code> and <code>drop</code> functions, as well as variants like <code>take-while</code> and <code>drop-while</code>, can be combined to select subsequences out of a larger sequence.
</p>

<p>
Given this infinite, lazy (and inefficient) sequence of prime numbers:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">primes</span>
  (<span class="org-builtin">letfn</span> [(next-prime [known-primes n]
            (<span class="org-variable-name">lazy-seq</span>
             (<span class="org-builtin">if</span> (<span class="org-variable-name">some</span> #(zero? (<span class="org-variable-name">rem</span> n %)) known-primes)
               (next-prime known-primes (<span class="org-variable-name">inc</span> n))
               (<span class="org-variable-name">cons</span> n (next-prime (<span class="org-variable-name">conj</span> known-primes n) (<span class="org-variable-name">inc</span> n))))))]
    (next-prime [] 2)))
</pre>
</div>

<p>
Find the sum of the first fifty primes over one hundred.
</p>
</div>

<div id="outline-container-orgheadline392" class="outline-5">
<h5 id="orgheadline392">Expected answer&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline392">
<p>
The expected answer is 11658.
</p>
</div>
</div>

<div id="outline-container-orgheadline393" class="outline-5">
<h5 id="orgheadline393">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline393">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">reduce</span> + (<span class="org-variable-name">take</span> 50 (<span class="org-variable-name">drop-while</span> #(<span class="org-variable-name">&lt;=</span> % 100) primes)))
</pre>
</div>

<pre class="example">
;;=&gt; 11658
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline394" class="outline-4">
<h4 id="orgheadline394">Ranges of letters</h4>
<div class="outline-text-4" id="text-orgheadline394">
<p>
Suppose we want to make a collection of all the capital letters, from <i>A</i> to <i>Z</i>. Clojure's <code>range</code> function only works on numbers, but we can convert between characters and numbers using the <code>char</code> and <code>int</code> functions.
</p>

<p>
Using those functions, plus <code>map</code> and <code>range</code>, define <code>letters</code> as a sequence of capital letters.
</p>
</div>

<div id="outline-container-orgheadline395" class="outline-5">
<h5 id="orgheadline395">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline395">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">letters</span> (<span class="org-variable-name">map</span> char (<span class="org-variable-name">range</span> (<span class="org-variable-name">int</span> \A) (<span class="org-variable-name">inc</span> (<span class="org-variable-name">int</span> \Z)))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline396" class="outline-4">
<h4 id="orgheadline396">Rotating a sequence</h4>
<div class="outline-text-4" id="text-orgheadline396">
<p>
In the next few exercises, we will implement the famous ROT-13 cipher, also known as the Caesar cipher.
</p>

<p>
ROT-13 works by "rotating" the alphabet 13 places to the left. So <i>A</i> becomes 
<i>N</i>, <i>B</i> becomes <i>O</i>, and so on.
</p>

<p>
Clojure's <code>cycle</code> function takes a sequential collection and returns the elements of that sequence repeated in an infinite cycle. For example:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">take</span> 10 (<span class="org-variable-name">cycle</span> [<span class="org-constant">:A</span> <span class="org-constant">:B</span> <span class="org-constant">:C</span>]))
</pre>
</div>

<pre class="example">
;;=&gt; (:A :B :C :A :B :C :A :B :C :A)
</pre>

<p>
Using <code>cycle</code>, rotate the alphabet 13 places to the left.
</p>
</div>

<div id="outline-container-orgheadline397" class="outline-5">
<h5 id="orgheadline397">Expected answer&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline397">
<div class="org-src-container">

<pre class="src src-clojure">: <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; (\N \O \P \Q \R \S \T \U \V \W \X \Y \Z \A \B \C \D \E \F \G \H \I \J \K \L \M)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline398" class="outline-5">
<h5 id="orgheadline398">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline398">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">take</span> 26 (<span class="org-variable-name">drop</span> 13 (<span class="org-variable-name">cycle</span> letters)))
</pre>
</div>

<pre class="example">
;;=&gt; (\N \O \P \Q \R \S \T \U \V \W \X \Y \Z \A \B \C \D \E \F \G \H \I \J \K \L \M)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline399" class="outline-4">
<h4 id="orgheadline399">Generic rotation</h4>
<div class="outline-text-4" id="text-orgheadline399">
<p>
Define a function which takes two arguments: a collection and a number <i>n</i>, and rotates the collection by <i>n</i> places.
</p>
</div>

<div id="outline-container-orgheadline400" class="outline-5">
<h5 id="orgheadline400">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline400">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">rotate</span> [coll n]
  (<span class="org-variable-name">take</span> (<span class="org-variable-name">count</span> coll) (<span class="org-variable-name">drop</span> n (<span class="org-variable-name">cycle</span> coll))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline401" class="outline-4">
<h4 id="orgheadline401">ROT-13 pairs</h4>
<div class="outline-text-4" id="text-orgheadline401">
<p>
Clojure's <code>map</code> function takes multiple collection arguments. Use this fact to create a sequence of pairs in the ROT-13 cipher, like <code>[\A \N]</code>.
</p>
</div>

<div id="outline-container-orgheadline402" class="outline-5">
<h5 id="orgheadline402">Expected answer&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline402">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; ([\A \N] [\B \O] [\C \P] [\D \Q] [\E \R] [\F \S] [\G \T] [\H \U] [\I \V] [\J \W] [\K \X] [\L \Y] [\M \Z] [\N \A] [\O \B] [\P \C] [\Q \D] [\R \E] [\S \F] [\T \G] [\U \H] [\V \I] [\W \J] [\X \K] [\Y \L] [\Z \M])</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline403" class="outline-5">
<h5 id="orgheadline403">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline403">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">map</span> vector letters (rotate letters 13))
</pre>
</div>

<pre class="example">
;;=&gt; ([\A \N] [\B \O] [\C \P] [\D \Q] [\E \R] [\F \S] [\G \T] [\H \U] [\I \V] [\J \W] [\K \X] [\L \Y] [\M \Z] [\N \A] [\O \B] [\P \C] [\Q \D] [\R \E] [\S \F] [\T \G] [\U \H] [\V \I] [\W \J] [\X \K] [\Y \L] [\Z \M])
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline404" class="outline-4">
<h4 id="orgheadline404">ROT-13 as a map</h4>
<div class="outline-text-4" id="text-orgheadline404">
<p>
We will define a cipher as a map from plain-text characters to cipher-text characters. We already have a sequence of pairs. Use Clojure's <code>into</code> function to convert this sequence into a map.
</p>
</div>

<div id="outline-container-orgheadline405" class="outline-5">
<h5 id="orgheadline405">Expected answer&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline405">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; {\A \N, \B \O, \C \P, \D \Q, \E \R, \F \S, \G \T, \H \U, \I \V, \J \W, \K \X, \L \Y, \M \Z, \N \A, \O \B, \P \C, \Q \D, \R \E, \S \F, \T \G, \U \H, \V \I, \W \J, \X \K, \Y \L, \Z \M}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline406" class="outline-5">
<h5 id="orgheadline406">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline406">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">into</span> {} (<span class="org-variable-name">map</span> vector letters (rotate letters 13)))
</pre>
</div>

<pre class="example">
;;=&gt; {\A \N, \B \O, \C \P, \D \Q, \E \R, \F \S, \G \T, \H \U, \I \V, \J \W, \K \X, \L \Y, \M \Z, \N \A, \O \B, \P \C, \Q \D, \R \E, \S \F, \T \G, \U \H, \V \I, \W \J, \X \K, \Y \L, \Z \M}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline407" class="outline-4">
<h4 id="orgheadline407">Building a map with reduce</h4>
<div class="outline-text-4" id="text-orgheadline407">
<p>
Clojure has a shortcut for this method of constructing maps called <code>zipmap</code>. Use <code>zipmap</code> to create the same map as the previous exercise. Define this map as <code>rot13-cipher</code>.
</p>
</div>

<div id="outline-container-orgheadline408" class="outline-5">
<h5 id="orgheadline408">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline408">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">rot13-cipher</span> (<span class="org-variable-name">zipmap</span> letters (rotate letters 13)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline409" class="outline-4">
<h4 id="orgheadline409">Invoking the map</h4>
<div class="outline-text-4" id="text-orgheadline409">
<p>
In the classic ROT-13 cipher, non-letter characters are left unchanged. Define a function <code>rot13-one-char</code> which takes a single character as its argument. If that character is in the <code>rot13-cipher</code> map, it returns the corresponding value. If the character is not in the map, it returns the original character unchanged.
</p>

<p>
Note: Our cipher ONLY WORKS ON CAPITAL LETTERS.
</p>
</div>

<div id="outline-container-orgheadline410" class="outline-5">
<h5 id="orgheadline410">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline410">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">rot13-one-char</span> [c]
  (rot13-cipher c c))
</pre>
</div>

<p>
Here we take advantage of the fact that maps are invocable, and take an optional second argument which is returned when the first argument is not a key in the map.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline411" class="outline-4">
<h4 id="orgheadline411">Enciphering text</h4>
<div class="outline-text-4" id="text-orgheadline411">
<p>
Define a function <code>rot13</code> that takes a string argument and returns the ROT-13 enciphered version.
</p>

<p>
Remember, our cipher ONLY WORKS ON CAPITAL LETTERS.
</p>

<p>
Hint: <code>apply str</code> will convert a collection of characters to a string.
</p>
</div>

<div id="outline-container-orgheadline412" class="outline-5">
<h5 id="orgheadline412">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline412">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">rot13</span> [text]
  (<span class="org-variable-name">apply</span> str (<span class="org-variable-name">map</span> rot13-one-char text)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline413" class="outline-5">
<h5 id="orgheadline413">Examples&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline413">
<div class="org-src-container">

<pre class="src src-clojure">(rot13 <span class="org-string">"HELLO, WORLD!"</span>)
</pre>
</div>

<pre class="example">
;;=&gt; "URYYB, JBEYQ!"
</pre>

<p>
The ROT-13 cipher is its own inverse, so we can use the same function to decipher text:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(rot13 <span class="org-string">"URYYB, JBEYQ!"</span>)
</pre>
</div>

<pre class="example">
;;=&gt; "HELLO, WORLD!"
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline414" class="outline-4">
<h4 id="orgheadline414">Bonus Questions</h4>
<div class="outline-text-4" id="text-orgheadline414">
<p>
The next few exercises will help you decipher the following message:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">secret-message</span>
  <span class="org-string">"FCMJ C CM U JLIALUGGCHA MSMNYG ZIL NBY CVG 704 ZIL WIGJONCHA QCNB</span>
<span class="org-string">MSGVIFCW YRJLYMMCIHM. CN BUM VYYH OMYX ZIL MSGVIFCW WUFWOFUNCIHM CH</span>
<span class="org-string">XCZZYLYHNCUF UHX CHNYALUF WUFWOFOM, YFYWNLCW WCLWOCN NBYILS,</span>
<span class="org-string">GUNBYGUNCWUF FIACW, UHX ULNCZCWCUF CHNYFFCAYHWY."</span>)
</pre>
</div>

<p>
This message was encoded with a rotation cipher similar to ROT-13. We can guess which cipher was used by finding the most common letters.
</p>
</div>

<div id="outline-container-orgheadline415" class="outline-5">
<h5 id="orgheadline415">Counting letter frequency</h5>
<div class="outline-text-5" id="text-orgheadline415">
<p>
Define a function <code>count-letters</code> that counts the occurrences of each letter in a string and returns them in a map.
</p>

<p>
Hint: a common strategy for building up a map from another collection is to <code>reduce</code> over the collection, adding one or more keys to the map at each step:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">reduce</span> (<span class="org-variable-name">fn</span> [result item]
          (<span class="org-variable-name">assoc</span> result ...))
        {}  <span class="org-comment">; empty map as seed for result</span>
        collection)
</pre>
</div>
</div>

<div id="outline-container-orgheadline416" class="outline-6">
<h6 id="orgheadline416">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline416">
<p>
Clojure already has a function <code>frequencies</code> that does this. It could also be written:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">count-letters</span> [text]
  (<span class="org-variable-name">reduce</span> (<span class="org-variable-name">fn</span> [counts character]
            (<span class="org-variable-name">assoc</span> counts character
                   (<span class="org-variable-name">inc</span> (counts character 0))))
          {}
          text))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline417" class="outline-5">
<h5 id="orgheadline417">Counting with fnil</h5>
<div class="outline-text-5" id="text-orgheadline417">
<p>
Clojure's <code>update-in</code> function is useful when making modifications to a map. It takes a vector of keys and a function, uses those keys to "reach into" the map, apply the function to a value, and return the modified map. The <code>fnil</code> function is useful in conjunction with <code>update-in</code>.
</p>

<p>
Use <code>update-in</code> and <code>fnil</code> to redefine the <code>count-letters</code> function.
</p>
</div>

<div id="outline-container-orgheadline418" class="outline-6">
<h6 id="orgheadline418">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline418">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">count-letters</span> [text]
  (<span class="org-variable-name">reduce</span> (<span class="org-variable-name">fn</span> [counts character]
            (<span class="org-variable-name">update-in</span> counts [character] (fnil inc 0)))
          {}
          text))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline419" class="outline-5">
<h5 id="orgheadline419">Finding most common letters</h5>
<div class="outline-text-5" id="text-orgheadline419">
<p>
Clojure's <code>sort-by</code> function can sort a collection by any arbitrary function. Use this to find the most common letters in the secret message cipher-text.
</p>
</div>

<div id="outline-container-orgheadline420" class="outline-6">
<h6 id="orgheadline420">Expected answer&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline420">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; (\D \E \K \P \T \Q \R \J \S \V \X \B \A \O \Z \G \I \H \L \M \F \N \U \W \Y \C)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline421" class="outline-6">
<h6 id="orgheadline421">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline421">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">sort-by</span> (count-letters secret-message) letters)
</pre>
</div>

<pre class="example">
;;=&gt; (\D \E \K \P \T \Q \R \J \S \V \X \B \A \O \Z \G \I \H \L \M \F \N \U \W \Y \C)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline422" class="outline-5">
<h5 id="orgheadline422">Deciphering</h5>
<div class="outline-text-5" id="text-orgheadline422">
<p>
In most English texts <i>E</i> is the most common letter, and this fact can often be used to break encryption. Our secret message is too short for that technique to work, so we will tell you that the most common letter in the plain-text message is <i>I</i>. We know the most common letter in the cipher-text from the previous exercise.
</p>

<p>
Given those facts, define a function to decipher the secret message.
</p>
</div>

<div id="outline-container-orgheadline423" class="outline-6">
<h6 id="orgheadline423">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline423">
<p>
We can see from the previous exercise that <i>C</i> is the most common letter in the cipher-text.  How far is <i>C</i> from <i>I</i>?
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">-</span> (<span class="org-variable-name">int</span> \I) (<span class="org-variable-name">int</span> \C))
</pre>
</div>

<pre class="example">
;;=&gt; 6
</pre>

<p>
So if we rotate the alphabet by six letters, we should be able to decipher the message.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">rot6-cipher</span> (<span class="org-variable-name">zipmap</span> letters (rotate letters 6)))

(<span class="org-keyword">defn</span> <span class="org-function-name">rot6</span> [text]
  (<span class="org-variable-name">apply</span> str (<span class="org-variable-name">map</span> #(rot6-cipher % %) text)))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">println</span> (rot6 secret-message))
<span class="org-comment-delimiter">;; </span><span class="org-comment">LISP I IS A PROGRAMMING SYSTEM FOR THE IBM 704 FOR COMPUTING WITH</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">SYMBOLIC EXPRESSIONS. IT HAS BEEN USED FOR SYMBOLIC CALCULATIONS IN</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">DIFFERENTIAL AND INTEGRAL CALCULUS, ELECTRIC CIRCUIT THEORY,</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">MATHEMATICAL LOGIC, AND ARTIFICIAL INTELLIGENCE.</span>
</pre>
</div>

<p>
The text is the opening paragraph of the <a href="http://history.siam.org/sup/Fox_1960_LISP.pdf">LISP I Programmer's Manual (PDF)</a>, published in 1960.
</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline781" class="outline-2">
<h2 id="orgheadline781">Intermediate Topics</h2>
<div class="outline-text-2" id="text-orgheadline781">
</div><div id="outline-container-orgheadline425" class="outline-3">
<h3 id="orgheadline425">Transducers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-orgheadline425">
</div>

<div id="outline-container-orgheadline438" class="outline-4">
<h4 id="orgheadline438">Transducers</h4>
<div class="outline-text-4" id="text-orgheadline438">
</div><div id="outline-container-orgheadline426" class="outline-5">
<h5 id="orgheadline426">Why transducers?&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline426">
<ul class="org-ul">
<li>Implementation of <code>map</code>, <code>filter</code>, etc involves:
<ul class="org-ul">
<li>1) Iterating the input sequence</li>
<li>2) Applying the operation</li>
<li>3) Constructing the output sequence</li>
</ul></li>
<li>Transducers are composable transformations (#2)</li>
<li>But can be used with many processing contexts (#1, #3)</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline427" class="outline-5">
<h5 id="orgheadline427">Creating transducers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline427">
<ul class="org-ul">
<li>Most sequence functions have reduced arity form</li>
<li>Omit the collection and get a transducer instead</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">map</span> inc)          <span class="org-comment-delimiter">;; </span><span class="org-comment">transducer</span>
(<span class="org-variable-name">filter</span> odd?)      <span class="org-comment-delimiter">;; </span><span class="org-comment">transducer</span>
(partition-all 2)  <span class="org-comment-delimiter">;; </span><span class="org-comment">transducer</span>
</pre>
</div>

<ul class="org-ul">
<li>Transducer is a "recipe" for the algorithm</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline428" class="outline-5">
<h5 id="orgheadline428">Combining transducers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline428">
<ul class="org-ul">
<li>Transducers are most easily combined using <code>comp</code></li>
<li>Composition creates a modified "recipe"</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">transducer</span>
(<span class="org-variable-name">comp</span> (<span class="org-variable-name">filter</span> odd?) (<span class="org-variable-name">map</span> inc) (partition-all 2))
</pre>
</div>

<ul class="org-ul">
<li>Transformations are applied left to right in a process
<ul class="org-ul">
<li><code>filter</code>, then <code>map</code>, then <code>partition-all</code></li>
</ul></li>
<li>Mnemonic - think of it reading like <code>-&gt;&gt;</code></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline429" class="outline-5">
<h5 id="orgheadline429">Transducible process&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline429">
<ul class="org-ul">
<li>A "transducible process" takes a transducer and applies it to a
series of inputs. What happens to the results depends on the process.</li>
<li><code>transduce</code> - like reduce. Applies transducer to an input
collection and accumulates an output.</li>
<li><code>into</code> - collect the results of applying a transducer to an input
collection into an output collection</li>
<li><code>sequence</code> - creates an incrementally computed sequence from
applying a transducer to an input collection.</li>
<li><code>eduction</code> - creates an iterable/reducible instance that
will perform the entire transformation anew on each use</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline430" class="outline-5">
<h5 id="orgheadline430">transduce&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline430">
<p>
Similar to reduce. Applies transducer to input collection and
reduces with + using initial value 0:
</p>
<div class="org-src-container">

<pre class="src src-clojure">(transduce (<span class="org-variable-name">map</span> inc) + 0 (<span class="org-variable-name">range</span> 100))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 5050</span>
</pre>
</div>

<p>
Arguments:
</p>
<ul class="org-ul">
<li>transducer</li>
<li>final reducing function</li>
<li>initial value (optional)</li>
<li>input collection</li>
</ul>
</div>
</div>


<div id="outline-container-orgheadline431" class="outline-5">
<h5 id="orgheadline431">into&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline431">
<p>
Eager collection into a target collection.
</p>

<p>
Collect the results of applying a transducer into an output
collection:
</p>
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">into</span> [] (<span class="org-variable-name">filter</span> prime?) (<span class="org-variable-name">range</span> 1000))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline432" class="outline-5">
<h5 id="orgheadline432">sequence&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline432">
<p>
Delayed, cached production of output elements.
Note: will completely realize intermediate results.
</p>

<p>
Create a lazy sequence from a collection and a transducer:
</p>
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">sequence</span> (<span class="org-variable-name">map</span> inc) (<span class="org-variable-name">range</span> 100))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline433" class="outline-5">
<h5 id="orgheadline433">eduction&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline433">
<p>
Delayed, <b>non-cached</b> production of results.
</p>

<p>
Create an eduction from a collection and a transducer:
</p>
<div class="org-src-container">

<pre class="src src-clojure">(eduction (<span class="org-variable-name">map</span> inc) (<span class="org-variable-name">range</span> 100))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline434" class="outline-5">
<h5 id="orgheadline434">core.async Channels&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline434">
<p>
Transducers can also be applied to streams of values flowing through a
channel:
</p>
<div class="org-src-container">

<pre class="src src-clojure">(async/chan 10 (<span class="org-variable-name">map</span> inc))
</pre>
</div>

<ul class="org-ul">
<li>More on this later!</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline435" class="outline-5">
<h5 id="orgheadline435">Comparing sequences to transducers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline435">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">sequence with thread-last</span>
(<span class="org-builtin">-&gt;&gt;</span> (<span class="org-variable-name">range</span> 100)         <span class="org-comment-delimiter">;; </span><span class="org-comment">input </span>
     (<span class="org-variable-name">map</span> inc)           <span class="org-comment-delimiter">;; </span><span class="org-comment">transformation</span>
     (<span class="org-variable-name">filter</span> odd?)
     (partition-all 4))

<span class="org-comment-delimiter">;; </span><span class="org-comment">transducer composition</span>
(<span class="org-variable-name">into</span> []                  <span class="org-comment-delimiter">;; </span><span class="org-comment">output </span>
  (<span class="org-variable-name">comp</span> (<span class="org-variable-name">map</span> inc)         <span class="org-comment-delimiter">;; </span><span class="org-comment">transformation</span>
        (<span class="org-variable-name">filter</span> odd?)
        (partition-all 4))
  (<span class="org-variable-name">range</span> 100))            <span class="org-comment-delimiter">;; </span><span class="org-comment">input</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline436" class="outline-5">
<h5 id="orgheadline436">Transducer advantages vs sequences&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline436">
<ul class="org-ul">
<li>Create transformation once, apply in multiple contexts
<ul class="org-ul">
<li>Improves code factoring</li>
</ul></li>
<li>Single pass over the input instead of pass per transformation
<ul class="org-ul">
<li>Less computation</li>
<li>Less object creation and garbage collection</li>
</ul></li>
<li>Eager execution
<ul class="org-ul">
<li>Easier to know and manage use of input resource</li>
<li>Errors occur at point of use rather than later</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline437" class="outline-5">
<h5 id="orgheadline437">Sequence advantages vs transducers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline437">
<ul class="org-ul">
<li>Lazier in consumption
<ul class="org-ul">
<li>Transducers fully realize each "step" per input</li>
</ul></li>
<li>Broader set of transformations available
<ul class="org-ul">
<li>Not all core sequence functions have transducers</li>
</ul></li>
<li>Many existing APIs expect sequences
<ul class="org-ul">
<li>This will likely change over time</li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline439" class="outline-3">
<h3 id="orgheadline439">Polymorphism&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-orgheadline439">
</div>

<div id="outline-container-orgheadline440" class="outline-4">
<h4 id="orgheadline440">Motivation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline440">
<ul class="org-ul">
<li>Protocols (<code>defprotocol</code>)
<ul class="org-ul">
<li>Type-oriented polymorphic behavior</li>
</ul></li>
<li>Multimethods (<code>defmulti</code>)
<ul class="org-ul">
<li>Polymorphic behavior with arbitrary dispatch</li>
</ul></li>

<li>Records (<code>defrecord</code>)
<ul class="org-ul">
<li>Represent information entities with known fields</li>
</ul></li>
<li>Types (<code>deftype</code>)
<ul class="org-ul">
<li>Implement custom data structures</li>
</ul></li>
</ul>
</div>

<div id="outline-container-orgheadline441" class="outline-5">
<h5 id="orgheadline441">Opinions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline441">
<ul class="org-ul">
<li>Implementation inheritance is bad
<ul class="org-ul">
<li>Only derive from interfaces</li>
<li>All methods must be in interfaces</li>
</ul></li>
<li>Polymorphism doesn't require inheritance</li>
<li>Data is still immutable</li>
<li>No data hiding (encapsulation)
<ul class="org-ul">
<li>Immutable data can be safely shared</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline442" class="outline-5">
<h5 id="orgheadline442">What does "type" mean?&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline442">
<ul class="org-ul">
<li>"What is the type (class) of object x?"
<ul class="org-ul">
<li><code>(class x)</code> or <code>(type x)</code></li>
</ul></li>
<li>"Foo is a type (class)"
<ul class="org-ul">
<li><code>(defrecord Foo ...)</code> or <code>(deftype Foo ...)</code></li>
<li>or Java <code>public class Foo {...}</code></li>
</ul></li>
<li>Java primitive types
<ul class="org-ul">
<li><code>int</code>, <code>long</code>, <code>double</code>, arrays, etc.</li>
</ul></li>
</ul>
</div>
</div>
</div>


<div id="outline-container-orgheadline443" class="outline-4">
<h4 id="orgheadline443">Protocols&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline443">
<ul class="org-ul">
<li>Abstract behavioral contract</li>
<li>Named group of generic functions
<ul class="org-ul">
<li>Parameters and doc string</li>
<li>No implementation</li>
</ul></li>
<li>Polymorphic on <i>type</i> of <i>first</i> argument
<ul class="org-ul">
<li>Like methods in object-oriented programming</li>
</ul></li>
<li>Must have at least one argument, used for dispatch
<ul class="org-ul">
<li>Equivalent to <code>this</code> in Java</li>
</ul></li>
</ul>
</div>

<div id="outline-container-orgheadline444" class="outline-5">
<h5 id="orgheadline444"><code>defprotocol</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline444">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defprotocol</span> <span class="org-function-name">MyProtocol</span>
  <span class="org-doc">"A doc string for MyProtocol abstraction"</span>
  (bar [q r] <span class="org-string">"bar docs"</span>)
  (baz [q] <span class="org-string">"baz docs"</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline445" class="outline-5">
<h5 id="orgheadline445">Protocol Dispatch&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline445">
<ul class="org-ul">
<li><code>defprotocol</code> creates generic <i>functions</i>
<ul class="org-ul">
<li>Normal functions like <code>defn</code></li>
<li>Invoked like any other Clojure function</li>
</ul></li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defprotocol</span> <span class="org-function-name">Describe</span>
  (desc [self]))

(desc thing)  <span class="org-comment">; Invoke it like this</span>

(<span class="org-preprocessor">.desc</span> thing) <span class="org-comment">; Not this</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">Similar to Java:  thing.desc()</span>
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgheadline446" class="outline-4">
<h4 id="orgheadline446">Extending Protocols to Types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline446">
<ul class="org-ul">
<li>What if we want to <i>add</i> protocols to an <i>existing</i> type
<ul class="org-ul">
<li>E.g. Java built-in types like <code>String</code></li>
</ul></li>
<li>Commonly called "The Expression Problem"</li>
<li>Common solutions are inadequate:
<ul class="org-ul">
<li>Inheritance: can't inherit from <code>String</code></li>
<li>Multiple inheritance: complex, not allowed in Java</li>
<li>Wrapping: complex, breaks type &amp; equality</li>
<li>Open classes: no namespacing, error-prone</li>
<li>Conditionals: complex, not extensible</li>
</ul></li>
</ul>
</div>

<div id="outline-container-orgheadline447" class="outline-5">
<h5 id="orgheadline447">Extending Protocols to Types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline447">
<ul class="org-ul">
<li>Extend <i>any</i> protocol to <i>any</i> type
<ul class="org-ul">
<li>Including <code>final</code> Java classes</li>
</ul></li>
<li>Type is not modified in any way</li>
<li>Can extend an implementation to <code>nil</code></li>
<li>Can extend default implementation to <code>Object</code></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline448" class="outline-5">
<h5 id="orgheadline448"><code>extend-type</code> and <code>extend-protocol</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline448">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">extend-type</span> <span class="org-preprocessor">SomeType</span>          <span class="org-comment">; 1 type, many protocols</span>
  <span class="org-preprocessor">SomeProtocol</span>
  (some-method [...] ...)
  <span class="org-preprocessor">AnotherProtocol</span>
  (another-method [...] ...))

(<span class="org-variable-name">extend-protocol</span> <span class="org-preprocessor">SomeProtocol</span>  <span class="org-comment">; 1 protocol, many types</span>
  <span class="org-preprocessor">SomeType</span>
  (some-method [...] ...)
  <span class="org-preprocessor">AnotherType</span>
  (some-method [...] ...))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline449" class="outline-5">
<h5 id="orgheadline449"><code>extend-type</code> example&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline449">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">; </span><span class="org-comment">java.lang.String does not implement Describe</span>
(desc <span class="org-string">"a"</span>)

<span class="org-comment-delimiter">; </span><span class="org-comment">IllegalArgumentException No implementation of</span>
<span class="org-comment-delimiter">; </span><span class="org-comment">method: :desc of protocol: #'user/Describe</span>
<span class="org-comment-delimiter">; </span><span class="org-comment">found for class: java.lang.String </span>

(<span class="org-variable-name">satisfies?</span> <span class="org-preprocessor">Describe</span> <span class="org-string">"a"</span>)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; false</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline450" class="outline-5">
<h5 id="orgheadline450"><code>extend-type</code> example&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline450">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">; </span><span class="org-comment">extend Describe to java.lang.String</span>
(<span class="org-variable-name">extend-type</span> <span class="org-preprocessor">String</span>
  <span class="org-preprocessor">Describe</span>
  (desc [s] s))

(<span class="org-variable-name">satisfies?</span> <span class="org-preprocessor">Describe</span> <span class="org-string">"a"</span>)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; true</span>

<span class="org-comment-delimiter">; </span><span class="org-comment">try again...</span>
(desc <span class="org-string">"a"</span>)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "a"</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline451" class="outline-4">
<h4 id="orgheadline451">Reifying Protocols&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline451">
<ul class="org-ul">
<li><code>reify</code> builds anonymous type and instance on the fly</li>
<li>Conceptually similar to anonymous functions
<ul class="org-ul">
<li>Or anonymous inner classes in Java</li>
</ul></li>
<li>Function bodies are closures</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">r</span> (<span class="org-builtin">let</span> [x 42]
         (<span class="org-variable-name">reify</span> <span class="org-preprocessor">Describe</span>
           (desc [_] (<span class="org-variable-name">str</span> <span class="org-string">"describe with "</span> x)))))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #user/r</span>

(desc r)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "describe with 42"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline452" class="outline-4">
<h4 id="orgheadline452">Multimethods&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline452">
<ul class="org-ul">
<li>Protocols limited to:
<ul class="org-ul">
<li><i>Single-argument</i> dispatch</li>
<li>On <i>type</i> of first argument</li>
</ul></li>
<li>Multimethods provide:
<ul class="org-ul">
<li><i>Multiple-argument</i> dispatch</li>
<li>On <i>any</i> criteria</li>
</ul></li>
</ul>
</div>

<div id="outline-container-orgheadline453" class="outline-5">
<h5 id="orgheadline453">Multimethod Example&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline453">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defmulti</span> <span class="org-function-name">reaction</span>
  <span class="org-comment-delimiter">;; </span><span class="org-comment">2-argument dispatch function:</span>
  (<span class="org-variable-name">fn</span> [a b] [(<span class="org-constant">:species</span> a) (<span class="org-constant">:species</span> b)]))

(<span class="org-keyword">defmethod</span> <span class="org-function-name">reaction</span> [<span class="org-constant">:hero</span> <span class="org-constant">:monster</span>] <span class="org-comment">; match criteria</span>
  [hero monster]                     <span class="org-comment">; function parameters</span>
  (<span class="org-variable-name">str</span> hero <span class="org-string">" fights "</span> monster))     <span class="org-comment">; function body</span>

(<span class="org-keyword">defmethod</span> <span class="org-function-name">reaction</span> [<span class="org-constant">:monster</span> <span class="org-constant">:hero</span>]
  [monster hero]
  (<span class="org-variable-name">str</span> monster <span class="org-string">" eats "</span> hero))

(<span class="org-keyword">defmethod</span> <span class="org-function-name">reaction</span> [<span class="org-constant">:monster</span> <span class="org-constant">:monster</span>]
  [monster1 monster2]
  (<span class="org-variable-name">str</span> monster1 <span class="org-string">" plays with "</span> monster2))

(<span class="org-keyword">defmethod</span> <span class="org-function-name">reaction</span> [<span class="org-constant">:hero</span> <span class="org-constant">:hero</span>]
  [hero1 hero2]
  (<span class="org-variable-name">str</span> hero1 <span class="org-string">" taunts "</span> hero2))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline454" class="outline-5">
<h5 id="orgheadline454">Custom Dispatch&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline454">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defmulti</span> <span class="org-function-name">shape</span> count)

(<span class="org-keyword">defmethod</span> <span class="org-function-name">shape</span> 3 [points] <span class="org-string">"triangle"</span>)
(<span class="org-keyword">defmethod</span> <span class="org-function-name">shape</span> 4 [points] <span class="org-string">"rectangle"</span>)
(<span class="org-keyword">defmethod</span> <span class="org-function-name">shape</span> 5 [points] <span class="org-string">"pentagon"</span>)
(<span class="org-keyword">defmethod</span> <span class="org-function-name">shape</span> 6 [points] <span class="org-string">"hexagon"</span>)
(<span class="org-keyword">defmethod</span> <span class="org-function-name">shape</span> <span class="org-constant">:default</span> [n] <span class="org-string">"who cares?"</span>)

(shape [[0 0], [0 5], [5 0]]) <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "triangle"</span>
(shape [[0 0], [0 5], [5 0], [5 5]]) <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "rectangle"</span>
(shape []) <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "who cares?"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline455" class="outline-5">
<h5 id="orgheadline455">Multimethods vs. Protocols&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline455">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">Multimethods</th>
<th scope="col" class="org-left">Protocols</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Extensible</td>
<td class="org-left">yes</td>
<td class="org-left">yes</td>
</tr>

<tr>
<td class="org-left">Java interop story</td>
<td class="org-left">Vars</td>
<td class="org-left">interfaces</td>
</tr>

<tr>
<td class="org-left">Dispatch on arguments</td>
<td class="org-left">any number</td>
<td class="org-left">only first</td>
</tr>

<tr>
<td class="org-left">Dispatch function</td>
<td class="org-left">arbitrary</td>
<td class="org-left">only type</td>
</tr>

<tr>
<td class="org-left">Method grouping</td>
<td class="org-left">no</td>
<td class="org-left">yes</td>
</tr>

<tr>
<td class="org-left">High performance</td>
<td class="org-left">no</td>
<td class="org-left">yes</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-orgheadline456" class="outline-4">
<h4 id="orgheadline456">Records&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline456">
<ul class="org-ul">
<li>Typical app represents domain data using maps</li>
<li>Often want polymorphic behavior across different types of map data</li>
<li>Records are <i>named</i> map types</li>
<li>Records can implement protocols</li>
</ul>
</div>

<div id="outline-container-orgheadline457" class="outline-5">
<h5 id="orgheadline457"><code>defrecord</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline457">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defrecord</span> <span class="org-function-name">Car</span> [make model year])   <span class="org-comment">; named type with fields</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; user.Car</span>

(<span class="org-keyword">def</span> <span class="org-function-name">car</span> (-&gt;<span class="org-preprocessor">Car</span> <span class="org-string">"Dodge"</span> <span class="org-string">"Omni"</span> 1980)) <span class="org-comment">; instantiation</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #'user/car</span>

(<span class="org-constant">:year</span> car)                   <span class="org-comment">; field access</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 1980</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline458" class="outline-5">
<h5 id="orgheadline458">Records are Classes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline458">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">car</span> (<span class="org-preprocessor">Car.</span> <span class="org-string">"Dodge"</span> <span class="org-string">"Omni"</span> 1980))  <span class="org-comment">; Java constructor</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #'user/car</span>

(.-year car)               <span class="org-comment">; fields are public &amp; final</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 1980                 </span>

(<span class="org-variable-name">class</span> car)                <span class="org-comment">; ordinary class</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; user.Car</span>

(<span class="org-variable-name">supers</span> (<span class="org-variable-name">class</span> car))       <span class="org-comment">; lots of built-in functionality</span>

<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #{clojure.lang.IObj clojure.lang.IKeywordLookup java.util.Map</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">clojure.lang.IPersistentMap clojure.lang.IMeta java.lang.Object</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">java.lang.Iterable clojure.lang.ILookup clojure.lang.Seqable</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">clojure.lang.Counted clojure.lang.IPersistentCollection</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">clojure.lang.Associative}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline459" class="outline-5">
<h5 id="orgheadline459">Implementing Protocols on Records&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline459">
<ul class="org-ul">
<li>Protocols can be implemented directly in <code>defrecord</code>
<ul class="org-ul">
<li>Can implement Java interfaces too</li>
</ul></li>
<li>Method implementation bodies
<ul class="org-ul">
<li>Can access record fields directly</li>
<li>Do not close over lexical environment</li>
</ul></li>
<li>Only implement the methods you need
<ul class="org-ul">
<li>Invoking undefined method throws <code>AbstractMethodError</code></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline460" class="outline-5">
<h5 id="orgheadline460">Implementing Protocols on records&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline460">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">; </span><span class="org-comment">specify protocol(s) directly inline</span>
(<span class="org-keyword">defrecord</span> <span class="org-function-name">Car</span> [make model year]
  <span class="org-preprocessor">Describe</span>
  (desc [self] (<span class="org-variable-name">str</span> year <span class="org-string">" "</span> make <span class="org-string">" "</span> model)))

(<span class="org-keyword">def</span> <span class="org-function-name">car</span> (-&gt;<span class="org-preprocessor">Car</span> <span class="org-string">"Dodge"</span> <span class="org-string">"Omni"</span> 1980))  
(desc car)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "1980 Dodge Omni"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline461" class="outline-5">
<h5 id="orgheadline461">Using Protocols and Records&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline461">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defprotocol</span> <span class="org-function-name">Player</span> <span class="org-doc">"A rock/paper/scissors player"</span>
  (choose [p] <span class="org-string">"return :rock, :paper or :scissors"</span>)
  (update-player [p me you]
    <span class="org-string">"return a new player based on what you and I did"</span>))

(<span class="org-keyword">defrecord</span> <span class="org-function-name">Stubborn</span> [choice]
  <span class="org-preprocessor">Player</span> <span class="org-comment">; implement Player protocol</span>
  (choose [_] choice) <span class="org-comment">; always play the choice</span>
  (update-player [this _ _] this)) <span class="org-comment">; never change</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline462" class="outline-5">
<h5 id="orgheadline462">Using Protocols and Records&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline462">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defrecord</span> <span class="org-function-name">Mean</span> [last-win] <span class="org-comment">; last thing that won for me</span>
  <span class="org-preprocessor">Player</span>
  (choose [_]
    (<span class="org-builtin">if</span> last-win  <span class="org-comment">; play last-win or random</span>
      last-win
      (random-choice)))
  (update-player [_ me you]
    <span class="org-comment-delimiter">;; </span><span class="org-comment">reuse last choice, or switch to random</span>
    (-&gt;<span class="org-preprocessor">Mean</span> (<span class="org-builtin">when</span> (i-won? me you) me))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline463" class="outline-4">
<h4 id="orgheadline463"><code>deftype</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline463">
<ul class="org-ul">
<li>Sometimes you don't want/need map behavior
<ul class="org-ul">
<li>New data structures</li>
<li>Clojure's data structures implemented in Clojure</li>
</ul></li>
<li><code>deftype</code> looks like <code>defrecord</code>
<ul class="org-ul">
<li>But provides <i>no</i> default behavior</li>
<li>Not even <code>equals</code> or <code>hashCode</code>!</li>
<li>Fields can be mutable (super-advanced)</li>
</ul></li>
</ul>
</div>

<div id="outline-container-orgheadline464" class="outline-5">
<h5 id="orgheadline464"><code>deftype</code> example&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline464">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">deftype</span> <span class="org-function-name">Point</span> [x y])  <span class="org-comment">; named type with fields</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; user.Point</span>

(<span class="org-keyword">def</span> <span class="org-function-name">p</span> (-&gt;<span class="org-preprocessor">Point</span> 1 2))  <span class="org-comment">; constructor</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #'user/p          ; (but no map-&gt;Point)</span>

(.-x p)                <span class="org-comment">; ordinary field access</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 1                 ; (but no keyword lookup)</span>

(<span class="org-variable-name">class</span> p)              <span class="org-comment">; ordinary class</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; user.Point</span>

(<span class="org-variable-name">supers</span> (<span class="org-variable-name">class</span> p))     <span class="org-comment">; an (almost) blank slate</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #{java.lang.Object clojure.lang.IType}</span>
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline465" class="outline-3">
<h3 id="orgheadline465">LAB: Rock, Paper, Scissors&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-orgheadline465">
</div>

<div id="outline-container-orgheadline466" class="outline-4">
<h4 id="orgheadline466">Introduction</h4>
<div class="outline-text-4" id="text-orgheadline466">
<p>
In this lab, we will write programs to play the classic game of <a href="http://en.wikipedia.org/wiki/Rock-paper-scissors">Rock, Paper, Scissors</a>. The rules are pretty simple:
</p>

<ul class="org-ul">
<li>Rock beats Scissors</li>
<li>Scissors beats Paper</li>
<li>Paper beats Rock</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline467" class="outline-4">
<h4 id="orgheadline467">World domination</h4>
<div class="outline-text-4" id="text-orgheadline467">
<p>
Define a function <code>dominates</code> that takes a keyword argument and returns the keyword naming the thing that beats it.
</p>

<p>
Hint: remember that data structures are functions.
</p>
</div>

<div id="outline-container-orgheadline468" class="outline-5">
<h5 id="orgheadline468">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline468">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">dominates</span>
  {<span class="org-constant">:rock</span> <span class="org-constant">:paper</span>
   <span class="org-constant">:scissors</span> <span class="org-constant">:rock</span>
   <span class="org-constant">:paper</span> <span class="org-constant">:scissors</span>})
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline469" class="outline-4">
<h4 id="orgheadline469">Choices, choices</h4>
<div class="outline-text-4" id="text-orgheadline469">
<p>
Define a vector of the possible choices, reusing the definition of <code>dominates</code>.
</p>

<p>
Hint: the <code>keys</code> function returns a sequence of the keys in a map.
</p>
</div>

<div id="outline-container-orgheadline470" class="outline-5">
<h5 id="orgheadline470">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline470">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">choices</span> (<span class="org-variable-name">vec</span> (<span class="org-variable-name">keys</span> dominates)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline471" class="outline-4">
<h4 id="orgheadline471">Winners and losers</h4>
<div class="outline-text-4" id="text-orgheadline471">
<p>
Define a function <code>winner</code> that takes two players' choices and returns the winner, or <code>nil</code> for a tie.
</p>
</div>

<div id="outline-container-orgheadline472" class="outline-5">
<h5 id="orgheadline472">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline472">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">winner</span> [p1-choice p2-choice]
  (<span class="org-builtin">cond</span>
   (<span class="org-variable-name">=</span> p1-choice p2-choice) nil
   (<span class="org-variable-name">=</span> (dominates p1-choice) p2-choice) p2-choice
   <span class="org-constant">:else</span> p1-choice))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline473" class="outline-4">
<h4 id="orgheadline473">Draws and ties</h4>
<div class="outline-text-4" id="text-orgheadline473">
<p>
Define two predicates:
</p>

<ul class="org-ul">
<li><code>draw?</code> takes two players' choices and returns true if they are a draw</li>
<li><code>iwon?</code> takes two players' choices and returns true if the first player won</li>
</ul>
</div>

<div id="outline-container-orgheadline474" class="outline-5">
<h5 id="orgheadline474">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline474">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">draw?</span> [me you] (<span class="org-variable-name">=</span> me you))

(<span class="org-keyword">defn</span> <span class="org-function-name">iwon?</span> [me you] (<span class="org-variable-name">=</span> (winner me you) me))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline475" class="outline-4">
<h4 id="orgheadline475">The players</h4>
<div class="outline-text-4" id="text-orgheadline475">
<p>
All the players will conform to a <code>Player</code> protocol. It should have two methods:
</p>

<ul class="org-ul">
<li><code>choose</code> takes a player and returns that player's choice</li>
<li><code>update-player</code> takes a player, that player's last choice, and the other player's last choice, returning a new <code>Player</code> for the next round</li>
</ul>

<p>
Define the <code>Player</code> protocol.
</p>
</div>

<div id="outline-container-orgheadline476" class="outline-5">
<h5 id="orgheadline476">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline476">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defprotocol</span> <span class="org-function-name">Player</span>
  (choose [p])
  (update-player [p me you]))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline477" class="outline-4">
<h4 id="orgheadline477">Random player</h4>
<div class="outline-text-4" id="text-orgheadline477">
<p>
Define a <code>Random</code> player who always picks at random and never changes strategy based on what the other player is doing.
</p>

<p>
Hint: Clojure's <code>rand-nth</code> function picks a random element from a collection.
</p>
</div>

<div id="outline-container-orgheadline478" class="outline-5">
<h5 id="orgheadline478">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline478">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defrecord</span> <span class="org-function-name">Random</span> []
  <span class="org-preprocessor">Player</span>
  (choose [_] (rand-nth choices))
  (update-player [this me you] this))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline479" class="outline-4">
<h4 id="orgheadline479">Stubborn player</h4>
<div class="outline-text-4" id="text-orgheadline479">
<p>
Define a <code>Stubborn</code> player who is initialized with a choice and sticks with it no matter what.
</p>
</div>

<div id="outline-container-orgheadline480" class="outline-5">
<h5 id="orgheadline480">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline480">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defrecord</span> <span class="org-function-name">Stubborn</span> [choice]
  <span class="org-preprocessor">Player</span>
  (choose [_] choice)
  (update-player [this me you] this))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline481" class="outline-4">
<h4 id="orgheadline481">Mean player</h4>
<div class="outline-text-4" id="text-orgheadline481">
<p>
Define a <code>Mean</code> player, who is slightly more subtle. The mean player sticks with what worked last time if it won, or plays at random following a loss.
</p>
</div>

<div id="outline-container-orgheadline482" class="outline-5">
<h5 id="orgheadline482">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline482">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defrecord</span> <span class="org-function-name">Mean</span> [last-winner]
  <span class="org-preprocessor">Player</span>
  (choose [_]
    (<span class="org-builtin">if</span> last-winner last-winner (rand-nth choices)))
  (update-player [_ me you]
    (-&gt;<span class="org-preprocessor">Mean</span> (<span class="org-builtin">when</span> (iwon? me you) me))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline483" class="outline-4">
<h4 id="orgheadline483">Playing a game</h4>
<div class="outline-text-4" id="text-orgheadline483">
<p>
Define a <code>game</code> function with three arguments: two players and a number of rounds. The game should return the two player's scores in a map.
</p>

<p>
This can be nicely represented as a <code>loop</code> with five variables:
</p>

<ol class="org-ol">
<li>Player One</li>
<li>Player Two</li>
<li>Player One's current score</li>
<li>Player Two's current score</li>
<li>The number of rounds remaining</li>
</ol>

<p>
Try some games with various combinations of players. Do the results match your intuition?
</p>
</div>

<div id="outline-container-orgheadline484" class="outline-5">
<h5 id="orgheadline484">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline484">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">game</span>
  [p1 p2 rounds]
  (<span class="org-builtin">loop</span> [p1 p1
         p2 p2
         p1-score 0
         p2-score 0
         rounds rounds]
    (<span class="org-builtin">if</span> (<span class="org-variable-name">pos?</span> rounds)
      (<span class="org-builtin">let</span> [p1-choice (choose p1)
            p2-choice (choose p2)
            result (winner p1-choice p2-choice)]
        (<span class="org-builtin">recur</span>
         (update-player p1 p1-choice p2-choice)
         (update-player p2 p2-choice p1-choice)
         (<span class="org-variable-name">+</span> p1-score (<span class="org-builtin">if</span> (<span class="org-variable-name">=</span> result p1-choice) 1 0))
         (<span class="org-variable-name">+</span> p2-score (<span class="org-builtin">if</span> (<span class="org-variable-name">=</span> result p2-choice) 1 0))
         (<span class="org-variable-name">dec</span> rounds)))
      {<span class="org-constant">:p1</span> p1-score <span class="org-constant">:p2</span> p2-score})))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline485" class="outline-5">
<h5 id="orgheadline485">Examples&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline485">
<div class="org-src-container">

<pre class="src src-clojure">(game (-&gt;<span class="org-preprocessor">Stubborn</span> <span class="org-constant">:rock</span>) (-&gt;<span class="org-preprocessor">Stubborn</span> <span class="org-constant">:scissors</span>) 100)
</pre>
</div>

<pre class="example">
;;=&gt; {:p1 100, :p2 0}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(game (-&gt;<span class="org-preprocessor">Random</span>) (-&gt;<span class="org-preprocessor">Random</span>) 100)
</pre>
</div>

<pre class="example">
;;=&gt; {:p1 34, :p2 25}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(game (-&gt;<span class="org-preprocessor">Stubborn</span> <span class="org-constant">:rock</span>) (-&gt;<span class="org-preprocessor">Mean</span> nil) 100)
</pre>
</div>

<pre class="example">
;;=&gt; {:p1 5, :p2 93}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline486" class="outline-4">
<h4 id="orgheadline486">Bonus: More strategies</h4>
<div class="outline-text-4" id="text-orgheadline486">
<p>
Define some players with more sophisticated strategies. 
</p>

<p>
Compare them with example strategies in the <a href="http://webdocs.cs.ualberta.ca/~darse/rsb-ts1.c">International RoShamBo Programming Competition</a> (in C) and <a href="http://rubyquiz.com/quiz16.html">Ruby Quiz #16</a>.
</p>
</div>
</div>

<div id="outline-container-orgheadline487" class="outline-4">
<h4 id="orgheadline487">Bonus: Spock, Lizard</h4>
<div class="outline-text-4" id="text-orgheadline487">
<p>
Extend the simulation to support <a href="http://www.samkass.com/theories/RPSSL.html">Rock, Paper, Scissors, Spock, Lizard</a>.
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline488" class="outline-3">
<h3 id="orgheadline488">Concurrency&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-orgheadline488">
</div>

<div id="outline-container-orgheadline492" class="outline-4">
<h4 id="orgheadline492">Concurrency Introduction</h4>
<div class="outline-text-4" id="text-orgheadline492">
</div><div id="outline-container-orgheadline489" class="outline-5">
<h5 id="orgheadline489">Identity, Value, State&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline489">
<ul class="org-ul">
<li>Identity: a logical entity
<ul class="org-ul">
<li>Spouse, today, employer, shipping address</li>
</ul></li>
<li>Value: immutable data
<ul class="org-ul">
<li>5, "Bob", [0, 1, 2]</li>
</ul></li>
<li>State: the value of an identity at a given time
<ul class="org-ul">
<li>Today is September 15th, 2010</li>
<li>My son is 6 years old</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline490" class="outline-5">
<h5 id="orgheadline490">OOP with Mutable State&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline490">
<ul class="org-ul">
<li>Identities are pointers to locations in memory</li>
<li>Objects changed in-place</li>
<li>Updating state means overwriting memory
<ul class="org-ul">
<li>Need to protect reads/writes</li>
<li>No language support for coordinating change</li>
<li>Locking, deadlocks, nightmares</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline491" class="outline-5">
<h5 id="orgheadline491">Clojure's Approach&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline491">
<ul class="org-ul">
<li>Identities are managed references to immutable values</li>
<li>Nothing changed in-place</li>
<li>References provide read/write protection</li>
<li>Language-level constructs to manage change</li>
<li>No locking in user code</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline500" class="outline-4">
<h4 id="orgheadline500">Conceptual Model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline500">
</div><div id="outline-container-orgheadline493" class="outline-5">
<h5 id="orgheadline493">Modeling Change&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline493">

<div class="figure">
<p><object type="image/svg+xml" data="slide-assets/identity-state-01.svg" >
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline494" class="outline-5">
<h5 id="orgheadline494">Modeling Change&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline494">

<div class="figure">
<p><object type="image/svg+xml" data="slide-assets/identity-state-02.svg" >
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline495" class="outline-5">
<h5 id="orgheadline495">Modeling Change&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline495">

<div class="figure">
<p><object type="image/svg+xml" data="slide-assets/identity-state-03.svg" >
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline496" class="outline-5">
<h5 id="orgheadline496">Modeling Change&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline496">

<div class="figure">
<p><object type="image/svg+xml" data="slide-assets/identity-state-04.svg" >
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline497" class="outline-5">
<h5 id="orgheadline497">Modeling Change&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline497">

<div class="figure">
<p><object type="image/svg+xml" data="slide-assets/identity-state-05.svg" >
Sorry, your browser does not support SVG.</object>
</p>
</div>

<ul class="org-ul">
<li>The future is a function of the past.</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline498" class="outline-5">
<h5 id="orgheadline498">Uniform State Transition Model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline498">
<ul class="org-ul">
<li><code>(<i style='font-family: serif'>change-state</i> reference function args*)</code>
<ul class="org-ul">
<li>Calls function on old state + args</li>
<li>Function returns new state</li>
<li>Different <i>change-state</i> functions for different behavior</li>
</ul></li>
<li><code>(deref reference)</code>
<ul class="org-ul">
<li>Shorthand: <code>@reference</code></li>
<li>Returns snapshot of current state</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline499" class="outline-5">
<h5 id="orgheadline499">Mutable Reference Types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline499">
<ul class="org-ul">
<li>Synchronous
<ul class="org-ul">
<li>Uncoordinated: Var, Atom</li>
<li>Coordinated: Ref</li>
</ul></li>
<li>Asynchronous
<ul class="org-ul">
<li>Write-many: Agent</li>
<li>Write-once: Future, Promise</li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline505" class="outline-4">
<h4 id="orgheadline505">Atoms&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline505">
</div><div id="outline-container-orgheadline501" class="outline-5">
<h5 id="orgheadline501">Atoms&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline501">
<ul class="org-ul">
<li>Share a single identity across threads</li>
<li>Changes visible to all threads at the same time</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline502" class="outline-5">
<h5 id="orgheadline502">Atom Usage&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline502">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">tick</span> (<span class="org-variable-name">atom</span> 1))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #'user/tick</span>

(<span class="org-variable-name">deref</span> tick)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 1</span>

(<span class="org-variable-name">swap!</span> tick inc)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 2</span>

@tick
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 2</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline503" class="outline-5">
<h5 id="orgheadline503">Atom Guarantees&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline503">
<ul class="org-ul">
<li>Change is <i>synchronous</i> on caller thread</li>
<li>Changes are <i>atomic</i></li>
<li>No locking</li>
<li>No deadlocks</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline504" class="outline-5">
<h5 id="orgheadline504">Atom Caveats&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline504">
<ul class="org-ul">
<li>Values must be immutable</li>
<li>Cannot atomically update more than one</li>
<li>Spinning compare-and-set
<ul class="org-ul">
<li>Functions should be quick</li>
<li>Function may be called more than once</li>
<li>Must avoid side effects!</li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline514" class="outline-4">
<h4 id="orgheadline514">Refs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline514">
</div><div id="outline-container-orgheadline506" class="outline-5">
<h5 id="orgheadline506">Refs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline506">
<ul class="org-ul">
<li>Share identities across threads</li>
<li>Coordinated change among multiple identities</li>
<li>Consistent view of the whole world</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline507" class="outline-5">
<h5 id="orgheadline507">Ref Usage&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline507">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">a</span> (<span class="org-variable-name">ref</span> 1))
(<span class="org-keyword">def</span> <span class="org-function-name">b</span> (<span class="org-variable-name">ref</span> 10))

(<span class="org-builtin">dosync</span>
 (<span class="org-variable-name">alter</span> a inc)
 (<span class="org-variable-name">alter</span> b + 10))

@a  <span class="org-comment">;=&gt; 2</span>
@b  <span class="org-comment">;=&gt; 20</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline508" class="outline-5">
<h5 id="orgheadline508">Ref Guarantees&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline508">
<ul class="org-ul">
<li>Change is <i>synchronous</i> on caller thread</li>
<li>Change can only occur in a transaction</li>
<li>Every transaction is <i>atomic</i> and <i>isolated</i></li>
<li>No locking in user code</li>
<li>Internal locking &amp; deadlock prevention</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline509" class="outline-5">
<h5 id="orgheadline509">Within a Transaction&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline509">
<ul class="org-ul">
<li>Consistent snapshot of "Ref world" from point where transaction started</li>
<li>Transaction can see changes it has made</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline510" class="outline-5">
<h5 id="orgheadline510">Ref Caveats&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline510">
<ul class="org-ul">
<li>Values must be immutable</li>
<li>Transactions are speculative
<ul class="org-ul">
<li>Body may be called more than once</li>
<li>Must avoid side effects!</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline511" class="outline-5">
<h5 id="orgheadline511">No Read Tracking&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline511">
<ul class="org-ul">
<li>Reading a Ref does not prevent other transactions from changing it</li>
<li>Transaction does not see changes made by other transactions</li>
<li>Protect from changes with <code>ensure</code></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline512" class="outline-5">
<h5 id="orgheadline512"><code>ensure</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline512">
<p>
In this example, the fee may change during the life of the
transaction and the transaction will only see the starting value.
</p>
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">savings and fee are refs</span>
(<span class="org-builtin">dosync</span>
  (<span class="org-variable-name">alter</span> savings - @fee))
</pre>
</div>

<p>
Use ensure to guarantee that if the fee changes, the transaction will
fail and retry:
</p>
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">dosync</span>
  (<span class="org-variable-name">alter</span> savings - (<span class="org-variable-name">ensure</span> fee)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline513" class="outline-5">
<h5 id="orgheadline513"><code>commute</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline513">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">counter</span> (<span class="org-variable-name">ref</span> 1))

(<span class="org-builtin">dosync</span> (<span class="org-variable-name">commute</span> counter inc))

<span class="org-comment-delimiter">;; </span><span class="org-comment">On another thread:</span>
(<span class="org-builtin">dosync</span> (<span class="org-variable-name">commute</span> counter + 30))
</pre>
</div>

<ul class="org-ul">
<li>Order of updates doesn't matter</li>
<li>More concurrency than alter</li>
<li>Just an optimization</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline521" class="outline-4">
<h4 id="orgheadline521">Agents&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline521">
</div><div id="outline-container-orgheadline515" class="outline-5">
<h5 id="orgheadline515">Agents&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline515">
<ul class="org-ul">
<li>Share identities across threads</li>
<li>Ensure an entity only does one thing at a time</li>
<li>Send messages between entities</li>
<li>Utilize all available CPU cores</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline516" class="outline-5">
<h5 id="orgheadline516">Agent Usage&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline516">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">a</span> (<span class="org-variable-name">agent</span> 5))

(<span class="org-variable-name">send</span> a + 10)  <span class="org-comment">; returns immediately</span>
@a  <span class="org-comment">; =&gt; still 5</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">Some time later:</span>
@a  <span class="org-comment">; =&gt; 15</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline517" class="outline-5">
<h5 id="orgheadline517">Agent Guarantees&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline517">
<ul class="org-ul">
<li>Action occurs <i>asynchronously</i> on thread pool</li>
<li>Action called exactly once</li>
<li>Only one action per Agent at a time</li>
<li>Sends during an action
<ul class="org-ul">
<li>Occur <i>after</i> state has been updated</li>
<li>Do not occur if action throws an exception</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline518" class="outline-5">
<h5 id="orgheadline518"><code>send</code> vs. <code>send-off</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline518">
<ul class="org-ul">
<li><code>send</code>
<ul class="org-ul">
<li>Fixed-size thread pool</li>
<li>Actions should not block</li>
<li>For CPU-bound tasks</li>
</ul></li>
<li><code>send-off</code>
<ul class="org-ul">
<li>Variable-sized thread pool</li>
<li>Actions may block</li>
<li>For IO-bound tasks</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline519" class="outline-5">
<h5 id="orgheadline519">Agents Are Not Actors&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline519">
<ul class="org-ul">
<li>In-process only</li>
<li>Point-in-time perception is free</li>
<li>Send functions, not messages</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline520" class="outline-5">
<h5 id="orgheadline520">Agents and Transactions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline520">
<ul class="org-ul">
<li>Sends during a transaction
<ul class="org-ul">
<li>An allowable side-effect</li>
<li>Occur <i>after</i> transaction is committed</li>
<li>Do not occur if transaction is aborted</li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline526" class="outline-4">
<h4 id="orgheadline526">Vars&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline526">
</div><div id="outline-container-orgheadline522" class="outline-5">
<h5 id="orgheadline522">Vars&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline522">
<ul class="org-ul">
<li>Thread-safe global identity</li>
<li>Optional dynamic scope/overrides</li>
<li>Changes isolated to a single thread</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline523" class="outline-5">
<h5 id="orgheadline523">Var Guarantees&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline523">
<ul class="org-ul">
<li>One global root binding
<ul class="org-ul">
<li><code>alter-var-root</code> is <i>atomic</i> and <i>blocking</i></li>
</ul></li>
<li>With <code>^:dynamic</code>
<ul class="org-ul">
<li>Many thread-local bindings</li>
<li>Thread-local assignment</li>
<li>Dynamic scope</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline524" class="outline-5">
<h5 id="orgheadline524">Var Usage&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline524">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">foo</span> 1)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #'user/foo</span>

(<span class="org-variable-name">alter-var-root</span> #'foo inc)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 2</span>

foo
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 2</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline525" class="outline-5">
<h5 id="orgheadline525">Dynamic Var Usage&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline525">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-constant">^:dynamic</span> <span class="org-function-name">*foo*</span> 5)  <span class="org-comment">; root binding is 5</span>

(<span class="org-builtin">binding</span> [*foo* 100]  <span class="org-comment">; thread-local binding</span>
  (<span class="org-variable-name">println</span> *foo*)     <span class="org-comment">; =&gt; 100</span>
  (set! *foo* 42)     <span class="org-comment">; thread-local assignment</span>
  (<span class="org-variable-name">println</span> *foo*))    <span class="org-comment">; =&gt; 42</span>

*foo*  <span class="org-comment">; root binding still 5</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline529" class="outline-4">
<h4 id="orgheadline529">Uniform State Transition Model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline529">
</div><div id="outline-container-orgheadline527" class="outline-5">
<h5 id="orgheadline527">Uniform State Transition Model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline527">
<div class="org-src-container">

<pre class="src src-clojure">         (<span class="org-variable-name">swap!</span> an-atom  assoc <span class="org-constant">:a</span> <span class="org-string">"lucy"</span>)

 (<span class="org-builtin">dosync</span> (<span class="org-variable-name">alter</span> a-ref    assoc <span class="org-constant">:a</span> <span class="org-string">"lucy"</span>))

          (<span class="org-variable-name">send</span> an-agent assoc <span class="org-constant">:a</span> <span class="org-string">"lucy"</span>)

(<span class="org-variable-name">alter-var-root</span> #'a-var  assoc <span class="org-constant">:a</span> <span class="org-string">"lucy"</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline528" class="outline-5">
<h5 id="orgheadline528">Breaking the State Transition Model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline528">
<div class="org-src-container">

<pre class="src src-clojure">         (<span class="org-variable-name">reset!</span> an-atom  42)

(<span class="org-builtin">dosync</span> (<span class="org-variable-name">ref-set</span> a-ref    42))

           (<span class="org-variable-name">send</span> an-agent (<span class="org-variable-name">constantly</span> 42))

 (<span class="org-variable-name">alter-var-root</span> #'a-var  (<span class="org-variable-name">constantly</span> 42))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline533" class="outline-4">
<h4 id="orgheadline533">Watches&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline533">
</div><div id="outline-container-orgheadline530" class="outline-5">
<h5 id="orgheadline530">Watches&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline530">
<ul class="org-ul">
<li>Get notified when a reference changes</li>
<li>Supports Atom, Ref, Agent, and Var</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline531" class="outline-5">
<h5 id="orgheadline531">Watch Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline531">
<ul class="org-ul">
<li>Arguments: key, reference, old and new states</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">my-watcher</span> [key reference old-state new-state]
  (<span class="org-variable-name">println</span> <span class="org-string">"Watcher called for"</span> key)
  (<span class="org-variable-name">println</span> <span class="org-string">"Old state:"</span> old-state)
  (<span class="org-variable-name">println</span> <span class="org-string">"New state:"</span> new-state))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline532" class="outline-5">
<h5 id="orgheadline532"><code>add-watch</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline532">
<ul class="org-ul">
<li>Arguments: reference, key, watch function</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(add-watch r <span class="org-constant">:foo</span> my-watcher)

(<span class="org-builtin">dosync</span> (<span class="org-variable-name">alter</span> r inc))
<span class="org-comment-delimiter">;; </span><span class="org-comment">Watcher called for :foo</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Old state: 42</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">New state: 43</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 43</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline536" class="outline-4">
<h4 id="orgheadline536">Futures&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline536">
</div><div id="outline-container-orgheadline534" class="outline-5">
<h5 id="orgheadline534">Futures&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline534">
<ul class="org-ul">
<li>Execute code in a background thread
<ul class="org-ul">
<li>Possibly with side effects</li>
</ul></li>
<li>Block only when we ask for the result</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline535" class="outline-5">
<h5 id="orgheadline535">Future Usage&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline535">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">f</span> (<span class="org-variable-name">future</span>
         <span class="org-comment-delimiter">;; </span><span class="org-comment">body of expressions</span>
         ))
<span class="org-comment-delimiter">;; </span><span class="org-comment">body starts on background thread</span>

@f  <span class="org-comment">; blocks until complete, returns result</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline540" class="outline-4">
<h4 id="orgheadline540">Promises&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline540">
</div><div id="outline-container-orgheadline537" class="outline-5">
<h5 id="orgheadline537">Promises&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline537">
<ul class="org-ul">
<li>Communicate a single value across threads</li>
<li>Set once</li>
<li>Wait until a value becomes available</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline538" class="outline-5">
<h5 id="orgheadline538">Promise Usage&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline538">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">p</span> (<span class="org-variable-name">promise</span>))

<span class="org-comment-delimiter">;; </span><span class="org-comment">on another thread</span>
(<span class="org-variable-name">deliver</span> p 42)

@p  <span class="org-comment">; blocks until delivered</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline539" class="outline-5">
<h5 id="orgheadline539">Inverting Async&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline539">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">p</span> (<span class="org-variable-name">promise</span>))

(<span class="org-variable-name">future</span>
  <span class="org-comment-delimiter">;; </span><span class="org-comment">do something that takes time</span>
  (<span class="org-variable-name">deliver</span> p 42))

<span class="org-comment-delimiter">;; </span><span class="org-comment">do something else for a while</span>

@p  <span class="org-comment">; blocks until delivered</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline541" class="outline-4">
<h4 id="orgheadline541">Concurrency and the JVM&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline541">
<ul class="org-ul">
<li><code>java.util.concurrent</code> is still there
<ul class="org-ul">
<li>thread pools, locks, atomics, concurrent collections</li>
<li>Clojure fns are <code>java.util.concurrent.Callable</code>
<ul class="org-ul">
<li>And <code>java.lang.Runnable</code></li>
</ul></li>
</ul></li>
<li>Clojure's concurrency features are thread-agnostic
<ul class="org-ul">
<li>Use Futures/Agents to create threads</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgheadline542" class="outline-3">
<h3 id="orgheadline542">LAB: Concurrent Surgery&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-orgheadline542">
</div>

<div id="outline-container-orgheadline543" class="outline-4">
<h4 id="orgheadline543">Introduction</h4>
<div class="outline-text-4" id="text-orgheadline543">
<p>
In this lab, we will build a crude simulation of a hospital in which surgeons perform operations on patients. In order to focus on the specific topic of concurrency, we will provide most of the initial setup code for you to copy-and-paste.
</p>

<p>
Patients are mutable references. We'll start with Atoms. Each patient has an initial state of two arms, two legs, and one head. There are 1000 patients in the hospital.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">patient</span> []
  (<span class="org-variable-name">atom</span> {<span class="org-constant">:arms</span> 2
         <span class="org-constant">:legs</span> 2
         <span class="org-constant">:heads</span> 1}))

(<span class="org-keyword">defn</span> <span class="org-function-name">init-patients</span> []
  (<span class="org-variable-name">vec</span> (<span class="org-variable-name">repeatedly</span> 1000 patient)))
</pre>
</div>

<p>
There are 100 surgeons in the hospital. Each surgeon specializes in operating on one particular part of the body.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">surgeon</span> [specialty] 
  {<span class="org-constant">:specialty</span> specialty})

(<span class="org-keyword">defn</span> <span class="org-function-name">init-surgeons</span> []
  (<span class="org-variable-name">vec</span> (<span class="org-variable-name">take</span> 100 (<span class="org-variable-name">map</span> surgeon (<span class="org-variable-name">cycle</span> [<span class="org-constant">:arms</span> <span class="org-constant">:legs</span> <span class="org-constant">:heads</span>])))))
</pre>
</div>

<p>
The global state of the simulation will be stored in two Vars:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">all-patients</span> nil)
(<span class="org-keyword">def</span> <span class="org-function-name">all-surgeons</span> nil)

(<span class="org-keyword">defn</span> <span class="org-function-name">init!</span> []
  (<span class="org-variable-name">alter-var-root</span> #'all-patients (<span class="org-variable-name">constantly</span> (init-patients)))
  (<span class="org-variable-name">alter-var-root</span> #'all-surgeons (<span class="org-variable-name">constantly</span> (init-surgeons))))
</pre>
</div>

<p>
Our hospital is very conscientious about keeping track of body parts. We want to count the total number of arms, legs, and heads to verify that it stays constant.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">totals</span> []
  (<span class="org-variable-name">reduce</span> (<span class="org-variable-name">partial</span> merge-with +)
          (<span class="org-variable-name">map</span> deref all-patients)))
</pre>
</div>

<p>
For example, at the REPL:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(init!)
(totals)
</pre>
</div>

<pre class="example">
;;=&gt; {:legs 2000, :arms 2000, :heads 1000}
</pre>
</div>
</div>

<div id="outline-container-orgheadline544" class="outline-4">
<h4 id="orgheadline544">Modifying patients</h4>
<div class="outline-text-4" id="text-orgheadline544">
<p>
Surgeons perform transplant operations on patients by removing a limb from one patient and adding it to another patient. The particular limb they choose is determined by their specialty.
</p>

<p>
Define a function <code>transplant!</code> that takes a surgeon and two patients, gets the surgeon's specialty, and modifies the number of limbs on each patient.
</p>
</div>

<div id="outline-container-orgheadline545" class="outline-5">
<h5 id="orgheadline545">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline545">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">transplant!</span> [surgn p1 p2]
  (<span class="org-builtin">let</span> [limb (<span class="org-constant">:specialty</span> surgn)]
    (<span class="org-variable-name">swap!</span> p1 update-in [limb] dec)
    (<span class="org-variable-name">swap!</span> p2 update-in [limb] inc)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline546" class="outline-4">
<h4 id="orgheadline546">Single-threaded operation</h4>
<div class="outline-text-4" id="text-orgheadline546">
<p>
To select patients for transplant operations, our hospital randomly chooses two patients who are near each other.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">select-patients</span> []
  (<span class="org-builtin">let</span> [n1 (<span class="org-variable-name">rand</span> (<span class="org-variable-name">count</span> all-patients))
        n2 (<span class="org-variable-name">mod</span> (<span class="org-variable-name">inc</span> n1) (<span class="org-variable-name">count</span> all-patients))]
    [(<span class="org-variable-name">nth</span> all-patients n1) (<span class="org-variable-name">nth</span> all-patients n2)]))
</pre>
</div>

<p>
Each operation involves one surgeon and two patients.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">operate!</span> []
  (<span class="org-builtin">let</span> [surgn (rand-nth all-surgeons)
        [p1 p2] (select-patients)]
    (transplant! surgn p1 p2)))
</pre>
</div>

<p>
To begin with, assume there is only one operating room at the hospital. Define a function <code>run!</code> to initialize the simulation and perform 10,000 operations, then print the totals. 
</p>

<p>
Does the simulation make sense? Examine some of the patients. Does it still make sense?
</p>
</div>

<div id="outline-container-orgheadline547" class="outline-5">
<h5 id="orgheadline547">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline547">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">run!</span> []
  (init!)
  (<span class="org-builtin">dotimes</span> [_ 10000] (operate!))
  (totals))
</pre>
</div>

<p>
At the REPL:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(run!)
</pre>
</div>

<pre class="example">
;;=&gt; {:legs 2000, :arms 2000, :heads 1000}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">take</span> 10 (<span class="org-variable-name">map</span> deref all-patients))
</pre>
</div>

<pre class="example">
;;=&gt; ({:legs 2, :arms -2, :heads 2} {:legs 1, :arms 3, :heads 5} {:legs 2, :arms 2, :heads 1} {:legs 4, :arms 2, :heads 0} {:legs 1, :arms -1, :heads -1} {:legs 5, :arms 3, :heads 2} {:legs -2, :arms 5, :heads 0} {:legs 6, :arms -3, :heads -1} {:legs -1, :arms 5, :heads 4} {:legs 2, :arms 5, :heads 0})
</pre>

<p>
Some of our patients have negative numbers of limbs, which is impossible. The simulation is flawed.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline548" class="outline-4">
<h4 id="orgheadline548">Correct single-threaded operation</h4>
<div class="outline-text-4" id="text-orgheadline548">
<p>
Add a condition to the <code>transplant!</code> function that only performs the operation if the "donating" patient has the requisite limb. (You will also need to reload/redefine <code>operate!</code> and <code>run!</code>.) Run the simulation again. Is it correct?
</p>
</div>

<div id="outline-container-orgheadline549" class="outline-5">
<h5 id="orgheadline549">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline549">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">transplant!</span> [surgn p1 p2]
  (<span class="org-builtin">let</span> [limb (<span class="org-constant">:specialty</span> surgn)]
    (<span class="org-builtin">when</span> (<span class="org-variable-name">pos?</span> (@p1 limb))
     (<span class="org-variable-name">swap!</span> p1 update-in [limb] dec)
     (<span class="org-variable-name">swap!</span> p2 update-in [limb] inc))))

<span class="org-comment-delimiter">;; </span><span class="org-comment">These are the same, but need to be redefined/reloaded:</span>

(<span class="org-keyword">defn</span> <span class="org-function-name">operate!</span> []
  (<span class="org-builtin">let</span> [surgn (rand-nth all-surgeons)
        [p1 p2] (select-patients)]
    (transplant! surgn p1 p2)))

(<span class="org-keyword">defn</span> <span class="org-function-name">run!</span> []
  (init!)
  (<span class="org-builtin">dotimes</span> [_ 10000] (operate!))
  (totals))
</pre>
</div>

<p>
At the REPL:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(run!)
</pre>
</div>

<pre class="example">
;;=&gt; {:legs 2000, :arms 2000, :heads 1000}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">take</span> 10 (<span class="org-variable-name">map</span> deref all-patients))
</pre>
</div>

<pre class="example">
;;=&gt; ({:legs 2, :arms 3, :heads 1} {:legs 3, :arms 0, :heads 0} {:legs 0, :arms 3, :heads 0} {:legs 0, :arms 5, :heads 0} {:legs 4, :arms 1, :heads 1} {:legs 0, :arms 1, :heads 4} {:legs 3, :arms 1, :heads 0} {:legs 2, :arms 1, :heads 1} {:legs 4, :arms 4, :heads 1} {:legs 1, :arms 2, :heads 2})
</pre>

<p>
For the single-threaded case, the simulation is correct.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline550" class="outline-4">
<h4 id="orgheadline550">Multi-threaded operation</h4>
<div class="outline-text-4" id="text-orgheadline550">
<p>
Suppose our hospital expands to 5 operating rooms, all of which can be used at the same time. Redefine <code>run!</code> to run 10,000 operations in each operating room on its own thread. (Hint: each room is a <code>future</code>.) Wait for the threads to finish (use <code>deref</code>) then examine the results. Is the simulation correct?
</p>
</div>

<div id="outline-container-orgheadline551" class="outline-5">
<h5 id="orgheadline551">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline551">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">operating-room</span> []
  (<span class="org-variable-name">future</span>
    (<span class="org-builtin">dotimes</span> [_ 10000] (operate!))))

(<span class="org-keyword">defn</span> <span class="org-function-name">run!</span> []
  (init!)
  (<span class="org-builtin">let</span> [rooms (<span class="org-builtin">doall</span> (<span class="org-variable-name">repeatedly</span> 5 operating-room))]
    (<span class="org-builtin">dorun</span> (<span class="org-variable-name">map</span> deref rooms))
    (totals)))
</pre>
</div>

<p>
The setup here may require some explanation. The call to <code>repeatedly</code> returns a <b>lazy</b> sequence of futures. To force all the futures to start at the same time, we force the sequence to be realized with <code>doall</code>. 
</p>

<p>
Before printing the totals, we want to wait for the simulation to finish. We can block our REPL thread on each of the other threads by mapping <code>deref</code> over the sequence of futures. The <code>map</code> function is also lazy, but we don't care about the return values, so we use <code>dorun</code> to force the sequence and discard the results.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(run!)
</pre>
</div>

<pre class="example">
;;=&gt; {:legs 2000, :arms 2000, :heads 1000}
</pre>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">take</span> 10 (<span class="org-variable-name">map</span> deref all-patients))
</pre>
</div>

<pre class="example">
;;=&gt; ({:legs 1, :arms 4, :heads 0} {:legs 3, :arms 2, :heads 0} {:legs 0, :arms 0, :heads 0} {:legs 1, :arms 1, :heads 2} {:legs 4, :arms 0, :heads 1} {:legs 0, :arms 2, :heads 0} {:legs 2, :arms 3, :heads 3} {:legs 1, :arms 2, :heads 2} {:legs 4, :arms 3, :heads 0} {:legs 0, :arms 3, :heads 1})
</pre>

<p>
The simulation looks correct, but it isn't: see the next exercise.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline552" class="outline-4">
<h4 id="orgheadline552">Finding the variant</h4>
<div class="outline-text-4" id="text-orgheadline552">
<p>
Looking at a piece of multi-threaded code from the outside, it can be difficult to recognize bugs. Our current hospital simulation appears to be correct, but we're only auditing the final results, not the intermediate states. 
</p>

<p>
Let's add another thread that performs periodic audits while the operating rooms are in use. 
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">auditor</span> []
  (<span class="org-variable-name">future</span>
    (<span class="org-builtin">dotimes</span> [_ 10]
      (<span class="org-variable-name">println</span> (totals)))))

(<span class="org-keyword">defn</span> <span class="org-function-name">run!</span> []
  (init!)
  (<span class="org-variable-name">println</span> <span class="org-string">"Finding the variant:"</span>)
  (<span class="org-builtin">let</span> [audit (auditor)
        rooms (<span class="org-builtin">doall</span> (<span class="org-variable-name">repeatedly</span> 5 operating-room))]
    (<span class="org-builtin">dorun</span> (<span class="org-variable-name">map</span> deref rooms))
    (<span class="org-variable-name">deref</span> audit)))
</pre>
</div>

<p>
Examine the results. What is wrong?
</p>
</div>

<div id="outline-container-orgheadline553" class="outline-5">
<h5 id="orgheadline553">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline553">
<p>
The simulation prints something like this:
</p>

<div class="org-src-container">

<pre class="src src-clojure">{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 1998, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2002, <span class="org-constant">:heads</span> 1001}
{<span class="org-constant">:legs</span> 2001, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1001}
{<span class="org-constant">:legs</span> 1999, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1001}
{<span class="org-constant">:legs</span> 1999, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1001}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 1999, <span class="org-constant">:arms</span> 1999, <span class="org-constant">:heads</span> 999}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 1998, <span class="org-constant">:heads</span> 1000}
</pre>
</div>

<p>
Notice that the number of arms, legs, and heads is not always consistent. When we look at the patients while the simulation is running, sometimes we catch them in the middle of an operation, when a limb has been removed from one patient but not yet added to the other. This makes it hard to be certain that we always have the correct number of arms, legs, and heads.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline554" class="outline-4">
<h4 id="orgheadline554">Refs for coordination</h4>
<div class="outline-text-4" id="text-orgheadline554">
<p>
The problem with our simulation is that each operation involves two patients. We want the state to be consistent across both entities, so Atoms are not sufficient.
</p>

<p>
Rewrite the <code>patient</code> and <code>transplant!</code> functions using Refs instead of Atoms. (You will also need to reload/redefine <code>all-patients</code> and <code>operate!</code>.) Run the simulation again. Is it correct?
</p>
</div>

<div id="outline-container-orgheadline555" class="outline-5">
<h5 id="orgheadline555">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline555">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">patient</span> []
  (<span class="org-variable-name">ref</span> {<span class="org-constant">:arms</span> 2
        <span class="org-constant">:legs</span> 2
        <span class="org-constant">:heads</span> 1}))

(<span class="org-keyword">defn</span> <span class="org-function-name">transplant!</span> [surgn p1 p2]
  (<span class="org-builtin">let</span> [limb (<span class="org-constant">:specialty</span> surgn)]
    (<span class="org-builtin">dosync</span>
     (<span class="org-builtin">when</span> (<span class="org-variable-name">pos?</span> (@p1 limb))
       (<span class="org-variable-name">alter</span> p1 update-in [limb] dec)
       (<span class="org-variable-name">alter</span> p2 update-in [limb] inc)))))

<span class="org-comment-delimiter">;; </span><span class="org-comment">These are the same, but must be reloaded/redefined: </span>

(<span class="org-keyword">defn</span> <span class="org-function-name">init-patients</span> []
  (<span class="org-variable-name">vec</span> (<span class="org-variable-name">repeatedly</span> 1000 patient)))

(<span class="org-keyword">defn</span> <span class="org-function-name">init!</span> []
  (<span class="org-variable-name">alter-var-root</span> #'all-patients (<span class="org-variable-name">constantly</span> (init-patients)))
  (<span class="org-variable-name">alter-var-root</span> #'all-surgeons (<span class="org-variable-name">constantly</span> (init-surgeons))))

(<span class="org-keyword">defn</span> <span class="org-function-name">operate!</span> []
  (<span class="org-builtin">let</span> [surgn (rand-nth all-surgeons)
        [p1 p2] (select-patients)]
    (transplant! surgn p1 p2)))

(<span class="org-keyword">defn</span> <span class="org-function-name">run!</span> []
  (init!)
  (<span class="org-variable-name">println</span> <span class="org-string">"Refs for coordination:"</span>)
  (<span class="org-builtin">let</span> [audit (auditor)
        rooms (<span class="org-builtin">doall</span> (<span class="org-variable-name">repeatedly</span> 5 operating-room))]
    (<span class="org-builtin">dorun</span> (<span class="org-variable-name">map</span> deref rooms))
    (<span class="org-variable-name">deref</span> audit)))
</pre>
</div>

<p>
The simulation prints something like:
</p>

<div class="org-src-container">

<pre class="src src-clojure">{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2001, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 1998, <span class="org-constant">:arms</span> 1999, <span class="org-constant">:heads</span> 1001}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 1999, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2001, <span class="org-constant">:arms</span> 1998, <span class="org-constant">:heads</span> 999}
{<span class="org-constant">:legs</span> 2001, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1001}
{<span class="org-constant">:legs</span> 1999, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
</pre>
</div>

<p>
It's still not correct: see the next exercise.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline556" class="outline-4">
<h4 id="orgheadline556">Reading in transactions</h4>
<div class="outline-text-4" id="text-orgheadline556">
<p>
Although the last exercise fixed the simulation to perform all its state changes inside transactions, the <code>totals</code> function is <b>not</b> running in a transaction. It just zips through all the patients, dereferencing one at a time. There is no guarantee that those values, read at different times, will present a consistent view of the world.
</p>

<p>
If we want our audits to give consistent results, we need to do them in transactions as well. Modify the <code>totals</code> function to run in its own transaction. (You will also need to reload/redefine <code>run!</code>.) Check that the results are what you expect.
</p>
</div>

<div id="outline-container-orgheadline557" class="outline-5">
<h5 id="orgheadline557">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline557">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">totals</span> []
  (<span class="org-builtin">dosync</span>
   (<span class="org-variable-name">reduce</span> (<span class="org-variable-name">partial</span> merge-with +)
           (<span class="org-variable-name">map</span> deref all-patients))))

(<span class="org-keyword">defn</span> <span class="org-function-name">run!</span> [] <span class="org-comment">; the same, but must reload/redefine</span>
  (init!)
  (<span class="org-variable-name">println</span> <span class="org-string">"Reading in transactions:"</span>)
  (<span class="org-builtin">let</span> [audit (auditor)
        rooms (<span class="org-builtin">doall</span> (<span class="org-variable-name">repeatedly</span> 5 operating-room))]
    (<span class="org-builtin">dorun</span> (<span class="org-variable-name">map</span> deref rooms))
    (<span class="org-variable-name">deref</span> audit)))
</pre>
</div>

<p>
Results:
</p>

<div class="org-src-container">

<pre class="src src-clojure">{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
{<span class="org-constant">:legs</span> 2000, <span class="org-constant">:arms</span> 2000, <span class="org-constant">:heads</span> 1000}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline558" class="outline-4">
<h4 id="orgheadline558">Introducing Agents</h4>
<div class="outline-text-4" id="text-orgheadline558">
<p>
Our simulation is still flawed in one respect: each operation selects a surgeon at random, but in reality a surgeon cannot be in two places at once. Let's implement that fact by turning surgeons into Agents.
</p>

<p>
Rewrite the <code>surgeon</code> function to create each surgeon as an Agent. Rewrite the <code>transplant!</code> function as an Agent action: the surgeon's state will be its first argument, and it must return that same state. Patients will still be Refs.
</p>

<p>
Then modify the <code>operate!</code> function to dispatch operations to surgeons with <code>send</code>.
</p>

<p>
Finally, re-run the simulation. This time, instead of creating futures for each operating room, just call <code>operate!</code> 10,000 times. Wait for all the surgeons to finish (call <code>await</code> on the Agents). Continue to use <code>future</code> for printing periodic audits. 
</p>

<p>
Can you describe what is happening here? How many operations can be taking place simultaneously?
</p>
</div>

<div id="outline-container-orgheadline559" class="outline-5">
<h5 id="orgheadline559">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline559">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">surgeon</span> [specialty]
  (<span class="org-variable-name">agent</span> {<span class="org-constant">:specialty</span> specialty}))

(<span class="org-keyword">defn</span> <span class="org-function-name">init-surgeons</span> []  <span class="org-comment">; the same, must reload/redefine</span>
  (<span class="org-variable-name">vec</span> (<span class="org-variable-name">take</span> 100 (<span class="org-variable-name">map</span> surgeon (<span class="org-variable-name">cycle</span> [<span class="org-constant">:arms</span> <span class="org-constant">:legs</span> <span class="org-constant">:heads</span>])))))

(<span class="org-keyword">defn</span> <span class="org-function-name">init!</span> []  <span class="org-comment">; the same, must reload/redefine</span>
  (<span class="org-variable-name">alter-var-root</span> #'all-patients (<span class="org-variable-name">constantly</span> (init-patients)))
  (<span class="org-variable-name">alter-var-root</span> #'all-surgeons (<span class="org-variable-name">constantly</span> (init-surgeons))))

(<span class="org-keyword">defn</span> <span class="org-function-name">transplant!</span> [surgn-state p1 p2]
  (<span class="org-builtin">let</span> [limb (<span class="org-constant">:specialty</span> surgn-state)]
    (<span class="org-builtin">dosync</span>
     (<span class="org-builtin">when</span> (<span class="org-variable-name">pos?</span> (@p1 limb))
       (<span class="org-variable-name">alter</span> p1 update-in [limb] dec)
       (<span class="org-variable-name">alter</span> p2 update-in [limb] inc))))
  surgn-state)  <span class="org-comment">; must return state</span>

(<span class="org-keyword">defn</span> <span class="org-function-name">operate!</span> []
  (<span class="org-builtin">let</span> [surgn (rand-nth all-surgeons)
        [p1 p2] (select-patients)]
    (<span class="org-variable-name">send</span> surgn transplant! p1 p2)))

(<span class="org-keyword">defn</span> <span class="org-function-name">run!</span> []
  (init!)
  (<span class="org-variable-name">println</span> <span class="org-string">"Introducing Agents:"</span>)
  (<span class="org-builtin">let</span> [audit (auditor)]
    (<span class="org-builtin">dotimes</span> [_ 10000] (operate!))
    (<span class="org-variable-name">apply</span> await all-surgeons)
    (<span class="org-variable-name">deref</span> audit)))
</pre>
</div>

<p>
The number of simultaneous operations depends on your definition of "simultaneous." The size of the Agent thread pool is bounded by the number of available CPU cores plus two (a common rule-of-thumb). So on a four-core system, there are up to six threads performing operations. But there are still only four cores to do the work, and we have that <code>future</code> running in the background on its own thread. So how many operations can happen at once? Theoretically, up to four, but we'll never really know. At this point we have given up control and must put our trust in Clojure, the Java Virtual Machine, the operating system, and our hardware, all of which have been optimized to make efficient use of computational resources.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline560" class="outline-3">
<h3 id="orgheadline560">Names and Namespaces&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-orgheadline560">
</div>

<div id="outline-container-orgheadline561" class="outline-4">
<h4 id="orgheadline561">What is a Namespace?&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline561">
<ul class="org-ul">
<li>Conceptual Version
<ul class="org-ul">
<li>A way to disambiguate names</li>
</ul></li>

<li>Concrete Version
<ul class="org-ul">
<li>Mappings from <i>symbols</i> to
<ul class="org-ul">
<li>Vars</li>
<li>Java classes</li>
<li>Aliases to other namespaces</li>
</ul></li>
</ul></li>
</ul>
</div>

<div id="outline-container-orgheadline562" class="outline-5">
<h5 id="orgheadline562">What is a Var?&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline562">
<ul class="org-ul">
<li>An association between a <i>symbol</i> and a <i>value</i></li>
<li><code>def</code>
<ul class="org-ul">
<li>Creates a new Var in the current namespace</li>
<li>Optionally creates <i>root binding</i> to a value</li>
</ul></li>
<li><code>defn</code>
<ul class="org-ul">
<li>Shortcut for <code>def</code> + <code>fn</code></li>
<li>Creates a new Var whose value is a function</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline563" class="outline-5">
<h5 id="orgheadline563">What is a Symbol?&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline563">
<ul class="org-ul">
<li>Just a label
<ul class="org-ul">
<li>A name <i>string</i></li>
<li>With an optional namespace <i>string</i></li>
</ul></li>
<li>Has no value</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">foo       <span class="org-comment">; Unqualified symbol</span>
bar/foo   <span class="org-comment">; Namespace-qualified symbol</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline567" class="outline-4">
<h4 id="orgheadline567">Creating Namespaces&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline567">
</div><div id="outline-container-orgheadline564" class="outline-5">
<h5 id="orgheadline564"><code>ns</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline564">
<ul class="org-ul">
<li>At the top of every source file</li>
<li>Creates a namespace</li>
<li>Automatically refers all of <code>clojure.core</code></li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">ns</span> com.some-example.my-app)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline565" class="outline-5">
<h5 id="orgheadline565">Names into Files&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline565">
<ul class="org-ul">
<li>Dots become directory separators</li>
<li>Hyphens become underscores</li>
<li>Add <code>.clj</code> on the end</li>
<li>Find on the CLASSPATH</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">in file $CLASSPATH/com/some_example/my_app.clj</span>
(<span class="org-builtin">ns</span> com.some-example.my-app)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline566" class="outline-5">
<h5 id="orgheadline566">The JVM Classpath&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline566">
<ul class="org-ul">
<li>Where to find code to load</li>
<li>List of directories and JAR files</li>
<li>Specified when launching the JVM
<ul class="org-ul">
<li>Cannot be changed (normally)</li>
</ul></li>
<li>Managed by tools such as Leiningen</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">Show the classpath</span>
(<span class="org-preprocessor">System/getProperty</span> <span class="org-string">"java.class.path"</span>)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline568" class="outline-4">
<h4 id="orgheadline568">Namespace Operations&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline568">
<ul class="org-ul">
<li>Load <i>(require)</i></li>
<li>Copy <i>(refer)</i> symbol→Var mappings</li>
<li>Make a shortcut <i>(alias)</i></li>
</ul>
</div>

<div id="outline-container-orgheadline569" class="outline-5">
<h5 id="orgheadline569"><code>ns :require</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline569">
<ul class="org-ul">
<li>Loads a namespace</li>
<li>Optionally
<ul class="org-ul">
<li>Provides an alias</li>
<li>Refers some symbols</li>
</ul></li>
<li>Never loads the same code twice</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline570" class="outline-5">
<h5 id="orgheadline570"><code>ns :require</code> Example&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline570">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">ns</span> com.some-example.my-app
  (<span class="org-constant">:require</span> clojure.string
            [clojure.set <span class="org-constant">:as</span> set]
            [clojure.java.io <span class="org-constant">:refer</span> (file reader)]))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline571" class="outline-5">
<h5 id="orgheadline571"><code>ns :require</code> Bare&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline571">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">ns</span> ... (<span class="org-constant">:require</span> clojure.string ...))
</pre>
</div>

<ul class="org-ul">
<li>Element inside <code>(:require ...)</code> is a symbol</li>
<li>Just load the code</li>
<li>Vars available as fully-qualified symbols
<ul class="org-ul">
<li>e.g. <code>clojure.string/replace</code></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline572" class="outline-5">
<h5 id="orgheadline572"><code>ns :require :as</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline572">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">ns</span> ... (<span class="org-constant">:require</span> [clojure.set <span class="org-constant">:as</span> set] ...))
</pre>
</div>

<ul class="org-ul">
<li>Element inside <code>(:require ...)</code> is a vector
<ul class="org-ul">
<li>Like <code>[<i style='font-family:serif'>name</i> :as <i style='font-family:serif'>alias</i>]</code></li>
</ul></li>
<li>Load code and create an alias</li>
<li>Vars available under shorter alias
<ul class="org-ul">
<li>e.g. <code>set/union</code></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline573" class="outline-5">
<h5 id="orgheadline573"><code>ns :require :refer</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline573">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">ns</span> ... (<span class="org-constant">:require</span> [clojure.java.io <span class="org-constant">:refer</span> (file reader)] ...))
</pre>
</div>

<ul class="org-ul">
<li>Element inside <code>(:require ...)</code> is a vector
<ul class="org-ul">
<li>Like <code>[<i style='font-family:serif'>name</i> :refer (<i style='font-family:serif'>symbols+</i>)]</code></li>
</ul></li>
<li>Load code and copy symbol→Var bindings</li>
<li>Vars available without namespace qualification
<ul class="org-ul">
<li>e.g. <code>reader</code></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline574" class="outline-5">
<h5 id="orgheadline574"><code>ns :use :only</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline574">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">ns</span> ... (<span class="org-constant">:use</span> [clojure.java.io <span class="org-constant">:only</span> (file reader)] ...))
</pre>
</div>

<ul class="org-ul">
<li>Older (pre-1.4) form of <code>:require :refer</code></li>
<li><code>(:use ...)</code> instead of <code>(:require ...)</code></li>
<li>Element inside <code>(:use ...)</code> is a vector
<ul class="org-ul">
<li>Like <code>[<i style='font-family:serif'>name</i> :only (<i style='font-family:serif'>symbols+</i>)]</code></li>
</ul></li>
<li>Vars available without namespace qualification
<ul class="org-ul">
<li>e.g. <code>reader</code></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline575" class="outline-5">
<h5 id="orgheadline575"><code>ns :import</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline575">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">ns</span> com.some-example.my-app
  (<span class="org-constant">:import</span> <span class="org-preprocessor">java.io.File</span>
           (java.util <span class="org-preprocessor">Map</span> <span class="org-preprocessor">List</span> <span class="org-preprocessor">Map$Entry</span>)))
</pre>
</div>

<ul class="org-ul">
<li>Element inside <code>(:import ...)</code> is
<ul class="org-ul">
<li>A package-qualified class name</li>
<li>Or a list like <code>(<i style='font-family:serif'>package</i> <i style='font-family:serif'>classes+</i>)</code></li>
</ul></li>
<li>Java "inner classes" are named <code>Outer$Inner</code></li>
<li>Every namespace automatically imports <code>java.lang</code></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline583" class="outline-4">
<h4 id="orgheadline583">Namespaces at the REPL&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline583">
</div><div id="outline-container-orgheadline576" class="outline-5">
<h5 id="orgheadline576">Where am I?&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline576">
<ul class="org-ul">
<li><code>*ns*</code> is the current namespace</li>
<li><code>in-ns</code> switches namespaces
<ul class="org-ul">
<li>Takes a <i>symbol</i> (quoted)</li>
<li>Creates namespace if it doesn't exist</li>
<li>Does <i>not</i> automatically refer <code>clojure.core</code> like <code>ns</code></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline577" class="outline-5">
<h5 id="orgheadline577"><code>in-ns</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline577">
<div class="org-src-container">

<pre class="src src-clojure">user=&gt; (<span class="org-builtin">in-ns</span> 'never-before-seen)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #&lt;Namespace never-before-seen&gt;</span>

never-before-seen=&gt; (<span class="org-variable-name">println</span> <span class="org-string">"This won't work"</span>)
<span class="org-comment-delimiter">;; </span><span class="org-comment">CompilerException java.lang.RuntimeException:</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Unable to resolve symbol: println in this context</span>

never-before-seen=&gt; (clojure.core/<span class="org-variable-name">println</span> <span class="org-string">"This will"</span>)
<span class="org-comment-delimiter">;; </span><span class="org-comment">This will</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; nil</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline578" class="outline-5">
<h5 id="orgheadline578"><code>require</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline578">
<ul class="org-ul">
<li><code>require</code> is also a function</li>
<li>Same syntax as in <code>(ns ... (:require ...))</code>
<ul class="org-ul">
<li>But <code>require</code> is not a keyword</li>
<li>Arguments must be <i>quoted</i> to prevent evaluation</li>
</ul></li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">user=&gt; (<span class="org-variable-name">require</span> clojure.set)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; CompilerException java.lang.ClassNotFoundException: clojure.set</span>
user=&gt; (<span class="org-variable-name">require</span> '[clojure.set <span class="org-constant">:as</span> set])
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; nil</span>
user=&gt; (set/<span class="org-type">union</span> #{1 3} #{2 4})
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #{1 4 2 3}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline579" class="outline-5">
<h5 id="orgheadline579"><code>require :reload</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline579">
<ul class="org-ul">
<li><code>require</code> never loads the same file twice</li>
<li>To get new definitions, add <code>:reload</code> flag</li>
<li><code>:reload-all</code> will recursively reload dependencies</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">require</span> 'com.example <span class="org-constant">:reload</span>)
(<span class="org-variable-name">require</span> 'com.example.myapp <span class="org-constant">:reload-all</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline580" class="outline-5">
<h5 id="orgheadline580"><code>import</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline580">
<ul class="org-ul">
<li><code>import</code> is also a macro</li>
<li>Same syntax as in <code>(ns ... (:import ...))</code>
<ul class="org-ul">
<li>But <code>import</code> is not a keyword</li>
<li>Arguments do <i>not</i> need to be quoted</li>
</ul></li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">user=&gt; (<span class="org-builtin">import</span> (java.util <span class="org-preprocessor">Random</span>))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; java.util.Random</span>
user=&gt; (<span class="org-preprocessor">.nextInt</span> (<span class="org-preprocessor">Random.</span>))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; -1547790708</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline581" class="outline-5">
<h5 id="orgheadline581">Namespace Concepts&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline581">
<p>Click on the image to view full-size in a new window (in browsers that support SVG).</p>
<a href="slide-assets/namespaces-total.svg" target="_blank">
  <img src="slide-assets/namespaces-total.svg" width="967" height="215" />
</a>
</div>
</div>

<div id="outline-container-orgheadline582" class="outline-5">
<h5 id="orgheadline582">File vs REPL&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline582">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">In a source file                  ;; At the REPL</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">------------------------------    ;; -------------------</span>
(<span class="org-builtin">ns</span> foo)                             (<span class="org-builtin">in-ns</span> 'foo)

(<span class="org-builtin">ns</span> foo (<span class="org-constant">:require</span> bar))              (<span class="org-variable-name">require</span> 'bar)
(<span class="org-builtin">ns</span> foo (<span class="org-constant">:require</span> [bar <span class="org-constant">:as</span> b]))      (<span class="org-variable-name">require</span> '[bar <span class="org-constant">:as</span> b])

(<span class="org-builtin">ns</span> foo (<span class="org-constant">:import</span> (java.io <span class="org-preprocessor">File</span>)))    (<span class="org-builtin">import</span> (java.io <span class="org-preprocessor">File</span>))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline588" class="outline-4">
<h4 id="orgheadline588">Examining Symbols &amp; Namespaces&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline588">
</div><div id="outline-container-orgheadline584" class="outline-5">
<h5 id="orgheadline584">Examining &amp; Creating Symbols&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline584">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">name</span> 'com.example/foo)       <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "foo"</span>
(<span class="org-variable-name">namespace</span> 'com.example/foo)  <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "com.example"</span>
(<span class="org-variable-name">namespace</span> 'foo)              <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; nil</span>

(<span class="org-variable-name">symbol</span> <span class="org-string">"foo"</span>)                <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; foo</span>
(<span class="org-variable-name">symbol</span> <span class="org-string">"com.example"</span> <span class="org-string">"foo"</span>)  <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; com.example/foo</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline585" class="outline-5">
<h5 id="orgheadline585">Finding Namespaces&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline585">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">Doesn't work:</span>
user=&gt; clojure.set
<span class="org-comment-delimiter">;; </span><span class="org-comment">CompilerException java.lang.ClassNotFoundException: clojure.set</span>

user=&gt; (<span class="org-variable-name">find-ns</span> 'clojure.set)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #&lt;Namespace clojure.set&gt;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline586" class="outline-5">
<h5 id="orgheadline586">Viewing Namespace Mappings&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline586">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left">Returns map of symbols to &#x2026;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">&nbsp; <code>ns-map</code></td>
<td class="org-left">all Vars and classes</td>
</tr>

<tr>
<td class="org-left">&nbsp; → <code>ns-interns</code></td>
<td class="org-left">all Vars created in this namespace</td>
</tr>

<tr>
<td class="org-left">&nbsp; → → <code>ns-publics</code></td>
<td class="org-left">all <b>public</b> Vars in this namespace</td>
</tr>

<tr>
<td class="org-left">&nbsp; → <code>ns-refers</code></td>
<td class="org-left"><b>referred</b> Vars from other namespaces</td>
</tr>

<tr>
<td class="org-left">&nbsp; → <code>ns-imports</code></td>
<td class="org-left">Java classes</td>
</tr>

<tr>
<td class="org-left">&nbsp; <code>ns-aliases</code></td>
<td class="org-left">aliased namespaces</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgheadline587" class="outline-5">
<h5 id="orgheadline587">Viewing Namespace Mappings&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline587">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">ns-map</span> 'user)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; {Runtime java.lang.Runtime</span>
<span class="org-comment-delimiter">;;    </span><span class="org-comment">keep    #'clojure.core/keep</span>
<span class="org-comment-delimiter">;;    </span><span class="org-comment">...}</span>

(<span class="org-variable-name">ns-aliases</span> 'user)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; {set #&lt;Namespace clojure.set&gt;}</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline589" class="outline-4">
<h4 id="orgheadline589">Private Vars&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline589">
<ul class="org-ul">
<li>Add <code>^:private</code> metadata to def'd symbol
<ul class="org-ul">
<li><code>defn-</code> is shortcut for private fn</li>
</ul></li>
<li>Prevents accidental refer</li>
<li>Prevents accidental use by qualified symbol</li>
<li>Not truly hidden, can expose by deref'ing Var</li>
</ul>
</div>

<div id="outline-container-orgheadline590" class="outline-5">
<h5 id="orgheadline590">Private Vars Example&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline590">
<div class="org-src-container">

<pre class="src src-clojure">user=&gt; (<span class="org-keyword">def</span> <span class="org-constant">^:private</span> <span class="org-function-name">secret</span> <span class="org-string">"trustno1"</span>)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #'user/secret</span>

user=&gt; (<span class="org-builtin">in-ns</span> 'foo.bar)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; nil</span>

foo.bar=&gt; user/secret
<span class="org-comment-delimiter">;; </span><span class="org-comment">CompilerException: user/secret is not public</span>

foo.bar=&gt; @#'user/secret   <span class="org-comment">; deref the Var</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "trustno1"</span>
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline591" class="outline-3">
<h3 id="orgheadline591">LAB: Namespaces&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-orgheadline591">
</div>

<div id="outline-container-orgheadline592" class="outline-4">
<h4 id="orgheadline592">Entering a namespace</h4>
<div class="outline-text-4" id="text-orgheadline592">
<p>
At the REPL, use <code>in-ns</code> to enter a new namespace <code>alpha</code>.
</p>
</div>

<div id="outline-container-orgheadline593" class="outline-5">
<h5 id="orgheadline593">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline593">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">in-ns</span> 'alpha)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline594" class="outline-4">
<h4 id="orgheadline594">An empty namespace</h4>
<div class="outline-text-4" id="text-orgheadline594">
<p>
In the <code>alpha</code> namespace, try to call a common function like <code>println</code>. Why doesn't it work?
</p>
</div>

<div id="outline-container-orgheadline595" class="outline-5">
<h5 id="orgheadline595">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline595">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">println</span> <span class="org-string">"Hello, World!"</span>)
<span class="org-comment-delimiter">;; </span><span class="org-comment">RuntimeException Unable to resolve</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">symbol: println in this context</span>
</pre>
</div>

<p>
The <code>println</code> function is defined in the <code>clojure.core</code> namespace, which is not automatically referred into new namespaces by <code>in-ns</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline596" class="outline-4">
<h4 id="orgheadline596">Getting to the core</h4>
<div class="outline-text-4" id="text-orgheadline596">
<p>
In the <code>alpha</code> namespace, call the <code>println</code> function correctly.
</p>
</div>

<div id="outline-container-orgheadline597" class="outline-5">
<h5 id="orgheadline597">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline597">
<div class="org-src-container">

<pre class="src src-clojure">(clojure.core/<span class="org-variable-name">println</span> <span class="org-string">"Hello, World!"</span>)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline598" class="outline-4">
<h4 id="orgheadline598">A less empty namespace</h4>
<div class="outline-text-4" id="text-orgheadline598">
<p>
Create a new namespace <code>beta</code> using <code>ns</code>. Try calling a common function like <code>println</code>. Why does it work now?
</p>
</div>

<div id="outline-container-orgheadline599" class="outline-5">
<h5 id="orgheadline599">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline599">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">ns</span> beta)

(<span class="org-variable-name">println</span> <span class="org-string">"Hello, World!"</span>)
</pre>
</div>

<p>
<code>ns</code> automatically refers all symbols from <code>clojure.core</code> into the new namespace.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline600" class="outline-4">
<h4 id="orgheadline600">File it away</h4>
<div class="outline-text-4" id="text-orgheadline600">
<p>
Create a new Clojure source file for the namespace <code>student.dialect</code>, with the appropriate <code>ns</code> declaration.
</p>

<p>
In this file, define a function <code>canadianize</code> that takes a string and appends ", eh?"
</p>
</div>

<div id="outline-container-orgheadline601" class="outline-5">
<h5 id="orgheadline601">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline601">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">in $CLASSPATH/student/dialect.clj</span>
(<span class="org-builtin">ns</span> student.dialect)

(<span class="org-keyword">defn</span> <span class="org-function-name">canadianize</span> [sentence]
  (<span class="org-variable-name">str</span> sentence <span class="org-string">", eh?"</span>))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline602" class="outline-4">
<h4 id="orgheadline602">Loading from files</h4>
<div class="outline-text-4" id="text-orgheadline602">
<p>
In the REPL, load your new namespace and call the <code>canadianize</code> function.
</p>
</div>

<div id="outline-container-orgheadline603" class="outline-5">
<h5 id="orgheadline603">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline603">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">require</span> 'student.dialect)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-clojure">(student.dialect/canadianize <span class="org-string">"Nice weather today."</span>)
</pre>
</div>

<pre class="example">
;;=&gt; "Nice weather today., eh?"
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline604" class="outline-4">
<h4 id="orgheadline604">Modifying sources</h4>
<div class="outline-text-4" id="text-orgheadline604">
<p>
Modify your source file to make the <code>clojure.string</code> namespace available under the alias <code>str</code> in the <code>student.dialect</code> namespace.
</p>

<p>
Modify the <code>canadianize</code> function to strip a trailing period off its input.  Use <code>clojure.string/replace</code>. 
</p>
</div>

<div id="outline-container-orgheadline605" class="outline-5">
<h5 id="orgheadline605">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline605">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">in $CLASSPATH/student/dialect.clj</span>
(<span class="org-builtin">ns</span> student.dialect
  (<span class="org-constant">:require</span> [clojure.string <span class="org-constant">:as</span> str]))

(<span class="org-keyword">defn</span> <span class="org-function-name">canadianize</span>
  [sentence]
  (str/<span class="org-type">replace</span> sentence #<span class="org-string">"\.$"</span> <span class="org-string">", eh?"</span>))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline606" class="outline-4">
<h4 id="orgheadline606">Reloading</h4>
<div class="outline-text-4" id="text-orgheadline606">
<p>
In the REPL, reload your source file and call the improved <code>canadianize</code> function.
</p>
</div>

<div id="outline-container-orgheadline607" class="outline-5">
<h5 id="orgheadline607">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline607">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">require</span> 'student.dialect <span class="org-constant">:reload</span>)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-clojure">(student.dialect/canadianize <span class="org-string">"Nice weather today."</span>)
</pre>
</div>

<pre class="example">
;;=&gt; "Nice weather today, eh?"
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline608" class="outline-3">
<h3 id="orgheadline608">Spec&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-orgheadline608">
</div>

<div id="outline-container-orgheadline614" class="outline-4">
<h4 id="orgheadline614">clojure.spec&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline614">
</div><div id="outline-container-orgheadline609" class="outline-5">
<h5 id="orgheadline609">Overview&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h5>
</div>

<div id="outline-container-orgheadline610" class="outline-5">
<h5 id="orgheadline610">Outline&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline610">
<ul class="org-ul">
<li>Why spec?</li>
<li>Predicates</li>
<li>Composite specs</li>
<li>Collection specs</li>
<li>Functions and Testing</li>
<li>Regex syntax specs</li>
<li>Generators</li>
</ul>
</div>

<div id="outline-container-orgheadline611" class="outline-6">
<h6 id="orgheadline611">Systemic generality&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline611">
<ul class="org-ul">
<li>Clojure allows us to use a small number of general data structures
and operations on those structures everywhere</li>
<li>However, that means the structure of the data is more implicit</li>
<li>spec allows us to talk concretely about our data and our functions</li>
<li>Without giving up our system generality</li>
<li>And how much you use it is up to you</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline612" class="outline-6">
<h6 id="orgheadline612">Attributes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline612">
<ul class="org-ul">
<li>Predicate based (uses existing language)</li>
<li>Declarative / structural</li>
<li>Optional (use what and how much you want)</li>
<li>Compositional</li>
<li>Logic based
<ul class="org-ul">
<li>Set logic for maps of attributes</li>
<li>Regex for sequential syntax</li>
</ul></li>
<li>Generative from the start</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline613" class="outline-6">
<h6 id="orgheadline613">Leverage&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline613">
<ul class="org-ul">
<li>Validation (does value match spec)</li>
<li>Conformance (why was value valid)</li>
<li>Explain (why was value invalid)</li>
<li>Docs</li>
<li>Examples</li>
<li>Instrumentation (was fn invoked correctly)</li>
<li>Generative testing</li>
<li>Assertions</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline627" class="outline-4">
<h4 id="orgheadline627">Predicates&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline627">
</div><div id="outline-container-orgheadline615" class="outline-5">
<h5 id="orgheadline615">Predicates&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline615">
<ul class="org-ul">
<li>specs are built from predicates</li>
<li>predicate: function that takes a value and returns logical true or false</li>
<li>Predicates can be:
<ul class="org-ul">
<li>existing predicate functions</li>
<li>sets (which act as functions of their elements)</li>
<li>anonymous functions</li>
</ul></li>
<li>Find predicates: <code>(find-doc #"\?$")</code></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline616" class="outline-5">
<h5 id="orgheadline616">Spec setup&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline616">
<ul class="org-ul">
<li>To include at your repl:</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">require</span> '[clojure.spec.alpha <span class="org-constant">:as</span> s]
         '[clojure.spec.gen.alpha <span class="org-constant">:as</span> gen]
         '[clojure.spec.test.alpha <span class="org-constant">:as</span> stest])
</pre>
</div>

<ul class="org-ul">
<li>To include in a namespace:</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">ns</span> foo
  (<span class="org-constant">:require</span> [clojure.spec.alpha <span class="org-constant">:as</span> s]
            [clojure.spec.gen.alpha <span class="org-constant">:as</span> gen]
            [clojure.spec.test.alpha <span class="org-constant">:as</span> stest]))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline617" class="outline-5">
<h5 id="orgheadline617">Validating with predicates&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline617">
<ul class="org-ul">
<li>Check whether a value satisfies a pred</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/valid? int? 10)        <span class="org-comment-delimiter">;; </span><span class="org-comment">true</span>
(s/valid? int? nil)       <span class="org-comment-delimiter">;; </span><span class="org-comment">false</span>
(s/valid? string? <span class="org-string">"abc"</span>)  <span class="org-comment-delimiter">;; </span><span class="org-comment">true</span>
(s/valid? #{1 2 3} 3)     <span class="org-comment-delimiter">;; </span><span class="org-comment">true</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline618" class="outline-5">
<h5 id="orgheadline618">Conformance&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline618">
<ul class="org-ul">
<li><code>s/conform</code> tells you <b>how</b> a value conforms to a spec</li>
<li>We'll see later how this can be used to understand why a value is
valid for a spec with alternatives</li>
<li>Predicates conform to the original value</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/conform int? 10)  <span class="org-comment-delimiter">;; </span><span class="org-comment">10</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline619" class="outline-5">
<h5 id="orgheadline619">Generators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline619">
<ul class="org-ul">
<li>Many core predicates are mapped to sample generators</li>
<li><code>s/exercise</code> can be used to generate and conform spec values</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/exercise int?)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; ([0 0] [0 0] [0 0] [-2 -2] [0 0] [1 1] [7 7] [-1 -1] [0 0] [2 2])</span>

(s/exercise string?)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; (["" ""] ["I5" "I5"] ["9c" "9c"] ["dg" "dg"] ["Orp6p" "Orp6p"])</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline620" class="outline-5">
<h5 id="orgheadline620">Enumerated values&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline620">
<ul class="org-ul">
<li>Sets match all elements of the set</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/valid? #{1 2 3} 3)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; true</span>
(s/conform #{1 2 3} 3)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 3</span>
(s/exercise #{1 2 3})
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; ([3 3] [2 2] [3 3] [2 2] [3 3] [2 2] [2 2] [3 3] [1 1] [3 3])</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline621" class="outline-5">
<h5 id="orgheadline621">Including nil&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline621">
<ul class="org-ul">
<li>Most predicates do not accept nil</li>
<li>Use s/nilable to extend a predicate to include nil</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/valid? int? nil)              <span class="org-comment-delimiter">;; </span><span class="org-comment">false</span>
(s/valid? (s/nilable int?) nil)  <span class="org-comment-delimiter">;; </span><span class="org-comment">true</span>
(s/valid? (s/nilable #{1 2}) nil) <span class="org-comment-delimiter">;; </span><span class="org-comment">true</span>
</pre>
</div>

<ul class="org-ul">
<li>Do NOT use a set that contains false or nil:</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/valid? #{true false nil} false) <span class="org-comment-delimiter">;; </span><span class="org-comment">false</span>
</pre>
</div>

<ul class="org-ul">
<li>Instead use s/nilable or write a predicate:</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/valid? (s/nilable boolean?) nil) <span class="org-comment-delimiter">;; </span><span class="org-comment">true</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline622" class="outline-5">
<h5 id="orgheadline622">Anonymous functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline622">
<ul class="org-ul">
<li>Any anonymous function can also be used as a predicate</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/valid? #(<span class="org-variable-name">=</span> 10 (<span class="org-variable-name">reduce</span> + %)) [2 2 6]) <span class="org-comment-delimiter">;; </span><span class="org-comment">true</span>
</pre>
</div>

<ul class="org-ul">
<li>Or you can pull it out to a function:</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">sums-to</span> [x coll] (<span class="org-variable-name">=</span> x (<span class="org-variable-name">reduce</span> + coll)))
(s/valid? (<span class="org-variable-name">partial</span> sums-to 10) [2 2 6]) <span class="org-comment-delimiter">;; </span><span class="org-comment">true</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline623" class="outline-5">
<h5 id="orgheadline623">Value ranges&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline623">
<ul class="org-ul">
<li>Several specs exist for checking value ranges</li>
<li><code>s/int-in</code> - for integer ranges</li>
<li><code>s/double-in</code> - for double ranges</li>
<li><code>s/inst-in</code> - for instant ranges</li>
</ul>
</div>

<div id="outline-container-orgheadline624" class="outline-6">
<h6 id="orgheadline624">Integer range&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline624">
<ul class="org-ul">
<li><code>s/int-in</code> - ints from begin (inclusive) to end (exclusive)</li>
<li>Generates ints uniformly across that range</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/valid? (s/int-in 0 10) 5)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; true</span>

(s/exercise (s/int-in 0 10))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; ([1 1] [1 1] [0 0] [2 2] [0 0] [1 1] [1 1] [7 7] [0 0] [3 3])</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline625" class="outline-6">
<h6 id="orgheadline625">Double range&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline625">
<ul class="org-ul">
<li><code>s/double-in</code> - doubles from begin (inclusive) to end (inclusive)</li>
<li>Also has support for excluding the special values: <code>NaN</code>, <code>Infinity</code>, <code>-Infinity</code></li>
<li>Unlike <code>int-in</code>, the min and max bounds are optional so all options
are passed using keyword args</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/valid? (s/double-in <span class="org-constant">:min</span> 0.0 <span class="org-constant">:max</span> 1.0 <span class="org-constant">:infinite?</span> true <span class="org-constant">:NaN?</span> false) 0.5)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; true</span>

(s/exercise (s/double-in <span class="org-constant">:min</span> 0.0 <span class="org-constant">:max</span> 1.0 <span class="org-constant">:infinite?</span> true <span class="org-constant">:NaN?</span> false))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; ([0.5 0.5] [0.5 0.5] [1.0 1.0] [1.0 1.0] [0.625 0.625] [0.875 0.875])</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline626" class="outline-6">
<h6 id="orgheadline626">Instant range&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h6>
<div class="outline-text-6" id="text-orgheadline626">
<ul class="org-ul">
<li><code>s/inst-in</code> - instants from begin to end</li>
<li>Instants backed by new <code>Inst</code> protocol - extended to Date and Instant</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/valid? (s/inst-in #inst <span class="org-string">"2000"</span> #inst <span class="org-string">"2010"</span>) #inst <span class="org-string">"2007"</span>)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; true</span>

(s/exercise (s/inst-in #inst <span class="org-string">"2000"</span> #inst <span class="org-string">"2001"</span>))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; ([#inst "2000-01-01T00:00:00.000-00:00" </span>
<span class="org-comment-delimiter">;;     </span><span class="org-comment">#inst "2000-01-01T00:00:00.000-00:00"] ...)</span>
</pre>
</div>
</div>
</div>
</div>
</div>


<div id="outline-container-orgheadline641" class="outline-4">
<h4 id="orgheadline641">LAB: Predicates&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline641">
</div><div id="outline-container-orgheadline628" class="outline-5">
<h5 id="orgheadline628">Set up</h5>
<div class="outline-text-5" id="text-orgheadline628">
<p>
If working in the REPL, remember to include the spec namespace:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">require</span> '[clojure.spec.alpha <span class="org-constant">:as</span> s])
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline629" class="outline-5">
<h5 id="orgheadline629">String spec</h5>
<div class="outline-text-5" id="text-orgheadline629">
<p>
Validate that "abc" is a valid string using spec.
</p>
</div>

<div id="outline-container-orgheadline630" class="outline-6">
<h6 id="orgheadline630">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline630">
<div class="org-src-container">

<pre class="src src-clojure">(s/valid? string? <span class="org-string">"abc"</span>)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline631" class="outline-5">
<h5 id="orgheadline631">Bowling rolls</h5>
<div class="outline-text-5" id="text-orgheadline631">
<p>
Write a spec that describes the number of pins knocked down in a bowling roll (0-10). Generate some sample rolls.
</p>
</div>

<div id="outline-container-orgheadline632" class="outline-6">
<h6 id="orgheadline632">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline632">
<div class="org-src-container">

<pre class="src src-clojure">(s/exercise (s/int-in 0 11))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline633" class="outline-5">
<h5 id="orgheadline633">Bowling marks</h5>
<div class="outline-text-5" id="text-orgheadline633">
<p>
Write a spec to describe a bowling scoring mark (a character) and generate some samples:
</p>

<ul class="org-ul">
<li><code>-</code> for 0</li>
<li><code>1-9</code> for a roll</li>
<li><code>/</code> for a spare</li>
<li><code>X</code> for a strike</li>
</ul>
</div>

<div id="outline-container-orgheadline634" class="outline-6">
<h6 id="orgheadline634">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline634">
<div class="org-src-container">

<pre class="src src-clojure">(s/exercise #{\- \1 \2 \3 \4 \5 \6 \7 \8 \9 \/ \X})
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline635" class="outline-5">
<h5 id="orgheadline635">Instances</h5>
<div class="outline-text-5" id="text-orgheadline635">
<p>
Write a spec that validates java.util.Date instances and check that 
<code>(java.util.Date.)</code> is valid.
</p>
</div>

<div id="outline-container-orgheadline636" class="outline-6">
<h6 id="orgheadline636">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline636">
<div class="org-src-container">

<pre class="src src-clojure">(s/valid? #(<span class="org-variable-name">instance?</span> <span class="org-preprocessor">java.util.Date</span> %) (<span class="org-preprocessor">java.util.Date.</span>))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline637" class="outline-5">
<h5 id="orgheadline637">"Regular" doubles</h5>
<div class="outline-text-5" id="text-orgheadline637">
<p>
Write a spec that accepts any double value except the special values NaN, Infinity, and -Infinity and generate some samples.
</p>
</div>

<div id="outline-container-orgheadline638" class="outline-6">
<h6 id="orgheadline638">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline638">
<div class="org-src-container">

<pre class="src src-clojure">(s/exercise (s/double-in <span class="org-constant">:NaN?</span> false <span class="org-constant">:infinite?</span> false))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline639" class="outline-5">
<h5 id="orgheadline639">Regex</h5>
<div class="outline-text-5" id="text-orgheadline639">
<p>
Write a spec that validates whether a string matches the regex #"SKU-[0-9]+" using <code>re-matches</code> and test with some values.
</p>

<p>
Does it generate when you exercise it?
</p>
</div>

<div id="outline-container-orgheadline640" class="outline-6">
<h6 id="orgheadline640">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline640">
<div class="org-src-container">

<pre class="src src-clojure">(s/valid? #(<span class="org-variable-name">re-matches</span> #<span class="org-string">"SKU-[0-9]+"</span> %) <span class="org-string">"SKU-456"</span>) <span class="org-comment-delimiter">;; </span><span class="org-comment">true</span>
(s/valid? #(<span class="org-variable-name">re-matches</span> #<span class="org-string">"SKU-[0-9]+"</span> %) <span class="org-string">"SKU"</span>) <span class="org-comment-delimiter">;; </span><span class="org-comment">false</span>
(s/exercise #(<span class="org-variable-name">re-matches</span> #<span class="org-string">"SKU-[0-9]+"</span> %))
</pre>
</div>

<p>
You will find this spec fails to generate in its current form. Because the function is opaque to spec, there is not enough information to create conforming instances. In the next section we'll learn how to address this.
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-orgheadline650" class="outline-4">
<h4 id="orgheadline650">Composite specs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline650">
</div><div id="outline-container-orgheadline642" class="outline-5">
<h5 id="orgheadline642">Registry&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline642">
<ul class="org-ul">
<li>specs are stored in the spec registry at runtime</li>
<li>The registry key is a qualified keyword</li>
<li>Register a spec with <code>s/def</code>, then use it by name</li>
<li>Named specs can be used anywhere you'd expect a spec</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">:user/name</span> string?)
(s/valid? <span class="org-constant">:user/name</span> <span class="org-string">"Thor"</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline643" class="outline-5">
<h5 id="orgheadline643">Qualified keywords&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline643">
<ul class="org-ul">
<li><code>:foo/bar</code> is a qualified keyword (<code>foo</code> is the namespace)</li>
<li><code>::bar</code> is an autoresolved keyword, with namespace <code>*ns*</code></li>
<li><code>::a/bar</code> is an autoresolved keyword, where <code>a</code> is either an alias in
the current namespace or an explicit namespace</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">create-ns</span> 'my.domain)
(<span class="org-variable-name">alias</span> 'd 'my.domain)
<span class="org-constant">::my.domain/x</span>   <span class="org-comment-delimiter">;; </span><span class="org-comment">absolute ns</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; :my.domain/x</span>
<span class="org-constant">::d/y</span>           <span class="org-comment-delimiter">;; </span><span class="org-comment">aliased ns</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; :my.domain/y</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline644" class="outline-5">
<h5 id="orgheadline644">s/and&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline644">
<ul class="org-ul">
<li>Specs can be combined with <code>s/and</code> - all predicates must pass</li>
<li><code>s/and</code> flows the <b>conformed</b> value through the predicates</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::pos-float</span> (s/and float? pos?))
(s/def <span class="org-constant">::cap-string</span> (s/and string? #(some-&gt; % first <span class="org-preprocessor">Character/isUpperCase</span>)))
(s/def <span class="org-constant">::odd</span> (s/and int? odd?))
(s/def <span class="org-constant">::big-odd</span> (s/and <span class="org-constant">::odd</span> #(<span class="org-variable-name">&gt;</span> % 1000)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline645" class="outline-5">
<h5 id="orgheadline645">s/and generators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline645">
<ul class="org-ul">
<li>s/and will generate values based on the first predicate</li>
<li>Then filter based on each subsequent predicate</li>
<li>Thus, the first pred should always have an associated generator
<ul class="org-ul">
<li><i>This still won't always work! More on that in a bit.</i></li>
</ul></li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::gt10</span> #(<span class="org-variable-name">&gt;</span> % 10)) <span class="org-comment-delimiter">;; </span><span class="org-comment">NO - doesn't gen</span>
(s/def <span class="org-constant">::gt10</span> (s/and int? #(<span class="org-variable-name">&gt;</span> % 10))) <span class="org-comment-delimiter">;; </span><span class="org-comment">YES - will gen</span>

(s/exercise <span class="org-constant">::gt10</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline646" class="outline-5">
<h5 id="orgheadline646">s/or&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline646">
<ul class="org-ul">
<li>Specs can be combined with <code>s/or</code> for alternatives</li>
<li>Each alternative must be tagged with a keyword</li>
<li>The conformed value is tagged with the path taken
<ul class="org-ul">
<li>The return value is a map entry, so works w/ <code>key</code> and <code>val</code></li>
</ul></li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::name</span> (s/or <span class="org-constant">:string</span> string?
                    <span class="org-constant">:keyword</span> keyword?))
(s/valid? <span class="org-constant">::name</span> <span class="org-string">"abc"</span>) <span class="org-comment-delimiter">;; </span><span class="org-comment">true</span>
(s/valid? <span class="org-constant">::name</span> <span class="org-constant">:abc</span>)  <span class="org-comment-delimiter">;; </span><span class="org-comment">true</span>
(s/conform <span class="org-constant">::name</span> <span class="org-string">"abc"</span>) <span class="org-comment-delimiter">;; </span><span class="org-comment">[:string "abc"]</span>
(s/conform <span class="org-constant">::name</span> <span class="org-constant">:abc</span>)  <span class="org-comment-delimiter">;; </span><span class="org-comment">[:keyword :abc]</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline647" class="outline-5">
<h5 id="orgheadline647">s/or generators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline647">
<ul class="org-ul">
<li><code>s/or</code> generators choose from all of the alternatives</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/exercise <span class="org-constant">::name</span>)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; (["" [:string ""]]</span>
<span class="org-comment-delimiter">;;    </span><span class="org-comment">["r" [:string "r"]]</span>
<span class="org-comment-delimiter">;;    </span><span class="org-comment">["20" [:string "20"]]</span>
<span class="org-comment-delimiter">;;    </span><span class="org-comment">["j8GZ" [:string "j8GZ"]]</span>
<span class="org-comment-delimiter">;;    </span><span class="org-comment">[:v1+V_+.nd.S.+-/*-!4- [:keyword :v1+V_+.nd.S.+-/*-!4-]] </span>
<span class="org-comment-delimiter">;;    </span><span class="org-comment">[:*T*B9UD.E1OI?!4j.ipV*j-/*9wt4y [:keyword :*T*B9UD.E1OI?!4j.ipV*j-/*9wt4y]])</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline648" class="outline-5">
<h5 id="orgheadline648">Explaining errors&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline648">
<ul class="org-ul">
<li><code>s/explain</code> explains why non-conforming values don't conform</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::name</span> (s/or <span class="org-constant">:string</span> string? <span class="org-constant">:keyword</span> keyword?))
(s/explain <span class="org-constant">::name</span> 100)
<span class="org-comment-delimiter">;; </span><span class="org-comment">val: 100 fails spec: :user/name at: [:string] predicate: string?</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">val: 100 fails spec: :user/name at: [:keyword] predicate: keyword?</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline649" class="outline-5">
<h5 id="orgheadline649">More explaining&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline649">
<ul class="org-ul">
<li><code>s/explain-str</code> - retrieve explain error as a string</li>
<li><code>s/explain-data</code> - retrieve explain error as data
<ul class="org-ul">
<li><code>:path</code> - vector of path keys from root data to failing data</li>
<li><code>:pred</code> - actual predicate that failed</li>
<li><code>:val</code>  - non-conforming value</li>
<li><code>:in</code>   - vector of specs from root spec to failing spec</li>
</ul></li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/explain-data <span class="org-constant">::name</span> 100)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; {:clojure.spec.alpha/problems</span>
<span class="org-comment-delimiter">;;    </span><span class="org-comment">({:path [:string], :pred string?, :val 100, :via [:user/name], :in []} </span>
<span class="org-comment-delimiter">;;     </span><span class="org-comment">{:path [:keyword], :pred keyword?, :val 100, :via [:user/name], :in []})}</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline659" class="outline-4">
<h4 id="orgheadline659">LAB: Composite specs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline659">
</div><div id="outline-container-orgheadline651" class="outline-5">
<h5 id="orgheadline651">Refining predicates</h5>
<div class="outline-text-5" id="text-orgheadline651">
<p>
Create a spec that accepts any unqualified symbol EXCEPT <code>&amp;</code>.
</p>

<p>
Does it gen automatically?
</p>
</div>

<div id="outline-container-orgheadline652" class="outline-6">
<h6 id="orgheadline652">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline652">
<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::local-name</span> (s/and simple-symbol? #(<span class="org-variable-name">not=</span> '&amp; %)))

(s/exercise <span class="org-constant">::local-name</span>) <span class="org-comment-delimiter">;; </span><span class="org-comment">works!</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline653" class="outline-5">
<h5 id="orgheadline653">Ports</h5>
<div class="outline-text-5" id="text-orgheadline653">
<p>
Create specs for privileged ports (1-1024) and unprivileged ports
(1025-65536). Create a spec that combines these specs for any port.
Conform values in both ranges and check the result.
</p>
</div>

<div id="outline-container-orgheadline654" class="outline-6">
<h6 id="orgheadline654">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline654">
<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::priv-port</span> (s/int-in 1 1025))
(s/def <span class="org-constant">::unpriv-port</span> (s/int-in 1025 65537))
(s/def <span class="org-constant">::port</span> (s/or <span class="org-constant">:privileged</span> <span class="org-constant">::priv-port</span>
                    <span class="org-constant">:unprivileged</span> <span class="org-constant">::unpriv-port</span>))

(s/conform <span class="org-constant">::port</span> 22)   <span class="org-comment-delimiter">;; </span><span class="org-comment">[:privileged 22]</span>
(s/conform <span class="org-constant">::port</span> 8000) <span class="org-comment-delimiter">;; </span><span class="org-comment">[:unprivileged 8000]</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline655" class="outline-5">
<h5 id="orgheadline655">Tweaking conformance</h5>
<div class="outline-text-5" id="text-orgheadline655">
<p>
Given the prior exercise, what if you wished to conform not to a
tagged value but to the original value?
</p>

<p>
spec provides <i>conformers</i> to manipulate the conformed value.
<code>s/conform</code> applies an arbitrary function to its input and returns
either the modified output or <code>:s/invalid</code>. Often conformers are
combined with other predicates inside an <code>s/and</code>.
</p>

<p>
NOTE! Be careful using conformers, particularly with registered
specs - you are making decisions for all consumers of your spec.
Modifying the conformed value throws away information that you may
wish to have at some future point.
</p>

<p>
Use <code>s/conformer</code> to modify <code>::port</code> to return the original
value. Keep in mind that <code>s/or</code> returns a map entry that works with
<code>key</code> and <code>val</code>.
</p>
</div>

<div id="outline-container-orgheadline656" class="outline-6">
<h6 id="orgheadline656">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline656">
<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::port-2</span> (s/and <span class="org-constant">::port</span> (s/conformer val)))

(s/conform <span class="org-constant">::port-2</span> 22)   <span class="org-comment-delimiter">;; </span><span class="org-comment">22</span>
(s/conform <span class="org-constant">::port-2</span> 8000) <span class="org-comment-delimiter">;; </span><span class="org-comment">8000</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline657" class="outline-5">
<h5 id="orgheadline657">Running spec backward</h5>
<div class="outline-text-5" id="text-orgheadline657">
<p>
The logic contained in conform can be run in reverse to produce the
original value from a conformed value using <code>s/unform</code>.
</p>

<p>
Run <code>unform</code> on both <code>::port</code> and <code>::port-2</code> - what
happens?
</p>
</div>

<div id="outline-container-orgheadline658" class="outline-6">
<h6 id="orgheadline658">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline658">
<div class="org-src-container">

<pre class="src src-clojure">(s/unform <span class="org-constant">::port</span> [<span class="org-constant">:user/privileged</span> 22])
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 22</span>

(s/unform <span class="org-constant">::port-2</span> 22)
<span class="org-comment-delimiter">;; </span><span class="org-comment">IllegalStateException no unform fn for conformer</span>
</pre>
</div>

<p>
When you define a conformer you can also pass an optional unform
function to be used. For example, the conformer here must take the
output of conform and produce the output of conforming the <code>s/or</code>:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::port-3</span>
  (s/and <span class="org-constant">::port</span> (s/conformer val 
                  #(<span class="org-builtin">if</span> (<span class="org-variable-name">&lt;=</span> % 1024) 
                    [<span class="org-constant">:privileged</span> %]
                    [<span class="org-constant">:unprivileged</span> %]))))

(s/unform <span class="org-constant">::port-3</span> 22) <span class="org-comment-delimiter">;; </span><span class="org-comment">22</span>
(s/unform <span class="org-constant">::port-3</span> 8000) <span class="org-comment-delimiter">;; </span><span class="org-comment">8000</span>
</pre>
</div>

<p>
In this case, it's possible to unambiguously recover the former
value, but this is not always the case. Some conformers throw away
enough information that you cannot recover the original value, and
that's why conformers should be used with care.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline673" class="outline-4">
<h4 id="orgheadline673">Collection specs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline673">
</div><div id="outline-container-orgheadline660" class="outline-5">
<h5 id="orgheadline660">coll-of&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline660">
<ul class="org-ul">
<li><code>s/coll-of</code> specs collection where elements match a spec</li>
<li>Suitable for all Clojure collections and seqs</li>
<li>All values will be checked and conformed</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::ints</span> (s/coll-of int?))
(s/valid? <span class="org-constant">::ints</span> [1 2]) <span class="org-comment-delimiter">;; </span><span class="org-comment">true</span>
(s/valid? <span class="org-constant">::ints</span> #{1 2}) <span class="org-comment-delimiter">;; </span><span class="org-comment">true</span>
(s/valid? <span class="org-constant">::ints</span> (<span class="org-variable-name">range</span> 10)) <span class="org-comment-delimiter">;; </span><span class="org-comment">true</span>
(s/valid? <span class="org-constant">::ints</span> []) <span class="org-comment-delimiter">;; </span><span class="org-comment">true</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline661" class="outline-5">
<h5 id="orgheadline661">coll-of :kind&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline661">
<ul class="org-ul">
<li>The <code>:kind</code> option can be used to add an initial constraint
<ul class="org-ul">
<li>Often to constrain collection type or check properties</li>
</ul></li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::int-set</span> (s/coll-of int? <span class="org-constant">:kind</span> set?))
(s/conform <span class="org-constant">::int-set</span> #{1 2 3}) <span class="org-comment-delimiter">;; </span><span class="org-comment">#{1 3 2}</span>
(s/explain <span class="org-constant">::int-set</span> [1 2 3])
<span class="org-comment-delimiter">;; </span><span class="org-comment">val: [1 2 3] fails spec: :user/int-set predicate: set?</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline662" class="outline-5">
<h5 id="orgheadline662">coll-of :into&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline662">
<ul class="org-ul">
<li><code>s/coll-of</code> will conform/gen to a coll that matches input type</li>
<li>Use <code>:into</code> option to override</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/conform (s/coll-of int?) [1 2 3])
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; [1 2 3]</span>
(s/conform (s/coll-of int? <span class="org-constant">:into</span> #{}) [1 2 3])
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #{1 3 2}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline663" class="outline-5">
<h5 id="orgheadline663">coll-of options&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline663">
<ul class="org-ul">
<li>There are several extra constraints you can add:
<ul class="org-ul">
<li><code>:count</code> - exact count</li>
<li><code>:min-count</code> - min count (inclusive)</li>
<li><code>:max-count</code> - max count (inclusive)</li>
<li><code>:distinct</code>  - elements are distinct</li>
</ul></li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::point</span> (s/coll-of int? <span class="org-constant">:count</span> 2))
(s/def <span class="org-constant">::line</span> (s/coll-of <span class="org-constant">::point</span> <span class="org-constant">:count</span> 2))
(s/def <span class="org-constant">::triangle</span> (s/coll-of <span class="org-constant">::point</span> <span class="org-constant">:count</span> 3))
(s/def <span class="org-constant">::polygon</span> (s/coll-of <span class="org-constant">::point</span> <span class="org-constant">:min-count</span> 3))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline664" class="outline-5">
<h5 id="orgheadline664">coll-of generator options&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline664">
<ul class="org-ul">
<li><code>coll-of</code> generates into an output coll based on:
<ul class="org-ul">
<li><code>:into</code> - default collection, if supplied (<code>[]</code>, <code>()</code>, <code>{}</code>, <code>#{}</code>)</li>
<li><code>:kind</code> - empty coll as generated by this predicate</li>
<li><code>[ ]</code></li>
</ul></li>
<li><code>:gen-max</code> - option to cap coll size (recommended!)</li>
<li><code>:gen</code> - an optional generator to use instead</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline665" class="outline-5">
<h5 id="orgheadline665">Maps as containers - map-of&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline665">
<ul class="org-ul">
<li><code>map-of</code> specs a map in terms of a key-pred and a val-pred</li>
<li>Conforms and generates to a map</li>
<li><code>:conform-keys</code> option says whether to conform keys (default=false)</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::scores</span> (s/map-of string? int?))
(s/def <span class="org-constant">::employees</span> (s/map-of <span class="org-constant">::region</span> (s/map-of <span class="org-constant">::id</span> <span class="org-constant">::employee</span>)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline666" class="outline-5">
<h5 id="orgheadline666">Collection sampling specs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline666">
<ul class="org-ul">
<li><code>coll-of</code> and <code>map-of</code> check and conform all elements and values</li>
<li><code>every</code> and <code>every-kv</code> instead sample <code>*coll-check-limit*</code> elements
and don't conform the values (performance generally better)</li>
<li><code>every</code> and <code>every-kv</code> share all of the same options already discussed</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline667" class="outline-5">
<h5 id="orgheadline667">Tuples&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline667">
<ul class="org-ul">
<li>All of the collection specs expect homogeneous element specs</li>
<li>For position-based heterogenous vector tuples, use <code>s/tuple</code></li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::quantity</span> number?)
(s/def <span class="org-constant">::unit</span> #{<span class="org-constant">:teaspoon</span> <span class="org-constant">:tablespoon</span> <span class="org-constant">:cup</span> <span class="org-constant">:ounce</span>})
(s/def <span class="org-constant">::ingredient</span> (s/tuple <span class="org-constant">::quantity</span> <span class="org-constant">::unit</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline668" class="outline-5">
<h5 id="orgheadline668">Maps as information&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline668">
<ul class="org-ul">
<li><code>s/keys</code> specs a map as a set of attributes</li>
<li>Attribute keys must be qualified keywords tied to spec names</li>
<li>ALL values are checked based on their key specs</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::item-id</span> int?)
(s/def <span class="org-constant">::quantity</span> int?)
(s/def <span class="org-constant">::line-item</span> (s/keys <span class="org-constant">:req</span> [<span class="org-constant">::item-id</span> <span class="org-constant">::quantity</span>]))

(s/def <span class="org-constant">::purchaser</span> string?)
(s/def <span class="org-constant">::line-items</span> (s/coll-of <span class="org-constant">::line-item</span> <span class="org-constant">:min-count</span> 1))
(s/def <span class="org-constant">::due-date</span> inst?)
(s/def <span class="org-constant">::order</span> (s/keys <span class="org-constant">:req</span> [<span class="org-constant">::purchaser</span> <span class="org-constant">::line-items</span>] <span class="org-constant">:opt</span> [<span class="org-constant">::due-date</span>]))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline669" class="outline-5">
<h5 id="orgheadline669">Using keys spec&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline669">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">line</span> {<span class="org-constant">::item-id</span> 100 <span class="org-constant">::quantity</span> 10})
(s/valid? <span class="org-constant">::line-item</span> line) <span class="org-comment-delimiter">;; </span><span class="org-comment">true</span>

(<span class="org-keyword">def</span> <span class="org-function-name">order</span> {<span class="org-constant">::purchaser</span> <span class="org-string">"James Bond"</span>
            <span class="org-constant">::line-items</span> [line] 
            <span class="org-constant">::due-date</span> #inst <span class="org-string">"2016-12-01"</span>})
(s/valid? <span class="org-constant">::order</span> order) <span class="org-comment-delimiter">;; </span><span class="org-comment">true</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline670" class="outline-5">
<h5 id="orgheadline670">Key combinations&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline670">
<ul class="org-ul">
<li><code>s/keys</code> also support <code>and</code> and <code>or</code> in the required key set:</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::user</span> string?)
(s/def <span class="org-constant">::password</span> string?)
(s/def <span class="org-constant">::token</span> string?)
(s/def <span class="org-constant">::creds</span> (s/keys <span class="org-constant">:req</span> [(<span class="org-builtin">or</span> (<span class="org-builtin">and</span> <span class="org-constant">::user</span> <span class="org-constant">::password</span>) <span class="org-constant">::token</span>)]))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline671" class="outline-5">
<h5 id="orgheadline671">Unqualified keys&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline671">
<ul class="org-ul">
<li><code>s/keys</code> also has <code>:req-un</code> and <code>:opt-un</code> for unqualified keys</li>
<li>They still take qualified spec names</li>
<li>But only the short name is used to match attribute in map</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::name</span> string?)
(s/def <span class="org-constant">::person</span> (s/keys <span class="org-constant">:req-un</span> [<span class="org-constant">::name</span>]))
(s/valid? <span class="org-constant">::person</span> {<span class="org-constant">:name</span> <span class="org-string">"Rich"</span>}) <span class="org-comment-delimiter">;; </span><span class="org-comment">true</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline672" class="outline-5">
<h5 id="orgheadline672">Merging map specs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline672">
<ul class="org-ul">
<li><code>s/merge</code> can be used to combine two map specs</li>
<li>Differences from <code>s/and</code>
<ul class="org-ul">
<li>Does not flow conformed values to each map spec</li>
<li>Generates maps satisfying union of specs</li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline682" class="outline-4">
<h4 id="orgheadline682">LAB: Collections&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline682">
</div><div id="outline-container-orgheadline674" class="outline-5">
<h5 id="orgheadline674">Collection practice</h5>
<div class="outline-text-5" id="text-orgheadline674">
<p>
Define the following specs and check that they conform and gen:
</p>

<ul class="org-ul">
<li>Collection of distinct strings</li>
<li>Vector of no more than 5 booleans</li>
<li>Set of collections of ints</li>
<li>Map of strings to ints</li>
</ul>
</div>

<div id="outline-container-orgheadline675" class="outline-6">
<h6 id="orgheadline675">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline675">
<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::distinct-strs</span> (s/coll-of string? <span class="org-constant">:distinct</span> true))
(s/def <span class="org-constant">::vbools</span> (s/coll-of boolean? <span class="org-constant">:kind</span> vector? <span class="org-constant">:max-count</span> 5))
(s/def <span class="org-constant">::int-sets</span> (s/coll-of (s/coll-of int?) <span class="org-constant">:kind</span> set?))
(s/def <span class="org-constant">::str-int</span> (s/map-of string? int?))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline676" class="outline-5">
<h5 id="orgheadline676">Recursive specs</h5>
<div class="outline-text-5" id="text-orgheadline676">
<p>
Write a spec for a binary tree. Branch nodes are collections 
containing either 1 or 2 children. Leaves are ints.
</p>

<p>
Conform a sample tree like:
</p>

<p>
<code>[[1 2] [3 [4 5]]]</code>
</p>

<p>
Exercise the spec to generate and conform some random trees.
</p>
</div>

<div id="outline-container-orgheadline677" class="outline-6">
<h6 id="orgheadline677">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline677">
<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::node</span>
  (s/or <span class="org-constant">:branch</span> (s/coll-of <span class="org-constant">::node</span> <span class="org-constant">:min-count</span> 1 <span class="org-constant">:max-count</span> 2)
        <span class="org-constant">:leaf</span> int?))

(s/conform <span class="org-constant">::node</span> [[1 2] [3 [4 5]]])

(s/exercise <span class="org-constant">::node</span>)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline678" class="outline-5">
<h5 id="orgheadline678">Ingredients</h5>
<div class="outline-text-5" id="text-orgheadline678">
<p>
Write a spec for a recipe ingredient consisting of the ingredient
name, a quantity, and unit (a keyword). The following ingredients
should conform:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">water</span> #<span class="org-constant">:ingredient</span>{<span class="org-constant">:name</span> <span class="org-string">"water"</span> <span class="org-constant">:quantity</span> 10 <span class="org-constant">:unit</span> <span class="org-constant">:ounce</span>})
(<span class="org-keyword">def</span> <span class="org-function-name">butter</span> #<span class="org-constant">:ingredient</span>{<span class="org-constant">:name</span> <span class="org-string">"butter"</span> <span class="org-constant">:quantity</span> 1/2 <span class="org-constant">:unit</span> <span class="org-constant">:tablespoon</span>})
</pre>
</div>
</div>

<div id="outline-container-orgheadline679" class="outline-6">
<h6 id="orgheadline679">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline679">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">create-ns</span> 'common)
(<span class="org-variable-name">alias</span> 'c 'common)
(s/def <span class="org-constant">::c/pos-num</span> (s/and number? pos?))

(<span class="org-variable-name">create-ns</span> 'ingredient)
(<span class="org-variable-name">alias</span> 'i 'ingredient)
(s/def <span class="org-constant">::i/name</span> string?)
(s/def <span class="org-constant">::i/quantity</span> <span class="org-constant">:common/pos-num</span>)
(s/def <span class="org-constant">::i/unit</span> keyword?)
(s/def <span class="org-constant">::i/ingredient</span> (s/keys <span class="org-constant">:req</span> [<span class="org-constant">::i/name</span> <span class="org-constant">::i/quantity</span> <span class="org-constant">::i/unit</span>]))

(s/conform <span class="org-constant">::i/ingredient</span> water)
(s/conform <span class="org-constant">::i/ingredient</span> butter)
</pre>
</div>

<p>
The quantity could be different kinds of numbers (integer, float, or
ratio, but must be positive. Basing pos-num on number? allows it
to gen automatically.
</p>

<p>
We could constrain the unit to specific keywords but we can leave
that as an open set for now.
</p>

<p>
We've used namespaces here to scope attributes and give them some meaning.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline680" class="outline-5">
<h5 id="orgheadline680">Recipes</h5>
<div class="outline-text-5" id="text-orgheadline680">
<p>
Write a spec for a recipe consisting of:
</p>
<ul class="org-ul">
<li>name</li>
<li>description</li>
<li>ingredients - coll of ingredients</li>
<li>steps - coll of strings</li>
<li>servings - number of servings</li>
</ul>

<p>
Conform the following recipe to verify it works:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">toast</span>
  #<span class="org-constant">:recipe</span>{
    <span class="org-constant">:name</span> <span class="org-string">"Buttered toast"</span>
    <span class="org-constant">:description</span> <span class="org-string">"Like bread, but more tasty"</span>
    <span class="org-constant">:ingredients</span> [
      #<span class="org-constant">:ingredient</span>{<span class="org-constant">:name</span> <span class="org-string">"bread"</span> <span class="org-constant">:quantity</span> 2 <span class="org-constant">:unit</span> <span class="org-constant">:slice</span>}
      #<span class="org-constant">:ingredient</span>{<span class="org-constant">:name</span> <span class="org-string">"butter"</span> <span class="org-constant">:quantity</span> 1 <span class="org-constant">:unit</span> <span class="org-constant">:teaspoon</span>}]
    <span class="org-constant">:steps</span> [<span class="org-string">"Toast two slice of bread in the toaster."</span>
            <span class="org-string">"Spread butter on toast."</span>]
    <span class="org-constant">:servings</span> 1})
</pre>
</div>

<p>
Exercise it to create some recipes.
</p>
</div>

<div id="outline-container-orgheadline681" class="outline-6">
<h6 id="orgheadline681">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline681">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">create-ns</span> 'recipe)
(<span class="org-variable-name">alias</span> 'r 'recipe)

(s/def <span class="org-constant">::r/name</span> string?)
(s/def <span class="org-constant">::r/description</span> string?)
(s/def <span class="org-constant">::r/ingredients</span> (s/coll-of <span class="org-constant">::i/ingredient</span> <span class="org-constant">:gen-max</span> 3))
(s/def <span class="org-constant">::r/steps</span> (s/coll-of string? <span class="org-constant">:gen-max</span> 3))
(s/def <span class="org-constant">::r/servings</span> <span class="org-constant">::c/pos-num</span>)
(s/def <span class="org-constant">::r/recipe</span> (s/keys <span class="org-constant">:req</span> [<span class="org-constant">::r/name</span>]
                         <span class="org-constant">:opt</span> [<span class="org-constant">::r/description</span> <span class="org-constant">::r/ingredients</span> <span class="org-constant">::r/steps</span> <span class="org-constant">::r/servings</span>]))

(s/conform <span class="org-constant">::r/recipe</span> toast)

(s/exercise <span class="org-constant">::r/recipe</span>)
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline702" class="outline-4">
<h4 id="orgheadline702">Functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline702">
</div><div id="outline-container-orgheadline683" class="outline-5">
<h5 id="orgheadline683">Function specs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline683">
<ul class="org-ul">
<li>Use <code>s/fdef</code> to associate specs with a function
<ul class="org-ul">
<li><code>:args</code> - args spec (usually a regex)</li>
<li><code>:ret</code>  - return value spec</li>
<li><code>:fn</code>   - spec or fn of conformed args + ret</li>
</ul></li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/fdef clojure.core/subs 
  <span class="org-constant">:args</span> (s/and (s/cat <span class="org-constant">:s</span> string? <span class="org-constant">:start</span> nat-int? <span class="org-constant">:end</span> (s/? nat-int?))
               (<span class="org-variable-name">fn</span> [{<span class="org-constant">:keys</span> [s start end]}]
                 (<span class="org-builtin">if</span> end
                   (<span class="org-variable-name">&lt;=</span> start end (<span class="org-variable-name">count</span> s))
                   (<span class="org-variable-name">&lt;=</span> start (<span class="org-variable-name">count</span> s)))))
  <span class="org-constant">:ret</span>  string?
  <span class="org-constant">:fn</span>   (<span class="org-variable-name">fn</span> [{<span class="org-constant">:keys</span> [args ret]}]
          (<span class="org-builtin">let</span> [{<span class="org-constant">:keys</span> [s start end]} args]
            (<span class="org-variable-name">&lt;=</span> (<span class="org-variable-name">count</span> ret) (<span class="org-variable-name">-</span> (<span class="org-builtin">or</span> end (<span class="org-variable-name">count</span> s)) start)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline684" class="outline-5">
<h5 id="orgheadline684">Regex syntax specs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h5>
</div>

<div id="outline-container-orgheadline685" class="outline-5">
<h5 id="orgheadline685">Sequential syntax&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline685">
<ul class="org-ul">
<li>Like regex, but describing data values in a sequential coll</li>
<li>Most applicable to describing syntax</li>
<li>Nested regex ops do NOT describe nested collections</li>
<li>(although there is a way to do that too)</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline686" class="outline-5">
<h5 id="orgheadline686">Concatentation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline686">
<ul class="org-ul">
<li><code>s/cat</code> - match all specified parts, in order</li>
<li>Each part is tagged with a keyword</li>
<li>Conforms to a map keyed by the tag</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::args</span> (s/cat <span class="org-constant">:ns</span> string? <span class="org-constant">:n</span> string?))
(s/conform <span class="org-constant">::args</span> [<span class="org-string">"clojure.string"</span> <span class="org-string">"blank?"</span>])
<span class="org-comment-delimiter">;; </span><span class="org-comment">{:ns "clojure.string", :n "blank?"}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline687" class="outline-5">
<h5 id="orgheadline687">Alternation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline687">
<ul class="org-ul">
<li><code>s/alt</code> - specify alternatives</li>
<li>Each part is tagged with a keyword</li>
<li>Conformed value is entry of tag and the conformed path taken</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::args</span> 
  (s/alt <span class="org-constant">::arity-2</span> (s/cat <span class="org-constant">:ns</span> string? <span class="org-constant">:n</span> string?) 
         <span class="org-constant">::arity-1</span> (s/cat <span class="org-constant">:n</span> string?)))

(s/conform <span class="org-constant">::args</span> [<span class="org-string">"clojure.string"</span> <span class="org-string">"blank?"</span>])
<span class="org-comment-delimiter">;; </span><span class="org-comment">[::arity-2 {:ns "clojure.string", :n "blank?"}]</span>
(s/conform <span class="org-constant">::args</span> [<span class="org-string">"blank?"</span>])
<span class="org-comment-delimiter">;; </span><span class="org-comment">[::arity-1 {:n "blank?"}]</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline688" class="outline-5">
<h5 id="orgheadline688">Repetition&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline688">
<ul class="org-ul">
<li>Repetition operators (<code>s/*</code>, <code>s/+</code>)
<ul class="org-ul">
<li>Conforms to a vector</li>
</ul></li>
<li>Optional element - <code>s/?</code></li>
<li>All of these operators can be nested together</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::o-then-maybe-e</span> (s/cat <span class="org-constant">:odds</span> (s/+ odd?) <span class="org-constant">:even</span> (s/? even?)))

(s/conform <span class="org-constant">::o-then-maybe-e</span> [1 3 5 100])
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; {:odds [1 3 5], :even 100}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline689" class="outline-5">
<h5 id="orgheadline689">kwargs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline689">
<ul class="org-ul">
<li>Common case we encounter in Clojure function signatures</li>
<li>Keyword options that can occur at the end of a call</li>
<li><code>s/keys*</code> borrows the syntax of <code>s/keys</code> but is used to spec an
arbitary number of key-value options in a sequential context</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::port</span> number?)
(s/def <span class="org-constant">::host</span> string?)
(s/def <span class="org-constant">::echo</span> boolean?)
(s/def <span class="org-constant">::connect</span> 
  (s/cat <span class="org-constant">:host</span> <span class="org-constant">::host</span> 
         <span class="org-constant">:opts</span> (s/keys* <span class="org-constant">:opt</span> [<span class="org-constant">::port</span> <span class="org-constant">::echo</span>])))

(s/conform <span class="org-constant">::connect</span> [<span class="org-string">"localhost"</span> <span class="org-constant">:port</span> 5555])
<span class="org-comment-delimiter">;; </span><span class="org-comment">{:host "localhost", :opts {:port 5555}}</span>
(s/conform <span class="org-constant">::connect</span> [<span class="org-string">"localhost"</span> <span class="org-constant">:echo</span> true <span class="org-constant">:port</span> 5555])
<span class="org-comment-delimiter">;; </span><span class="org-comment">{:host "localhost", :opts {:echo true, :port 5555}}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline690" class="outline-5">
<h5 id="orgheadline690">Adding constraints&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline690">
<ul class="org-ul">
<li><code>s/&amp;</code> adds an arbitrary constraint to another regex op</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">int, then up to 3 strings</span>
(s/def <span class="org-constant">::foo</span> (s/cat <span class="org-constant">:i</span> int? 
                    <span class="org-constant">:s</span> (s/&amp; (s/* string?) 
                            #(<span class="org-variable-name">&lt;=</span> (<span class="org-variable-name">count</span> %) 3))))

(s/conform <span class="org-constant">::foo</span> [5]) <span class="org-comment-delimiter">;; </span><span class="org-comment">{:i 5}</span>
(s/conform <span class="org-constant">::foo</span> [5 <span class="org-string">"a"</span> <span class="org-string">"b"</span> <span class="org-string">"c"</span>]) <span class="org-comment-delimiter">;; </span><span class="org-comment">{:i 5, :s ["a" "b" "c"]} </span>
(s/explain <span class="org-constant">::foo</span> [5 <span class="org-string">"a"</span> <span class="org-string">"b"</span> <span class="org-string">"c"</span> <span class="org-string">"d"</span>])
<span class="org-comment-delimiter">;; </span><span class="org-comment">val: ["a" "b" "c" "d"] fails spec: :user/foo </span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">at: [:s] predicate: (&lt;= (count %) 3)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline691" class="outline-5">
<h5 id="orgheadline691">doc support&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline691">
<ul class="org-ul">
<li>Loaded function specs will be printed by <code>doc</code></li>
<li><code>doc</code> also works with keyword spec names</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::foo</span> string?)
(<span class="org-variable-name">doc</span> <span class="org-constant">::foo</span>)
-------------------------
<span class="org-constant">:user/foo</span>
<span class="org-preprocessor">Spec</span>
  string?
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline692" class="outline-5">
<h5 id="orgheadline692">Macro args check&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline692">
<ul class="org-ul">
<li>If <code>fdef</code> is on a macro, the <code>:args</code> spec will be checked
during macroexpansion and an error will be thrown</li>
<li>The <code>:ret</code> and <code>:fn</code> specs are NOT checked</li>
<li>This check is added automatically with no further action</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline693" class="outline-5">
<h5 id="orgheadline693">Function args check&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline693">
<ul class="org-ul">
<li>If <code>fdef</code> is used on a function, no checks are done automatically.
We'll see later how to turn on instrumentation.</li>
<li>Use <code>exercise-fn</code> to generate args and invoke a function.</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/fdef clojure.core/str
  <span class="org-constant">:args</span> (s/* any?)
  <span class="org-constant">:ret</span> string?)

(s/exercise-fn `str)
<span class="org-comment-delimiter">;; </span><span class="org-comment">([() ""] </span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">[([] nil) "[]"] </span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">[([{}] nil nil nil nil) "[{}]"] </span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">[([{-4 :OgP.H8_*t 5 1.0} {\N 2.5625}] nil nil {}) </span>
<span class="org-comment-delimiter">;;   </span><span class="org-comment">"[{-4 :OgP.H8_*t, 5 1.0} {\\N 2.5625}]{}"] ...)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline694" class="outline-5">
<h5 id="orgheadline694">Function specs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline694">
<ul class="org-ul">
<li><code>s/fspec</code> takes the same form as <code>fdef</code> but can be used to spec a
function independently from a var (higher-order functions)</li>
<li>Function specs generate by creating a function that invokes
the :ret generator (so a :ret spec is required)</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">adder</span> [x] #(<span class="org-variable-name">+</span> x %))
(s/fdef adder
  <span class="org-constant">:args</span> (s/cat <span class="org-constant">:x</span> number?)
  <span class="org-constant">:ret</span> (s/fspec <span class="org-constant">:args</span> (s/cat <span class="org-constant">:y</span> number?)
                <span class="org-constant">:ret</span> number?)
  <span class="org-constant">:fn</span> #(<span class="org-variable-name">=</span> (<span class="org-builtin">-&gt;</span> % <span class="org-constant">:args</span> <span class="org-constant">:x</span>) ((<span class="org-constant">:ret</span> %) 0)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline695" class="outline-5">
<h5 id="orgheadline695">Instrumenting functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline695">
<ul class="org-ul">
<li>clojure.spec.test.alpha namespace contains testing facilities</li>
<li><code>instrument</code> will instrument a spec'ed function to check its :args
spec on invocation</li>
<li>Takes one or more fully-qualified var names to instrument</li>
<li>Or none to instrument all instrumentable symbols</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">require</span> '[clojure.spec.test.alpha <span class="org-constant">:as</span> stest])
(stest/instrument 'clojure.core/subs)
(<span class="org-variable-name">subs</span> <span class="org-string">"abc"</span> 10)
<span class="org-comment-delimiter">;; </span><span class="org-comment">ExceptionInfo Call to #'clojure.core/subs did not conform to spec:</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">val: {:s "abc", :start 10} fails at: [:args] </span>
<span class="org-comment-delimiter">;;   </span><span class="org-comment">predicate: (fn [{:keys [s start end]}] (if end (&lt;= start end (count s)) (&lt;= start (count s))))</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">:clojure.spec.alpha/args  ("abc" 10)</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">:clojure.spec.alpha/failure  :instrument</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">:clojure.spec.test.alpha/caller  {:file "NO_SOURCE_FILE", :line 17, :var-scope user/eval21}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline696" class="outline-5">
<h5 id="orgheadline696">Other instrumentation features&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline696">
<ul class="org-ul">
<li>Specify missing or replacement specs</li>
<li>Generate function stubs</li>
<li>Swap in replacement functions</li>
<li>See docs for more details</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline697" class="outline-5">
<h5 id="orgheadline697">Instrumentation helpers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline697">
<ul class="org-ul">
<li><code>stest/enumerate-ns</code> - enumerate all var-name symbols in a namespace</li>
<li><code>stest/instrumentable-syms</code> - all syms that can be instrumented
<ul class="org-ul">
<li>functions vars that have function specs or stubs or replace fns</li>
</ul></li>
<li><code>stest/checkable-syms</code> - all syms that can be checked
<ul class="org-ul">
<li>function vars that have function specs</li>
</ul></li>
<li><code>stest/unstrument</code> - uninstrument some or all vars</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline698" class="outline-5">
<h5 id="orgheadline698">Check&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline698">
<ul class="org-ul">
<li><code>stest/check</code> runs generative tests on functions using their specs
<ul class="org-ul">
<li>:args spec is used to generate inputs</li>
<li>the function is invoked</li>
<li>the :ret and :fn specs are checked</li>
</ul></li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">sq</span> [x] (<span class="org-variable-name">*</span>' x x))
(s/fdef sq <span class="org-constant">:args</span> (s/cat <span class="org-constant">:x</span> integer?) <span class="org-constant">:ret</span> integer?)
(stest/check `sq)
<span class="org-comment-delimiter">;; </span><span class="org-comment">({:spec #object[...],</span>
<span class="org-comment-delimiter">;;   </span><span class="org-comment">:clojure.spec.test.check/ret </span>
<span class="org-comment-delimiter">;;   </span><span class="org-comment">{:result true, :num-tests 1000, :seed 1479321111667}, :sym user/sq})</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline699" class="outline-5">
<h5 id="orgheadline699">Interpreting check results&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline699">
<ul class="org-ul">
<li>Returns lazy seq of check result maps with keys:
<ul class="org-ul">
<li>:spec, :sym, :failure, :clojure.spec.test.check/ret</li>
</ul></li>
<li>A :failure has a failure type:
<ul class="org-ul">
<li><code>:no-fn</code> - fn doesn't exist</li>
<li><code>:no-fspec</code> - fn doesn't have a function spec</li>
<li><code>:no-args-spec</code> - fn doesn't have :args spec</li>
<li><code>:no-gen</code> - fn args don't generate</li>
<li><code>:instrument</code> - invalid args detected by instrument</li>
<li><code>:check-failed</code> - either :ret or :fn didn't validate</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline700" class="outline-5">
<h5 id="orgheadline700">Summarizing check results&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline700">
<ul class="org-ul">
<li><code>stest/abbrev-result</code> will abbreviate a single sym's result</li>
<li><code>stest/summarize-results</code> can be used to summarize all</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(stest/summarize-results *1)
<span class="org-comment-delimiter">;; </span><span class="org-comment">{:sym user/sq}</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; {:total 1, :check-passed 1}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline701" class="outline-5">
<h5 id="orgheadline701">Check options&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline701">
<ul class="org-ul">
<li>check has several options
<ul class="org-ul">
<li>:clojure.spec.test.check/opts - map of args to pass through to
test.check
<ul class="org-ul">
<li>:num-tests - most commonly passed (default=1000)</li>
<li>:seed - to recreate specific run</li>
<li>:max-size - control generated value size</li>
</ul></li>
</ul></li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">bound size to make tests more tractable</span>
(stest/check `str {<span class="org-constant">:clojure.spec.test.check/opts</span> {<span class="org-constant">:max-size</span> 10}})
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline715" class="outline-4">
<h4 id="orgheadline715">LAB: Regex ops and functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline715">
</div><div id="outline-container-orgheadline703" class="outline-5">
<h5 id="orgheadline703">Alternating</h5>
<div class="outline-text-5" id="text-orgheadline703">
<p>
Write a regex spec for any number of pairs of strings and numbers.
</p>

<p>
Example: <code>["a" 5 "b" 0.2]</code>
</p>
</div>

<div id="outline-container-orgheadline704" class="outline-6">
<h6 id="orgheadline704">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline704">
<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::altks</span> (s/* (s/cat <span class="org-constant">:s</span> string? <span class="org-constant">:n</span> number?)))
(s/conform <span class="org-constant">::altks</span> [<span class="org-string">"a"</span> 5 <span class="org-string">"b"</span> 0.2])
<span class="org-comment-delimiter">;; </span><span class="org-comment">[{:s "a", :n 5} {:s "b", :n 0.2}]</span>
</pre>
</div>

<p>
Note that nested regex operations do not start a new level of nested
collection! Nested regex ops always join together to describe a
single sequential collection.
</p>

<p>
Consider if you wanted instead to parse actual pairs like 
<code>[["a" 5] ["b" 0.2]]</code>.
</p>

<p>
One choice is to notice that you are no longer specifying positional
syntax structure and use collection specs instead:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::altks2</span> (s/coll-of (s/tuple string? number?)))
(s/conform <span class="org-constant">::altks2</span> [[<span class="org-string">"a"</span> 5] [<span class="org-string">"b"</span> 0.2]])
<span class="org-comment-delimiter">;; </span><span class="org-comment">[["a" 5] ["b" 0.2]]</span>
</pre>
</div>

<p>
Or you can continue with sequential syntax and force a new
nested sequential context by wrapping the regex in <code>s/spec</code>:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::altks3</span> (s/* (s/spec (s/cat <span class="org-constant">:s</span> string? <span class="org-constant">:n</span> number?))))
(s/conform <span class="org-constant">::altks3</span> [[<span class="org-string">"a"</span> 5] [<span class="org-string">"b"</span> 0.2]])
<span class="org-comment-delimiter">;; </span><span class="org-comment">[{:s "a", :n 5} {:s "b", :n 0.2}]</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline705" class="outline-5">
<h5 id="orgheadline705">Lines</h5>
<div class="outline-text-5" id="text-orgheadline705">
<p>
Write a regex spec for a line defined by two x y coordinates (ints).
</p>

<p>
Example: <code>[0 0, 5 5]</code>
</p>
</div>

<div id="outline-container-orgheadline706" class="outline-6">
<h6 id="orgheadline706">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline706">
<p>
You could use a simple cat defining each number:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::line</span> (s/cat <span class="org-constant">:ax</span> int? <span class="org-constant">:bx</span> int? <span class="org-constant">:cx</span> int? <span class="org-constant">:dx</span> int?))
(s/conform <span class="org-constant">::line</span> [0 0 5 5])
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; {:ax 0, :bx 0, :cx 5, :dx 5}</span>
(s/explain <span class="org-constant">::line</span> [0 0 5])
<span class="org-comment-delimiter">;; </span><span class="org-comment">val: () fails spec: :user/line at: [:dx] predicate: int?,  Insufficient input</span>
</pre>
</div>

<p>
Or you might find it useful to define an intermediate <code>::point</code>:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::point</span> (s/cat <span class="org-constant">:x</span> int? <span class="org-constant">:y</span> int?))
(s/def <span class="org-constant">::line</span> (s/cat <span class="org-constant">:a</span> <span class="org-constant">::point</span> <span class="org-constant">:b</span> <span class="org-constant">::point</span>))
(s/conform <span class="org-constant">::line</span> [0 0 5 5])
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; {:a {:x 0, :y 0}, :b {:x 5, :y 5}}</span>
(s/explain <span class="org-constant">::line</span> [0 0 5])
<span class="org-comment-delimiter">;; </span><span class="org-comment">val: () fails spec: :user/line at: [:b :y] predicate: int?,  Insufficient input</span>
</pre>
</div>

<p>
Compare the conform and explain results to see how they differ.
Depending on how you expect to use this spec you may prefer one path
or another.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline707" class="outline-5">
<h5 id="orgheadline707">Polygons</h5>
<div class="outline-text-5" id="text-orgheadline707">
<p>
Write a regex spec for a polygon made of any number of x y
coordinates. Add a constraint to require at least 3 points.
</p>

<p>
Example: <code>[0 0, 5 5, 10 10]</code>
</p>
</div>

<div id="outline-container-orgheadline708" class="outline-6">
<h6 id="orgheadline708">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline708">
<p>
We can use s/&amp; to add an arbitrary constraint:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::polygon</span> (s/&amp; (s/* <span class="org-constant">::point</span>)
                      #(<span class="org-variable-name">&gt;</span> (<span class="org-variable-name">count</span> %) 2)))

(s/conform <span class="org-constant">::polygon</span> [0 0 5 5 10 10])
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; [{:x 0, :y 0} {:x 5, :y 5} {:x 10, :y 10}]</span>
(s/explain <span class="org-constant">::polygon</span> [0 0])
<span class="org-comment-delimiter">;; </span><span class="org-comment">val: [{:x 0, :y 0}] fails spec: :user/polygon predicate: (&gt; (count %) 2)</span>
</pre>
</div>

<p>
Another solution to this is to explicitly spec the first two points,
then specify s/+ for the rest. The downside of that approach is that
the conformed value will separate the first two points from the rest.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline709" class="outline-5">
<h5 id="orgheadline709">range args</h5>
<div class="outline-text-5" id="text-orgheadline709">
<p>
The <code>range</code> function takes several arity versions:
<code>([] [end] [start end] [start end step])</code>
</p>

<p>
Write a spec that accepts all of these choices as if they an
apply-able list of arguments. <code>range</code> accepts any kind of number for
its arguments.
</p>

<p>
Tests:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(s/conform <span class="org-constant">::range</span> [])
(s/conform <span class="org-constant">::range</span> [10])
(s/conform <span class="org-constant">::range</span> [5 10])
(s/conform <span class="org-constant">::range</span> [0 5/2 1/2])
</pre>
</div>
</div>

<div id="outline-container-orgheadline710" class="outline-6">
<h6 id="orgheadline710">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline710">
<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::range</span>
  (s/? (s/cat <span class="org-constant">:start</span> (s/? number?)
              <span class="org-constant">:end</span> number?
              <span class="org-constant">:step</span> (s/? number?))))

(s/conform <span class="org-constant">::range</span> [])
(s/conform <span class="org-constant">::range</span> [10])
(s/conform <span class="org-constant">::range</span> [5 10])
(s/conform <span class="org-constant">::range</span> [5 10 0.5])
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline711" class="outline-5">
<h5 id="orgheadline711">Revisiting range</h5>
<div class="outline-text-5" id="text-orgheadline711">
<p>
Write a spec for range (use the spec we wrote in the regex lab
describing the arguments to range). Don't define the :ret or :fn
specs. Run <code>check</code> to test it.
</p>
</div>

<div id="outline-container-orgheadline712" class="outline-6">
<h6 id="orgheadline712">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline712">
<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::range</span>
  (s/? (s/cat <span class="org-constant">:start</span> (s/? number?)
              <span class="org-constant">:end</span> number?
              <span class="org-constant">:step</span> (s/? number?))))

(s/fdef clojure.core/range
  <span class="org-constant">:args</span> <span class="org-constant">::range</span>
  <span class="org-constant">:ret</span> seqable?)

(stest/check 'clojure.core/range)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline713" class="outline-5">
<h5 id="orgheadline713">Range constraints</h5>
<div class="outline-text-5" id="text-orgheadline713">
<p>
Now add a <code>:fn</code> spec that checks that the first value in the returned
sequence matches the start value (if there is one).
</p>
</div>

<div id="outline-container-orgheadline714" class="outline-6">
<h6 id="orgheadline714">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline714">
<div class="org-src-container">

<pre class="src src-clojure">(s/fdef clojure.core/range
  <span class="org-constant">:args</span> <span class="org-constant">::range</span>
  <span class="org-constant">:fn</span> #(<span class="org-builtin">if-let</span> [start (<span class="org-builtin">-&gt;</span> % <span class="org-constant">:args</span> <span class="org-constant">:start</span>)]
         (<span class="org-variable-name">=</span> start (<span class="org-builtin">-&gt;</span> % <span class="org-constant">:ret</span> first))))

(stest/check 'clojure.core/range)
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline729" class="outline-4">
<h4 id="orgheadline729">Generators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline729">
</div><div id="outline-container-orgheadline716" class="outline-5">
<h5 id="orgheadline716">clojure.spec.alpha.gen&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline716">
<ul class="org-ul">
<li>Dynamically loaded versions of functions from test.check.generators
<ul class="org-ul">
<li>Don't need test.check dependency if not used</li>
</ul></li>
<li>Value generators: <code>any any-printable boolean bytes</code>
   <code>char char-alpha char-alphanumeric char-ascii double double* int</code>
   <code>keyword keyword-ns large-integer large-integer* ratio simple-type</code>
   <code>simple-type-printable string string-alphanumeric string-ascii</code>
   <code>symbol symbol-ns uuid</code></li>
<li>Combinators - <code>bind cat choose elements fmap list map not-empty
  one-of return set such-that tuple vector vector-distinct</code></li>
<li>Use - <code>generate sample</code></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline717" class="outline-5">
<h5 id="orgheadline717">Using generators directly&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline717">
<ul class="org-ul">
<li>We've already seen <code>s/exercise</code></li>
<li>You can also use the clojure.spec.gen.alpha functions to generate</li>
<li><code>s/gen</code> returns the generator for any spec</li>
<li><code>gen/generate</code> produces a single sample</li>
<li><code>gen/sample</code> returns several samples</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">require</span> '[clojure.spec.gen.alpha <span class="org-constant">:as</span> gen])
(gen/sample (s/gen int?))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; (0 0 -1 0 2 -1 -1 -1 3 0)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline718" class="outline-5">
<h5 id="orgheadline718">Why to specify custom generators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline718">
<ul class="org-ul">
<li>Automatic generators have filters that are too sparse</li>
<li>Arguments have relationships that need to be modeled</li>
<li>Making generated examples closer to real data</li>
<li>Making generators faster</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline719" class="outline-5">
<h5 id="orgheadline719">Where to specify custom generators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline719">
<ul class="org-ul">
<li>Many places to specify custom generators
<ul class="org-ul">
<li><code>s/with-gen</code> - wrap spec with custom gen</li>
<li><code>s/spec</code> - create initial spec with gen</li>
<li><code>s/every</code>, <code>s/every-kv</code>, <code>s/coll-of</code>, <code>s/map-of</code></li>
<li><code>s/fspec</code></li>
<li><code>s/keys</code></li>
</ul></li>
<li>Overrides
<ul class="org-ul">
<li><code>s/exercise</code>, <code>s/gen</code></li>
<li>Later: <code>stest/instrument</code>, <code>stest/check</code></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline720" class="outline-5">
<h5 id="orgheadline720">Generating formatted strings&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline720">
<ul class="org-ul">
<li>Consider a spec that accepts strings in a certain format</li>
<li>The automatic generator will generate values from the first pred,
then filter by the second</li>
<li>In this case, generated strings are unlikely to be valid IDs</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">id-regex</span> #<span class="org-string">"ID-[0-9]{6}"</span>)
(s/def <span class="org-constant">::id</span> (s/and string? #(<span class="org-variable-name">re-matches</span> id-regex %)))
(gen/sample (s/gen <span class="org-constant">::id</span>))
<span class="org-comment-delimiter">;; </span><span class="org-comment">ExceptionInfo Couldn't satisfy such-that predicate after 100 tries.</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline721" class="outline-5">
<h5 id="orgheadline721">Building generators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline721">
<ul class="org-ul">
<li>Our ids have a "ID-" prefix and a 6 digit number</li>
<li>Generate valid numbers, then apply a function to produce a sample</li>
<li>The easiest way to write generators is to write specs, then use
their generator</li>
<li><code>gen/fmap</code> creates a generator that applies a function to the
result of another generator</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline722" class="outline-5">
<h5 id="orgheadline722">Building generators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline722">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">id-gen</span>
  (gen/fmap #(<span class="org-variable-name">str</span> <span class="org-string">"ID-"</span> %)
    (s/gen (s/int-in 100000 999999))))

(s/def <span class="org-constant">::id</span>
  (s/with-gen (s/and string? #(<span class="org-variable-name">re-matches</span> id-regex %))
    (<span class="org-variable-name">constantly</span> id-gen)))

(gen/sample (s/gen <span class="org-constant">::id</span>))
<span class="org-comment-delimiter">;; </span><span class="org-comment">("ID-100000" "ID-100001" "ID-100000" "ID-100003" "ID-100005" ...)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline723" class="outline-5">
<h5 id="orgheadline723">Enumerating concrete values&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline723">
<ul class="org-ul">
<li>For a very narrow generator, just gen from an enumerated set</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::stooge</span>
  (s/with-gen string?
    #(s/gen #{<span class="org-string">"Larry"</span> <span class="org-string">"Curly"</span> <span class="org-string">"Moe"</span>})))

(gen/sample (s/gen <span class="org-constant">::stooge</span>))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; ("Larry" "Curly" "Larry" "Moe" "Larry" "Larry" "Curly" ...)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline724" class="outline-5">
<h5 id="orgheadline724">Generating related values&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline724">
<ul class="org-ul">
<li>Consider this spec and its default generator:</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::point</span> (s/tuple int? int?))
(s/def <span class="org-constant">::square</span> (s/coll-of <span class="org-constant">::point</span> <span class="org-constant">:count</span> 4))

<span class="org-comment-delimiter">;; </span><span class="org-comment">generates examples like: [[8 0] [-42 -14] [0 0] [2 2]]</span>
</pre>
</div>

<ul class="org-ul">
<li><code>::square</code> has additional unsatisfied constraints</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline725" class="outline-5">
<h5 id="orgheadline725">Modeling the values&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline725">
<ul class="org-ul">
<li>Model the square as 2 x values and 2 y values
<ul class="org-ul">
<li>where x1 != x2 and y1 != y2</li>
</ul></li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">square-model</span>
  (s/gen (s/and (s/tuple int? int? int? int?)
                (<span class="org-variable-name">fn</span> [[x1 x2 y1 y2]] 
                  (<span class="org-builtin">and</span> (<span class="org-variable-name">not=</span> x1 x2) (<span class="org-variable-name">not=</span> y1 y2))))))

(gen/sample square-model)
<span class="org-comment-delimiter">;; </span><span class="org-comment">([6 -3 -7 7] [0 -1 -2 0] [-2 -1 -1 0] [-1 1 -1 -2] ...)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline726" class="outline-5">
<h5 id="orgheadline726">Generate valid squares from the model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline726">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">square-gen</span> []
  (gen/fmap
    (<span class="org-variable-name">fn</span> [[x1 x2 y1 y2]]
      [[x1 y1] [x1 y2] [x2 y1] [x2 y2]])
    square-model))

(gen/sample (square-gen))
<span class="org-comment-delimiter">;; </span><span class="org-comment">([[0 0] [0 -1] [-1 0] [-1 -1]] </span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">[[-1 0] [-1 -1] [0 0] [0 -1]] </span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">[[-1 -4] [-1 0] [0 -4] [0 0]] ...)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline727" class="outline-5">
<h5 id="orgheadline727">Generators around a model&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline727">
<ul class="org-ul">
<li>Use <code>gen/bind</code> to enhance a model with more generators</li>
<li>Never use an external source of randomness! 
<ul class="org-ul">
<li>If you do this, your generator is not repeatable and can't be
shrunk automatically</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline728" class="outline-5">
<h5 id="orgheadline728">bind example&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline728">
<ul class="org-ul">
<li>Spec: <code>(s/cat :m (s/map-of int? int?) :k int?)</code></li>
<li>Example: generating a map and a random key within it</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">map-key-gen</span> []
  (gen/bind
    (s/gen (s/map-of int? int? <span class="org-constant">:min-count</span> 1 <span class="org-constant">:gen-max</span> 3))
    #(gen/tuple
      (gen/return %)
      (s/gen (<span class="org-variable-name">set</span> (<span class="org-variable-name">keys</span> %))))))
(gen/sample (map-key-gen))
<span class="org-comment-delimiter">;; </span><span class="org-comment">([{0 0} 0] </span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">[{-1 -1, 0 -1} 0] </span>
<span class="org-comment-delimiter">;;  </span><span class="org-comment">[{-1 6, -4 -3, -2 -7} -4] ... )</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline738" class="outline-4">
<h4 id="orgheadline738">LAB: Custom generators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline738">
</div><div id="outline-container-orgheadline730" class="outline-5">
<h5 id="orgheadline730">Constant generator</h5>
<div class="outline-text-5" id="text-orgheadline730">
<p>
Sometimes it's useful to just create a generator that hard-codes a
known value. Given the spec <code>(s/def ::i int?)</code>, exercise <code>::i</code> but
override the generator to always return <code>42</code>.
</p>
</div>

<div id="outline-container-orgheadline731" class="outline-6">
<h6 id="orgheadline731">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline731">
<div class="org-src-container">

<pre class="src src-clojure">(s/exercise <span class="org-constant">::i</span> 10 {<span class="org-constant">::i</span> #(gen/return 42)})
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline732" class="outline-5">
<h5 id="orgheadline732">Enumerated generator</h5>
<div class="outline-text-5" id="text-orgheadline732">
<p>
Extend the last example and exercise <code>::i</code> with a custom generator
that returns 1, 2, or 3. Remember that you can produce a generator
from any spec! This is often the easiest way to make a generator
(easier than constructing one yourself).
</p>
</div>

<div id="outline-container-orgheadline733" class="outline-6">
<h6 id="orgheadline733">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline733">
<div class="org-src-container">

<pre class="src src-clojure">(s/exercise <span class="org-constant">::i</span> 10 {<span class="org-constant">::i</span> #(s/gen #{1 2 3})})
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline734" class="outline-5">
<h5 id="orgheadline734">Restricted keyword spec</h5>
<div class="outline-text-5" id="text-orgheadline734">
<p>
Given a spec for keywords in the <code>xyz</code> namespace:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::kwid</span> (s/and qualified-keyword? #(<span class="org-variable-name">=</span> (<span class="org-variable-name">namespace</span> %) <span class="org-string">"xyz"</span>)))
</pre>
</div>

<p>
Write a custom generator that creates keyword with the "xyz" namespace
and alphanumeric names.
</p>

<p>
Use <code>gen/fmap</code> to implement the generator, based on
<code>gen/string-alphanumeric</code>, then supply the generator to the spec with
<code>s/with-gen</code>. Remember that <code>with-gen</code> takes a no-arg function that
returns the generator!
</p>
</div>

<ul class="org-ul"><li><a id="orgheadline735"></a>Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span><br  /><div class="outline-text-7" id="text-orgheadline735">
<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::kwid</span>
  (s/with-gen
    (s/and qualified-keyword? #(<span class="org-variable-name">=</span> (<span class="org-variable-name">namespace</span> %) <span class="org-string">"xyz"</span>))
    #(gen/fmap 
      (<span class="org-variable-name">fn</span> [s] (<span class="org-variable-name">keyword</span> <span class="org-string">"xyz"</span> s))
      (gen/string-alphanumeric))))

(gen/sample (s/gen <span class="org-constant">::kwid</span>) 5)
<span class="org-comment-delimiter">;; </span><span class="org-comment">(:xyz/ :xyz/M :xyz/0 :xyz/5n :xyz/l91)</span>
</pre>
</div>
</div></li></ul>
</div>

<div id="outline-container-orgheadline736" class="outline-5">
<h5 id="orgheadline736">More restricted keyword spec</h5>
<div class="outline-text-5" id="text-orgheadline736">
<p>
Let's consider a keyword spec that's even more restricted - 
namespace starts with <code>foo</code> and name starts with <code>bar</code>:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">require</span> '[clojure.string <span class="org-constant">:as</span> str])
(s/def <span class="org-constant">::kwid2</span> 
  (s/and qualified-keyword?
         #(str/starts-with? (<span class="org-variable-name">namespace</span> %) <span class="org-string">"foo"</span>)
         #(str/starts-with? (<span class="org-variable-name">name</span> %) <span class="org-string">"bar"</span>)))

(s/valid? <span class="org-constant">::kwid2</span> <span class="org-constant">:foo5/bar10</span>)
</pre>
</div>

<p>
In this case we want to start with two random suffix strings and
generate a valid keyword. One useful pattern is to use <code>s/tuple</code>
to generate your random "parts", then construct the final 
result with <code>s/fmap</code>. Try it!
</p>
</div>

<div id="outline-container-orgheadline737" class="outline-6">
<h6 id="orgheadline737">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h6>
<div class="outline-text-6" id="text-orgheadline737">
<div class="org-src-container">

<pre class="src src-clojure">(s/def <span class="org-constant">::kwid2</span>
  (s/with-gen
    (s/and qualified-keyword?
           #(str/starts-with? (<span class="org-variable-name">namespace</span> %) <span class="org-string">"foo"</span>)
           #(str/starts-with? (<span class="org-variable-name">name</span> %) <span class="org-string">"bar"</span>))
    #(gen/fmap
      (<span class="org-variable-name">fn</span> [[n1 n2]] (<span class="org-variable-name">keyword</span> (<span class="org-variable-name">str</span> <span class="org-string">"foo"</span> n1) (<span class="org-variable-name">str</span> <span class="org-string">"bar"</span> n2)))
      (gen/tuple (gen/string-alphanumeric) (gen/string-alphanumeric)))))

(s/exercise <span class="org-constant">::kwid2</span>)
<span class="org-comment-delimiter">;; </span><span class="org-comment">([:foo/bar :foo/bar] [:foo3/bar :foo3/bar] [:fooE/bar7 :fooE/bar7] [:foood2/barbE :foood2/barbE] ...</span>
</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline739" class="outline-3">
<h3 id="orgheadline739">Macros&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-orgheadline739">
</div>

<div id="outline-container-orgheadline744" class="outline-4">
<h4 id="orgheadline744">Overview</h4>
<div class="outline-text-4" id="text-orgheadline744">
</div><div id="outline-container-orgheadline740" class="outline-5">
<h5 id="orgheadline740">Clojure Evaluation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline740">

<div class="figure">
<p><object type="image/svg+xml" data="slide-assets/macro-evaluation.svg" >
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline741" class="outline-5">
<h5 id="orgheadline741">Macros&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline741">
<ul class="org-ul">
<li>Pure functions</li>
<li>Code as input, code as output</li>
<li>Called during <b>compilation</b></li>
<li>Do not exist at runtime</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline742" class="outline-5">
<h5 id="orgheadline742">Normal Compilation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline742">
<div class="org-src-container">

<pre class="src src-clojure">(foo bar baz)
</pre>
</div>

<ul class="org-ul">
<li>If <code>foo</code> is not a macro, emit bytecode to:
<ul class="org-ul">
<li>Evaluate <code>bar</code> and <code>baz</code></li>
<li>Cast <code>foo</code> to IFn</li>
<li>Invoke <code>foo</code> on values of <code>bar baz</code></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline743" class="outline-5">
<h5 id="orgheadline743">Macro Compilation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline743">
<div class="org-src-container">

<pre class="src src-clojure">(foo bar baz)
</pre>
</div>

<ul class="org-ul">
<li>If <code>foo</code> is a macro:
<ul class="org-ul">
<li>Do not evaluate <code>bar baz</code></li>
<li>Call <code>foo</code> with literal <code>bar baz</code> as arguments</li>
<li>Replace <code>(foo bar baz)</code> with returned code</li>
<li>Continue compiling</li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline758" class="outline-4">
<h4 id="orgheadline758">Writing Macros</h4>
<div class="outline-text-4" id="text-orgheadline758">
</div><div id="outline-container-orgheadline745" class="outline-5">
<h5 id="orgheadline745">How to Write a Macro&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline745">
<ul class="org-ul">
<li>Think of what you want to type</li>
<li>Think of what you want it to become</li>
<li>Write macro as a function that transforms the former into the latter</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline746" class="outline-5">
<h5 id="orgheadline746">Example: when&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline746">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">We want to write</span>
(<span class="org-builtin">when</span> condition
  (foo)
  (bar))

<span class="org-comment-delimiter">;; </span><span class="org-comment">And have it become</span>
(<span class="org-builtin">if</span> condition
  (<span class="org-builtin">do</span> (foo)
      (bar)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline747" class="outline-5">
<h5 id="orgheadline747">Example: when&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline747">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">And have it become</span>
(<span class="org-builtin">if</span> condition
  (<span class="org-builtin">do</span> (foo)
      (bar)))

<span class="org-comment-delimiter">;; </span><span class="org-comment">Write a macro:</span>
(<span class="org-keyword">defmacro</span> <span class="org-function-name">when</span> [test &amp; body]
  (<span class="org-variable-name">list</span> 'if test (<span class="org-variable-name">cons</span> 'do body)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline748" class="outline-5">
<h5 id="orgheadline748">Macroexpansion&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline748">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">Write a macro:</span>
(<span class="org-keyword">defmacro</span> <span class="org-function-name">when</span> [test &amp; body]
  (<span class="org-variable-name">list</span> 'if test (<span class="org-variable-name">cons</span> 'do body)))

<span class="org-comment-delimiter">;; </span><span class="org-comment">Test with macroexpand:</span>
(<span class="org-variable-name">macroexpand-1</span> '(<span class="org-builtin">when</span> condition (foo) (bar)))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; (if condition (do (foo) (bar)))</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline749" class="outline-5">
<h5 id="orgheadline749">Syntax-Quote (<code>`</code>)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline749">
<ul class="org-ul">
<li>A template that looks like the expansion</li>
<li>Easier than constructing code manually</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defmacro</span> <span class="org-function-name">when</span> [test &amp; body]
  (<span class="org-variable-name">list</span> 'if test (<span class="org-variable-name">cons</span> 'do body)))

<span class="org-comment-delimiter">;; </span><span class="org-comment">same thing with syntax-quote</span>
(<span class="org-keyword">defmacro</span> <span class="org-function-name">when2</span> [test &amp; body]
  `(<span class="org-builtin">if</span> ~test (<span class="org-builtin">do</span> ~@body)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline750" class="outline-5">
<h5 id="orgheadline750">Syntax-Quote on Symbols&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline750">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">Qualified symbols left as-is</span>
`clojure.core/list  <span class="org-comment">;=&gt; clojure.core/list</span>
`<span class="org-preprocessor">java.util.List</span>     <span class="org-comment">;=&gt; java.util.List</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">Special forms left as-is</span>
`do    <span class="org-comment">;=&gt; do</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">Unqualified symbols resolved in namespace</span>
`foo   <span class="org-comment">;=&gt; user/foo</span>
`<span class="org-preprocessor">List</span>  <span class="org-comment">;=&gt; user/List</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline751" class="outline-5">
<h5 id="orgheadline751">Syntax-Quote on Collections&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline751">
<div class="org-src-container">

<pre class="src src-clojure">`(1 2 3)  <span class="org-comment">;=&gt; (1 2 3)</span>

`(a b)    <span class="org-comment">;=&gt; (user/a user/b)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline752" class="outline-5">
<h5 id="orgheadline752">Unquote (<code>~</code>)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline752">
<ul class="org-ul">
<li>Only valid inside syntax-quote</li>
<li>Turns off syntax-quote for next form</li>
<li>Unquote-splicing (<code>~@</code>)
<ul class="org-ul">
<li>"Splices" in a sequence of values</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline753" class="outline-5">
<h5 id="orgheadline753">Unquote Examples&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline753">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">In the 'user' namespace:</span>

(<span class="org-keyword">def</span> <span class="org-function-name">x</span> 42)       <span class="org-comment">;=&gt; #'user/x</span>

`(x ~x)          <span class="org-comment">;=&gt; (user/x 42)</span>


(<span class="org-keyword">def</span> <span class="org-function-name">y</span> [1 2 3])  <span class="org-comment">;=&gt; #'user/y</span>

`(y ~@y ~y)      <span class="org-comment">;=&gt; (user/y 1 2 3 [1 2 3])</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline754" class="outline-5">
<h5 id="orgheadline754">Auto-Gensym&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline754">
<ul class="org-ul">
<li>Within syntax-quote</li>
<li>Symbols ending with <code>#</code> get unique, generated names</li>
<li>All uses within one syntax-quote are the same</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline755" class="outline-5">
<h5 id="orgheadline755">Auto-Gensym Examples&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline755">
<ul class="org-ul">
<li>Each syntax-quote produces new unique gemsyms</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">`(x x# x#)  <span class="org-comment">;=&gt; (user/x x__10 x__10)</span>

`(x x# x#)  <span class="org-comment">;=&gt; (user/x x__13 x__13)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline756" class="outline-5">
<h5 id="orgheadline756">Example: <code>or</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline756">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">We want to write:</span>
(<span class="org-builtin">or</span> a b c)

<span class="org-comment-delimiter">;; </span><span class="org-comment">And have it become:</span>
(<span class="org-builtin">let</span> [or__42 a]
  (<span class="org-builtin">if</span> or__42
    or__42
    (<span class="org-builtin">or</span> b c))) <span class="org-comment">; note "recursion"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline757" class="outline-5">
<h5 id="orgheadline757">Example: <code>or</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline757">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">Write a macro:</span>
(<span class="org-keyword">defmacro</span> <span class="org-function-name">or</span>
  ([] nil)
  ([x] x)
  ([x &amp; next]
    `(<span class="org-builtin">let</span> [or# ~x]
       (<span class="org-builtin">if</span> or# or# (<span class="org-builtin">or</span> ~@next)))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline760" class="outline-4">
<h4 id="orgheadline760">Encapsulating Patterns</h4>
<div class="outline-text-4" id="text-orgheadline760">
</div><div id="outline-container-orgheadline759" class="outline-5">
<h5 id="orgheadline759">Encapsulating Patterns&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline759">
<ul class="org-ul">
<li>Macros often used to implement patterns in code</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defmacro</span> <span class="org-function-name">with-open</span> [bindings &amp; body]
  `(<span class="org-builtin">let</span> ~bindings
     (<span class="org-builtin">try</span> ~@body
          (<span class="org-builtin">finally</span>
           (<span class="org-preprocessor">.close</span> ~(<span class="org-variable-name">first</span> bindings))))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline764" class="outline-4">
<h4 id="orgheadline764">Common Macros</h4>
<div class="outline-text-4" id="text-orgheadline764">
</div><div id="outline-container-orgheadline761" class="outline-5">
<h5 id="orgheadline761">Common Macros&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline761">
<ul class="org-ul">
<li>Branching
<ul class="org-ul">
<li><code>and or when when-not when-let</code></li>
<li><code>if-not if-let cond condp</code></li>
</ul></li>
<li>Looping
<ul class="org-ul">
<li><code>for doseq dotimes while</code></li>
</ul></li>
<li>Definitions
<ul class="org-ul">
<li><code>ns declare defn defmacro</code></li>
</ul></li>
<li>Some other examples&#x2026;</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline762" class="outline-5">
<h5 id="orgheadline762">Threading Macros&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline762">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">Thread-first:</span>
(<span class="org-builtin">-&gt;</span> x
    (foo 1 2)
    (bar 3 4))   <span class="org-comment">;=&gt; (bar (foo x 1 2) 3 4)</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">Thread-last:</span>
(<span class="org-builtin">-&gt;&gt;</span> x
     (foo 1 2)
     (bar 3 4))  <span class="org-comment">;=&gt; (bar 3 4 (foo 1 2 x))</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline763" class="outline-5">
<h5 id="orgheadline763"><code>doto</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline763">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">doto</span> (<span class="org-preprocessor">ClassName.</span>)
  (<span class="org-preprocessor">.setFoo</span> 1)
  (<span class="org-preprocessor">.setBar</span> 2))

<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt;</span>
(<span class="org-builtin">let</span> [x# (<span class="org-preprocessor">ClassName.</span>)]
  (<span class="org-preprocessor">.setFoo</span> x# 1)
  (<span class="org-preprocessor">.setBar</span> x# 2)
  x#)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline766" class="outline-4">
<h4 id="orgheadline766">Motivation</h4>
<div class="outline-text-4" id="text-orgheadline766">
</div><div id="outline-container-orgheadline765" class="outline-5">
<h5 id="orgheadline765">When to Use Macros&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline765">
<ul class="org-ul">
<li>Only for things functions can't do
<ul class="org-ul">
<li>Transform / generate / rearrange code</li>
<li>Prevent evaluation of some things
<ul class="org-ul">
<li>e.g. <code>and</code>, <code>or</code> can't be functions</li>
</ul></li>
</ul></li>
<li>Must be pure functions, code to code</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline767" class="outline-3">
<h3 id="orgheadline767">LAB: Macros&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-orgheadline767">
</div>

<div id="outline-container-orgheadline768" class="outline-4">
<h4 id="orgheadline768">Introduction</h4>
<div class="outline-text-4" id="text-orgheadline768">
<p>
Macros are often useful for metaprogramming tasks like testing and debugging. In this lab we will develop the <code>transcript</code> macro, which will print a series of expressions and their return values as if we had typed them at the REPL.
</p>
</div>
</div>

<div id="outline-container-orgheadline769" class="outline-4">
<h4 id="orgheadline769">The do-nothing macro</h4>
<div class="outline-text-4" id="text-orgheadline769">
<p>
Define a macro <code>just-do-it</code> which takes a body of expressions and expands to code which evaluates the expressions in order.
</p>
</div>

<div id="outline-container-orgheadline770" class="outline-5">
<h5 id="orgheadline770">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline770">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defmacro</span> <span class="org-function-name">just-do-it</span> [&amp; body]
  `(<span class="org-builtin">do</span> ~@body))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline771" class="outline-4">
<h4 id="orgheadline771">Do one thing at a time</h4>
<div class="outline-text-4" id="text-orgheadline771">
<p>
Define a macro <code>execute</code> which takes <b>one</b> expression and expands to code which first prints the expression, then evaluates it and prints the result.
</p>

<p>
Hint: to print the expression itself, you will need to quote it.
</p>
</div>

<div id="outline-container-orgheadline772" class="outline-5">
<h5 id="orgheadline772">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline772">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defmacro</span> <span class="org-function-name">execute</span> [expr]
  `(<span class="org-builtin">do</span> (<span class="org-variable-name">println</span> (quote ~expr))  <span class="org-comment">; could be written '~expr</span>
       (<span class="org-variable-name">println</span> ~expr)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline773" class="outline-4">
<h4 id="orgheadline773">Make it pretty</h4>
<div class="outline-text-4" id="text-orgheadline773">
<p>
Modify the <code>execute</code> macro to use <code>clojure.pprint/pprint</code> to pretty-print both the expression and the result.
</p>
</div>

<div id="outline-container-orgheadline774" class="outline-5">
<h5 id="orgheadline774">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline774">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">require</span> '[clojure.pprint <span class="org-constant">:refer</span> (pprint)])
</pre>
</div>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defmacro</span> <span class="org-function-name">execute</span> [expr]
  `(<span class="org-builtin">do</span> (pprint '~expr)
       (pprint ~expr)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline775" class="outline-4">
<h4 id="orgheadline775">Make it safe</h4>
<div class="outline-text-4" id="text-orgheadline775">
<p>
Modify the <code>execute</code> macro to catch and print any exceptions thrown by the expression. Use <code>clojure.repl/pst</code> (print stack trace) to print exceptions.
</p>

<p>
Hint: Catch <code>java.lang.Throwable</code>, not <code>java.lang.Exception</code>. You will need to use a gensym name (like <code>foo#</code>) for the exception object in the <code>catch</code> clause.
</p>
</div>

<div id="outline-container-orgheadline776" class="outline-5">
<h5 id="orgheadline776">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline776">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">use</span> '[clojure.repl <span class="org-constant">:only</span> (pst)])
</pre>
</div>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defmacro</span> <span class="org-function-name">execute</span> [expr]
  `(<span class="org-builtin">do</span> (pprint '~expr)
       (<span class="org-builtin">try</span> (pprint ~expr)
            (<span class="org-builtin">catch</span> <span class="org-preprocessor">Throwable</span> t#
              (pst t#)))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline777" class="outline-4">
<h4 id="orgheadline777">Do more than one thing</h4>
<div class="outline-text-4" id="text-orgheadline777">
<p>
Define a macro <code>transcript</code> that takes a body of multiple expressions and causes each one to be wrapped in <code>execute</code>.
</p>
</div>

<div id="outline-container-orgheadline778" class="outline-5">
<h5 id="orgheadline778">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline778">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defmacro</span> <span class="org-function-name">transcript</span> [&amp; body]
  (<span class="org-builtin">when</span> (<span class="org-variable-name">seq</span> body)
    `(<span class="org-builtin">do</span> (execute ~(<span class="org-variable-name">first</span> body))
         (transcript ~@(<span class="org-variable-name">rest</span> body)))))
</pre>
</div>

<p>
There are several ways to implement this macro. This solution shows a classic "recursive" macro technique, meaning that the expansion of <code>transcript</code> contains another "call" to <code>transcript</code>. It is not the same as a recursive function, because <code>transcript</code> does not actually call itself. Instead, it returns code which will evaluate the first expression and then expand <code>transcript</code> again on the remaining expressions. When there are no more expressions left (when <code>(seq body)</code> returns <code>nil</code>) the "recursion" terminates.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline779" class="outline-4">
<h4 id="orgheadline779">Bonus: Reuse intermediate results</h4>
<div class="outline-text-4" id="text-orgheadline779">
<p>
The Clojure REPL sets the Var <code>*1</code> to the result of the last expression. Redefine <code>transcript</code> to do something similar: make the result of the previous expression available as a local binding to the symbol <code>that</code>. 
</p>

<p>
This is known as an <a href="http://en.wikipedia.org/wiki/Anaphoric_macro">anaphoric macro</a> because <code>that</code> is never explicitly defined and appears "magically" within the body of the macro. Anaphoric macros are generally considered bad style in Clojure code, although Clojure itself has one (the <code>proxy</code> macro binds <code>this</code> within method bodies).
</p>

<p>
Hint: You will not be able to reuse the <code>execute</code> macro because it does not return a value. Instead, the <code>transcript</code> macro will do all the work. To capture the symbol <code>that</code> inside a syntax-quote, you will need to unquote-quote it, like this:
</p>

<div class="org-src-container">

<pre class="src src-clojure">`(<span class="org-builtin">let</span> [~'that ...]
   ...)
</pre>
</div>
</div>

<div id="outline-container-orgheadline780" class="outline-5">
<h5 id="orgheadline780">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline780">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defmacro</span> <span class="org-function-name">transcript</span> [&amp; body]
  (<span class="org-builtin">when</span> (<span class="org-variable-name">seq</span> body)
    `(<span class="org-builtin">do</span> (pprint '~(<span class="org-variable-name">first</span> body))
         (<span class="org-builtin">try</span> (<span class="org-builtin">let</span> [~'that ~(<span class="org-variable-name">first</span> body)]
                (pprint ~'that)
                (transcript ~@(<span class="org-variable-name">rest</span> body)))
              (<span class="org-builtin">catch</span> <span class="org-preprocessor">Throwable</span> t#
                (pst t#))))))
</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline865" class="outline-2">
<h2 id="orgheadline865">Optional Topics</h2>
<div class="outline-text-2" id="text-orgheadline865">
</div><div id="outline-container-orgheadline782" class="outline-3">
<h3 id="orgheadline782">Testing&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-orgheadline782">
</div>

<div id="outline-container-orgheadline783" class="outline-4">
<h4 id="orgheadline783">clojure.test&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline783">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">In project at test/com/example/my_app_tests.clj</span>
(<span class="org-builtin">ns</span> com.example.my-app-tests
  (<span class="org-constant">:require</span> [clojure.test <span class="org-constant">:refer</span> (<span class="org-keyword">deftest</span> <span class="org-function-name">is</span>)]))

(<span class="org-keyword">deftest</span> <span class="org-function-name">t-addition</span>         <span class="org-comment">; define a test</span>
  (<span class="org-type">is</span> (<span class="org-variable-name">=</span> 7 (<span class="org-variable-name">+</span> 3 4)))        <span class="org-comment">; make assertions</span>
  (<span class="org-type">is</span> (<span class="org-variable-name">=</span> 5 (<span class="org-variable-name">+</span> 2 2))))
</pre>
</div>

<ul class="org-ul">
<li>Included with Clojure</li>
<li>Similar to xUnit frameworks in other languages</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline784" class="outline-4">
<h4 id="orgheadline784">Assertions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline784">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-type">is</span> expression message?)

<span class="org-comment-delimiter">;; </span><span class="org-comment">use optional message to clarify</span>
(<span class="org-type">is</span> (<span class="org-variable-name">not</span> (face-up? (<span class="org-variable-name">get</span> hand 1)))
    (<span class="org-variable-name">str</span> <span class="org-string">"Expected 2nd card to be face down because it's Tuesday."</span>))

<span class="org-comment-delimiter">;; </span><span class="org-comment">optional message not necessary most of the time</span>
(<span class="org-type">is</span> (<span class="org-variable-name">pos?</span> x))
<span class="org-comment-delimiter">;; </span><span class="org-comment">expected: (pos? x)</span>
<span class="org-comment-delimiter">;;   </span><span class="org-comment">actual: (not (pos? -2))</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">Checking exception cases</span>
(<span class="org-type">is</span> (thrown? <span class="org-preprocessor">ClassCastException</span> (<span class="org-variable-name">+</span> 1 false)))
(<span class="org-type">is</span> (thrown-with-msg? <span class="org-preprocessor">ClassCastException</span>
                      #<span class="org-string">"cannot be cast"</span>
                      (<span class="org-variable-name">+</span> 1 false)))

<span class="org-comment-delimiter">;; </span><span class="org-comment">Always fail / pass</span>
(<span class="org-type">is</span> nil)
(<span class="org-type">is</span> true)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline785" class="outline-4">
<h4 id="orgheadline785">Data-driven tests&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline785">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-type">are</span> [expected a b] (<span class="org-variable-name">=</span> expected (<span class="org-variable-name">+</span> a b))
      3        1 2
      0       -1 1)
</pre>
</div>

<ul class="org-ul">
<li>Each partition of inputs is a separate case</li>
<li>Drawbacks
<ul class="org-ul">
<li>The <code>are</code> macro can't specify per-case failure strings</li>
<li>Error reporting of line numbers will always be the <code>are</code> expression</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline786" class="outline-4">
<h4 id="orgheadline786">test-runner&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline786">
<ul class="org-ul">
<li><a href="https://github.com/cognitect-labs/test-runner">https://github.com/cognitect-labs/test-runner</a></li>
<li>Add tool to deps.edn as alias</li>
<li>Run tests with alias</li>
</ul>
</div>

<div id="outline-container-orgheadline787" class="outline-5">
<h5 id="orgheadline787">Add test-runner tool&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline787">
<div class="org-src-container">

<pre class="src src-clojure">{<span class="org-constant">:deps</span> ...
 <span class="org-constant">:aliases</span> 
 {<span class="org-constant">:test</span> {<span class="org-constant">:extra-paths</span> [<span class="org-string">"test"</span>]
         <span class="org-constant">:extra-deps</span> {com.cognitect/test-runner
           {<span class="org-constant">:git/url</span> <span class="org-string">"https://github.com/cognitect-labs/test-runner.git"</span>
            <span class="org-constant">:sha</span> <span class="org-string">"028a6d41ac9ac5d5c405dfc38e4da6b4cc1255d5"</span>}}
         <span class="org-constant">:main-opts</span> [<span class="org-string">"-m"</span> <span class="org-string">"cognitect.test-runner"</span>]}}}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline788" class="outline-5">
<h5 id="orgheadline788">Run test-runner&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline788">
<ul class="org-ul">
<li>Run all tests</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">clj -A:test
</pre>
</div>

<ul class="org-ul">
<li>For more options, see the test-runner docs</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline789" class="outline-4">
<h4 id="orgheadline789">lein test&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline789">
<pre class="example">
$ lein test

lein test com.example.my-app-tests

FAIL in (t-addition) (my_app_tests.clj:6)
expected: (= 5 (+ 2 2))
  actual: (not (= 5 4))

Ran 1 tests containing 2 assertions.
1 failures, 0 errors.
Tests failed.
</pre>
</div>
</div>

<div id="outline-container-orgheadline790" class="outline-4">
<h4 id="orgheadline790">Example- vs property-based tests&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline790">
<ul class="org-ul">
<li>Example-based tests
<ul class="org-ul">
<li>Persist REPL-based tests</li>
<li>Give representative examples of use</li>
<li>Check specific boundary cases</li>
</ul></li>
<li>Property-based tests
<ul class="org-ul">
<li>Thorough coverage</li>
<li>Clarifies constraints in your code</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline791" class="outline-4">
<h4 id="orgheadline791">test.check&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline791">
<ul class="org-ul">
<li>Based on Haskell QuickCheck library</li>
<li>Define generators to create test examples</li>
<li>Specify properties that must hold for each example</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">In project.clj</span>
(defproject testing <span class="org-string">"0.1.0-SNAPSHOT"</span>
  <span class="org-constant">:dependencies</span> [[org.clojure/clojure <span class="org-string">"1.9.0"</span>]
                 [org.clojure/test.check <span class="org-string">"0.9.0"</span>]])

<span class="org-comment-delimiter">;; </span><span class="org-comment">In tests</span>
(<span class="org-variable-name">require</span> '[clojure.test.check <span class="org-constant">:as</span> tc])
(<span class="org-variable-name">require</span> '[clojure.test.check.generators <span class="org-constant">:as</span> gen])
(<span class="org-variable-name">require</span> '[clojure.test.check.properties <span class="org-constant">:as</span> prop])
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline792" class="outline-4">
<h4 id="orgheadline792">Basic generators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline792">
<ul class="org-ul">
<li>Generators used to generate random instances</li>
<li>Basic generators
<ul class="org-ul">
<li><code>gen/boolean</code>, <code>gen/byte</code>, <code>gen/ratio</code></li>
<li><code>gen/bytes</code> - random byte-arrays</li>
<li><code>gen/char</code>, <code>gen/char-alpha-numeric</code>, <code>gen/char-ascii</code></li>
<li><code>gen/int</code>, <code>gen/nat</code>, <code>gen/pos-int</code>, etc - integers</li>
<li><code>gen/choose</code> - numbers in a range with min and max</li>
<li><code>gen/keyword</code> - Clojure keywords</li>
<li><code>gen/string</code>, <code>gen/string-alpha-numeric</code>, <code>gen/string-ascii</code></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline793" class="outline-4">
<h4 id="orgheadline793">Sampling generators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline793">
<p>
Use <code>gen/sample</code> to get some samples from a generator:
</p>

<pre class="example">
(gen/sample gen/int)
;; =&gt; (0 -1 0 3 -3 -1 5 -5 -6 -7)

(gen/sample gen/string-alpha-numeric)
;; =&gt; ("" "o" "ca" "1" "7l0d" "0xY4Q" "4" "Pu5k9Uf" "4A022" "g")
</pre>
</div>
</div>

<div id="outline-container-orgheadline794" class="outline-4">
<h4 id="orgheadline794">Other generators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline794">
<ul class="org-ul">
<li>Create a generator collection with an element generator
<ul class="org-ul">
<li><code>gen/vector</code>, <code>gen/list</code>, <code>gen/hash-map</code></li>
</ul></li>
<li>Create tuples
<ul class="org-ul">
<li><code>gen/tuple</code></li>
</ul></li>
<li>Combine generators
<ul class="org-ul">
<li><code>gen/one-of</code>, <code>gen/frequency</code></li>
</ul></li>
<li>Filter generated values to those matching a predicate
<ul class="org-ul">
<li><code>gen/such-that</code></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline795" class="outline-4">
<h4 id="orgheadline795">Combining generators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline795">
<p>
Create random maps:
</p>

<pre class="example">
(gen/sample
  (gen/hash-map :name gen/string-alpha-numeric
                :age gen/nat))
;; =&gt; ({:age 0, :name ""} {:age 1, :name ""} {:age 0, :name "TF"}
;;     {:age 1, :name "8"} {:age 2, :name "2"} {:age 1, :name "rT"})
</pre>
</div>
</div>

<div id="outline-container-orgheadline796" class="outline-4">
<h4 id="orgheadline796">Specifying properties&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline796">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">prop-no-42</span>
  (prop/for-all [v (gen/vector gen/int)]
    (<span class="org-variable-name">not</span> (<span class="org-variable-name">some</span> #{42} v))))

(tc/quick-check 100 prop-no-42)
<span class="org-comment-delimiter">;; </span><span class="org-comment">=&gt; {:result false,</span>
       <span class="org-constant">:failing-size</span> 45,
       <span class="org-constant">:num-tests</span> 46,
       <span class="org-constant">:fail</span> [[10 1 28 40 11 -33 42 -42 39 -13 13 -44 -36 11 27 -42 4 21 -39]],
       <span class="org-constant">:shrunk</span> {<span class="org-constant">:total-nodes-visited</span> 38,
                <span class="org-constant">:depth</span> 18,
                <span class="org-constant">:result</span> false,
                <span class="org-constant">:smallest</span> [[42]]}}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline797" class="outline-4">
<h4 id="orgheadline797">Specifying properties&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline797">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">addition-is-associative</span>
  (prop/for-all [a gen/int
                 b gen/int
                 c gen/int]
    (<span class="org-variable-name">=</span> (<span class="org-variable-name">+</span> (<span class="org-variable-name">+</span> a b) c) (<span class="org-variable-name">+</span> a (<span class="org-variable-name">+</span> b c)))))

(tc/quick-check 1000 addition-is-associative)
<span class="org-comment-delimiter">;; </span><span class="org-comment">=&gt; {:result true, :num-tests 1000, :seed 1400277173531}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline798" class="outline-4">
<h4 id="orgheadline798">Integrating with clojure.test&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline798">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">require</span> '[clojure.test.check.clojure-test <span class="org-constant">:refer</span> (defspec)])

(defspec addition-is-associative 1000
  (prop/for-all [a gen/int
                 b gen/int
                 c gen/int]
    (<span class="org-variable-name">=</span> (<span class="org-variable-name">+</span> (<span class="org-variable-name">+</span> a b) c) (<span class="org-variable-name">+</span> a (<span class="org-variable-name">+</span> b c)))))
</pre>
</div>

<ul class="org-ul">
<li>Then use <code>lein test</code> or other runners as usual</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline799" class="outline-3">
<h3 id="orgheadline799">LAB: Testing</h3>
<div class="outline-text-3" id="text-orgheadline799">
</div>

<div id="outline-container-orgheadline800" class="outline-4">
<h4 id="orgheadline800">Introduction</h4>
<div class="outline-text-4" id="text-orgheadline800">
<p>
In this lab we'll be practicing writing tests against the <code>range</code>
function.
</p>
</div>
</div>

<div id="outline-container-orgheadline801" class="outline-4">
<h4 id="orgheadline801">Testing range</h4>
<div class="outline-text-4" id="text-orgheadline801">
<p>
Write a test that verifies the outputs for these example inputs to
range with the single argument "end". The default start value is 0
and step value is 1. Use <code>is</code> to verify each assertion.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">End</th>
<th scope="col" class="org-left">Expected output</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-left">'()</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">'(0)</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">'(0 1)</td>
</tr>

<tr>
<td class="org-right">-1</td>
<td class="org-left">'()</td>
</tr>
</tbody>
</table>

<p>
Before defining your test, you will need to require the clojure.test
namespace:  <code>(require '[clojure.test :refer :all])</code>
</p>

<p>
You can run your test by just running it as a no-argument function.
</p>
</div>

<div id="outline-container-orgheadline802" class="outline-5">
<h5 id="orgheadline802">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline802">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">require</span> '[clojure.test <span class="org-constant">:refer</span> <span class="org-constant">:all</span>])

(<span class="org-keyword">deftest</span> <span class="org-function-name">test-range</span>
  (<span class="org-type">is</span> (<span class="org-variable-name">=</span> '() (<span class="org-variable-name">range</span> 0)))
  (<span class="org-type">is</span> (<span class="org-variable-name">=</span> '(0) (<span class="org-variable-name">range</span> 1)))
  (<span class="org-type">is</span> (<span class="org-variable-name">=</span> '(0 1) (<span class="org-variable-name">range</span> 2)))
  (<span class="org-type">is</span> (<span class="org-variable-name">=</span> '() (<span class="org-variable-name">range</span> -1))))

(test-range)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; nil</span>
</pre>
</div>

<p>
If you modify your test so it fails, what do you see?
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline803" class="outline-4">
<h4 id="orgheadline803">Driving with data</h4>
<div class="outline-text-4" id="text-orgheadline803">
<p>
Rewrite the previous test to use <code>are</code> instead of is and provide many
examples at once.
</p>
</div>

<div id="outline-container-orgheadline804" class="outline-5">
<h5 id="orgheadline804">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline804">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">deftest</span> <span class="org-function-name">test-range</span>
  (<span class="org-type">are</span> [end expected] (<span class="org-variable-name">=</span> expected (<span class="org-variable-name">range</span> end))
    0 '()
    1 '(0)
    2 '(0 1)
    -1 '()))
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgheadline805" class="outline-4">
<h4 id="orgheadline805">Checking exceptions</h4>
<div class="outline-text-4" id="text-orgheadline805">
<p>
Calling range with something other than a number will result in an error.
Verify that <code>(range "abc")</code> throws a ClassCastException.
</p>
</div>

<div id="outline-container-orgheadline806" class="outline-5">
<h5 id="orgheadline806">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline806">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">deftest</span> <span class="org-function-name">test-range-err</span>
  (<span class="org-type">is</span> (thrown? <span class="org-preprocessor">ClassCastException</span> (<span class="org-variable-name">range</span> <span class="org-string">"abc"</span>))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline807" class="outline-4">
<h4 id="orgheadline807">Checking exception messages</h4>
<div class="outline-text-4" id="text-orgheadline807">
<p>
Rewrite the test to verify that the class name of the input
(java.lang.String) is included in the error message.
</p>
</div>

<div id="outline-container-orgheadline808" class="outline-5">
<h5 id="orgheadline808">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline808">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">deftest</span> <span class="org-function-name">test-range-err-msg</span>
  (<span class="org-type">is</span> (thrown-with-msg? <span class="org-preprocessor">ClassCastException</span> #<span class="org-string">"java.lang.String"</span> 
        (<span class="org-variable-name">range</span> <span class="org-string">"abc"</span>))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline809" class="outline-4">
<h4 id="orgheadline809">Specifying properties</h4>
<div class="outline-text-4" id="text-orgheadline809">
<p>
We will next create a test.check test for <code>range</code>. 
</p>

<p>
Start with some requires to load the right namespaces:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">require</span> '[clojure.test.check <span class="org-constant">:as</span> tc])
(<span class="org-variable-name">require</span> '[clojure.test.check.generators <span class="org-constant">:as</span> gen])
(<span class="org-variable-name">require</span> '[clojure.test.check.properties <span class="org-constant">:as</span> prop])
</pre>
</div>

<p>
What property can we assert about <code>count</code> when used with the
single-argument arity of range?
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">range</span> 5)
<span class="org-comment-delimiter">;; </span><span class="org-comment">(0 1 2 3 4)</span>
(<span class="org-variable-name">count</span> (<span class="org-variable-name">range</span> 5))
<span class="org-comment-delimiter">;; </span><span class="org-comment">5</span>
</pre>
</div>

<p>
Write a generative property that creates ranges of random positive
size and checks their count is correct. Run the test for 100
iterations.
</p>

<p>
See the test.check.generators api doc for generator functions:
<a href="https://clojure.github.io/test.check/clojure.test.check.generators.html">https://clojure.github.io/test.check/clojure.test.check.generators.html</a>
</p>
</div>

<div id="outline-container-orgheadline810" class="outline-5">
<h5 id="orgheadline810">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline810">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">range-count-eq-n</span> 
  (prop/for-all [n gen/pos-int]
    (<span class="org-variable-name">=</span> n (<span class="org-variable-name">count</span> (<span class="org-variable-name">range</span> n)))))

(tc/quick-check 100 range-count-eq-n)
</pre>
</div>

<p>
Note the use of <code>gen/pos-int</code> to constrain the range input values to
positive integers. What happens if you use gen/int instead? Why?
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline811" class="outline-3">
<h3 id="orgheadline811">Life on the JVM&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-orgheadline811">
</div>

<div id="outline-container-orgheadline812" class="outline-4">
<h4 id="orgheadline812">JVM Overview&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline812">
<ul class="org-ul">
<li>Clojure is tightly integrated with the JVM</li>
<li>Can manipulate Java primitives, arrays, and generate classes
<ul class="org-ul">
<li>Allows Clojure to both consume and implement Java APIs</li>
</ul></li>
<li>As fast as Java if written correctly</li>
<li>Clojure can be incrementally added to a Java project, or vice versa</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline819" class="outline-4">
<h4 id="orgheadline819">Passing Data to/from Java&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline819">
</div><div id="outline-container-orgheadline813" class="outline-5">
<h5 id="orgheadline813">Arrays&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline813">
<ul class="org-ul">
<li>Used in Clojure for interop, performance</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">nums</span> (<span class="org-variable-name">int-array</span> 10))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #'user/nums</span>

(<span class="org-variable-name">aset</span> nums 4 1000)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 1000</span>

(<span class="org-variable-name">aget</span> nums 4)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 1000</span>

(<span class="org-variable-name">seq</span> nums)
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; (0 0 0 0 1000 0 0 0 0 0)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline814" class="outline-5">
<h5 id="orgheadline814">Arrays from Seqs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline814">
<ul class="org-ul">
<li>Prefer Clojure collections</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">def</span> <span class="org-function-name">nums</span> (<span class="org-variable-name">range</span> 3))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; #'user/nums</span>

(<span class="org-variable-name">class</span> (<span class="org-variable-name">to-array</span> nums))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; [Ljava.lang.Object;   ; Java array of Object</span>

(<span class="org-variable-name">class</span> (<span class="org-variable-name">into-array</span> nums))  <span class="org-comment">; infer type from first</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; [Ljava.lang.Long;</span>

(<span class="org-variable-name">class</span> (<span class="org-variable-name">into-array</span> <span class="org-preprocessor">Comparable</span> nums))  <span class="org-comment">; specify type</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; [Ljava.lang.Comparable;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline815" class="outline-5">
<h5 id="orgheadline815">Varargs in Java&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline815">
<div class="org-src-container">

<pre class="src src-fundamental">// Java
public class String {
  static String format(String format, Object... args) { //...
</pre>
</div>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">Clojure</span>
(<span class="org-preprocessor">String/format</span> <span class="org-string">"Qty: %d   Total: $%.2f"</span> (object-array [5 23.5]))
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "Qty: 5   Total: $23.50"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline816" class="outline-5">
<h5 id="orgheadline816">Clojure Types are Java Types&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline816">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Clojure Type</th>
<th scope="col" class="org-left">Java Type</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Long</td>
<td class="org-left">java.lang.Long</td>
</tr>

<tr>
<td class="org-left">Double</td>
<td class="org-left">java.lang.Double</td>
</tr>

<tr>
<td class="org-left">Boolean</td>
<td class="org-left">java.lang.Boolean</td>
</tr>

<tr>
<td class="org-left">String</td>
<td class="org-left">java.lang.String</td>
</tr>

<tr>
<td class="org-left">Regex</td>
<td class="org-left">java.util.regex.Pattern</td>
</tr>

<tr>
<td class="org-left">BigDecimal</td>
<td class="org-left">java.lang.BigDecimal</td>
</tr>

<tr>
<td class="org-left">Ratio</td>
<td class="org-left">clojure.lang.Ratio</td>
</tr>

<tr>
<td class="org-left">BigInt</td>
<td class="org-left">clojure.lang.BigInt*</td>
</tr>
</tbody>
</table>

<p>
*Wraps java.lang.BigInteger or long
</p>
</div>
</div>

<div id="outline-container-orgheadline817" class="outline-5">
<h5 id="orgheadline817">Clojure Types / Java Interfaces&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline817">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Clojure Type</th>
<th scope="col" class="org-left">Implements</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Vector</td>
<td class="org-left">java.util.List*</td>
</tr>

<tr>
<td class="org-left">List</td>
<td class="org-left">java.util.List*</td>
</tr>

<tr>
<td class="org-left">Map</td>
<td class="org-left">java.util.Map*</td>
</tr>

<tr>
<td class="org-left">Set</td>
<td class="org-left">java.util.Set*</td>
</tr>

<tr>
<td class="org-left">Function</td>
<td class="org-left">java.lang.Runnable, j.u.concurrent.Callable</td>
</tr>
</tbody>
</table>

<p>
*Immutable portion only
</p>
</div>
</div>

<div id="outline-container-orgheadline818" class="outline-5">
<h5 id="orgheadline818">Generics&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline818">
<ul class="org-ul">
<li>Java is statically typed</li>
<li>Clojure is dynamically typed</li>
</ul>

<div class="org-src-container">

<pre class="src src-fundamental">// a List of Objects which happen to be Strings
java.util.List&lt;String&gt;
</pre>
</div>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">a Vector of Objects which happen to be Strings</span>
[<span class="org-string">"one"</span> <span class="org-string">"two"</span> <span class="org-string">"three"</span>]
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline831" class="outline-4">
<h4 id="orgheadline831">Performance Tuning&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline831">
</div><div id="outline-container-orgheadline820" class="outline-5">
<h5 id="orgheadline820">Reflection&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline820">
<ul class="org-ul">
<li>Clojure finds Java methods that match arg types</li>
<li>Uses reflection where necessary</li>
<li>Can add type hints to improve performance
<ul class="org-ul">
<li>Only do this when there's evidence of a problem&#x2026;</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline821" class="outline-5">
<h5 id="orgheadline821">Reflection Example&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline821">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">capitalize</span> [s]
  (<span class="org-builtin">if</span> (<span class="org-preprocessor">.isEmpty</span> s)
    s
    (<span class="org-builtin">let</span> [up (<span class="org-preprocessor">.toUpperCase</span> (<span class="org-preprocessor">.substring</span> s 0 1))
          down (<span class="org-preprocessor">.toLowerCase</span> (<span class="org-preprocessor">.substring</span> s 1))]
      (<span class="org-preprocessor">.concat</span> up down))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline822" class="outline-5">
<h5 id="orgheadline822">Micro-Benchmarking&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline822">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">time</span> (capitalize <span class="org-string">"CLoJuRe"</span>))
<span class="org-comment-delimiter">;; </span><span class="org-comment">"Elapsed time: 0.061 msecs"</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "Clojure"</span>

(<span class="org-variable-name">time</span> (<span class="org-builtin">dotimes</span> [i 10000] (capitalize <span class="org-string">"CLoJuRe"</span>)))
<span class="org-comment-delimiter">;; </span><span class="org-comment">"Elapsed time: 212.713 msecs"</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; "Clojure"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline823" class="outline-5">
<h5 id="orgheadline823">JVM Micro-Benchmarking&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline823">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">dotimes</span> [j 5]
  (<span class="org-variable-name">time</span>
   (<span class="org-builtin">dotimes</span> [i 10000]
     (capitalize <span class="org-string">"CLoJuRe"</span>))))
<span class="org-comment-delimiter">;; </span><span class="org-comment">"Elapsed time: 184.384 msecs"</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">"Elapsed time: 182.298 msecs"</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">"Elapsed time: 168.98 msecs"</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">"Elapsed time: 173.844 msecs"</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">"Elapsed time: 173.053 msecs"</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; nil</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline824" class="outline-5">
<h5 id="orgheadline824"><code>*warn-on-reflection*</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline824">
<div class="org-src-container">

<pre class="src src-clojure">(set! *warn-on-reflection* true)

(<span class="org-keyword">defn</span> <span class="org-function-name">capitalize</span> ... )
<span class="org-comment-delimiter">;; </span><span class="org-comment">Reflection warning, NO_SOURCE_FILE:1</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">- reference to field isEmpty can't be resolved.</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Reflection warning, NO_SOURCE_FILE:1</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">- call to substring can't be resolved.</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Reflection warning, NO_SOURCE_FILE:1</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">- call to toUpperCase can't be resolved.</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">...</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline825" class="outline-5">
<h5 id="orgheadline825">Add Type Hint Metadata&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline825">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">capitalize</span> [<span class="org-type">^String</span> s]  <span class="org-comment">; type hint</span>
  (<span class="org-builtin">if</span> (<span class="org-preprocessor">.isEmpty</span> s)
    s
    (<span class="org-builtin">let</span> [up (<span class="org-preprocessor">.toUpperCase</span> (<span class="org-preprocessor">.substring</span> s 0 1))
          down (<span class="org-preprocessor">.toLowerCase</span> (<span class="org-preprocessor">.substring</span> s 1))]
      (<span class="org-preprocessor">.concat</span> up down))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline826" class="outline-5">
<h5 id="orgheadline826">Type-Hinted Performance&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline826">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">dotimes</span> [j 5]
  (<span class="org-variable-name">time</span>
   (<span class="org-builtin">dotimes</span> [i 10000]
     (capitalize <span class="org-string">"CLoJuRe"</span>))))
<span class="org-comment-delimiter">;; </span><span class="org-comment">"Elapsed time: 7.121 msecs"</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">"Elapsed time: 11.745 msecs"</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">"Elapsed time: 2.883 msecs"</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">"Elapsed time: 2.514 msecs"</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">"Elapsed time: 4.282 msecs"</span>
<span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; nil</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline827" class="outline-5">
<h5 id="orgheadline827">Type Hint Summary&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline827">
<ul class="org-ul">
<li>Use only when necessary</li>
<li>Always check with <code>*warn-on-reflection*</code></li>
<li><i>Not</i> a static type check or runtime coercion</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline828" class="outline-5">
<h5 id="orgheadline828">Primitive Math&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline828">
<ul class="org-ul">
<li>By default, Clojure numbers are <i>boxed</i> in objects
<ul class="org-ul">
<li><code>java.lang.Long</code>,  <code>java.lang.Double</code>, etc.</li>
<li>Limits arithmetic performance</li>
</ul></li>
<li>Java has <i>primitive</i> (non-object) types for fast math
<ul class="org-ul">
<li><code>byte</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, etc.</li>
<li>Cannot be stored in collections (except arrays)</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline829" class="outline-5">
<h5 id="orgheadline829">Primitive Math&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline829">
<ul class="org-ul">
<li>Clojure supports primitive <code>long</code> and <code>double</code> only</li>
<li>Add type hints to fn arguments and return values</li>
<li>All basic math operations support primitives</li>
<li>Calling non-primitive fn reverts to boxed numbers</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline830" class="outline-5">
<h5 id="orgheadline830">Primitive Math&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline830">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">fib</span> [n]
  (<span class="org-builtin">if</span> (<span class="org-variable-name">&lt;=</span> n 1)
    1
    (<span class="org-variable-name">+</span> (fib (<span class="org-variable-name">dec</span> n)) (fib (<span class="org-variable-name">-</span> n 2)))))

(<span class="org-variable-name">time</span> (fib 38))
<span class="org-comment-delimiter">;; </span><span class="org-comment">"Elapsed time: 3565.579 msecs"</span>

(<span class="org-keyword">defn</span> <span class="org-function-name">fib</span> <span class="org-type">^long</span> [<span class="org-type">^long</span> n]   <span class="org-comment">; hint arg and return</span>
  (<span class="org-builtin">if</span> (<span class="org-variable-name">&lt;=</span> n 1)
    1
    (<span class="org-variable-name">+</span> (fib (<span class="org-variable-name">dec</span> n)) (fib (<span class="org-variable-name">-</span> n 2)))))

(<span class="org-variable-name">time</span> (fib 38))
<span class="org-comment-delimiter">;; </span><span class="org-comment">"Elapsed time: 395.365 msecs"</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline840" class="outline-4">
<h4 id="orgheadline840">AOT Compilation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline840">
</div><div id="outline-container-orgheadline832" class="outline-5">
<h5 id="orgheadline832">AOT Compilation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline832">
<ul class="org-ul">
<li>Clojure is always compiled
<ul class="org-ul">
<li>Usually on-the-fly, while loading code</li>
</ul></li>
<li>Ahead-of-time (AOT) compilation
<ul class="org-ul">
<li>Write bytecode (.class) files to disk</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline833" class="outline-5">
<h5 id="orgheadline833">Reasons to AOT-compile&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline833">
<ul class="org-ul">
<li>Ship without source</li>
<li>Provide static references for Java code</li>
<li>Avoid compilation cost on startup</li>
<li>Special deployment targets, e.g. Android</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline834" class="outline-5">
<h5 id="orgheadline834"><code>compile</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline834">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">compile</span> 'your.namespace)
</pre>
</div>

<ul class="org-ul">
<li>Loads <code>your.namespace</code> with <code>require</code></li>
<li>Writes .class files to <code>*clojure-compile-path*</code>
<ul class="org-ul">
<li>Default is <code>classes/</code></li>
<li>Both this and source must be on classpath!</li>
</ul></li>
<li>Usually handled by build tools</li>
</ul>
</div>
</div>


<div id="outline-container-orgheadline835" class="outline-5">
<h5 id="orgheadline835">Leiningen&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline835">
<ul class="org-ul">
<li>pronounced "LINE-ing-en"</li>
<li><a href="http://leiningen.org/">leiningen.org</a></li>
</ul>

<div class="org-src-container">

<pre class="src src-shell-script">lein new ${<span class="org-variable-name">NAME</span>}      <span class="org-comment-delimiter"># </span><span class="org-comment">Generate a new project</span>
lein repl             <span class="org-comment-delimiter"># </span><span class="org-comment">Start a REPL</span>
lein run -m foo/main  <span class="org-comment-delimiter"># </span><span class="org-comment">Execute function foo/main</span>
lein version          <span class="org-comment-delimiter"># </span><span class="org-comment">Show version</span>
lein help             <span class="org-comment-delimiter"># </span><span class="org-comment">Show available commands</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline836" class="outline-5">
<h5 id="orgheadline836">Leiningen 2 Project&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline836">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Path</th>
<th scope="col" class="org-left">Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">&nbsp; <code>project.clj</code></td>
<td class="org-left">Project/build config</td>
</tr>

<tr>
<td class="org-left">&nbsp; <code>src/</code></td>
<td class="org-left">Clojure sources</td>
</tr>

<tr>
<td class="org-left">&nbsp; <code>test/</code></td>
<td class="org-left">Clojure unit tests</td>
</tr>

<tr>
<td class="org-left">&nbsp; <code>resources/</code></td>
<td class="org-left">Non-code project files</td>
</tr>

<tr>
<td class="org-left">&nbsp; <code>resources/public/</code></td>
<td class="org-left">HTML/CSS/JS files for web (convention)</td>
</tr>

<tr>
<td class="org-left">&nbsp; <code>target/classes/</code></td>
<td class="org-left">Compiled bytecode</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>Cached dependencies stored in <code>$HOME/.m2/repository/</code></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline837" class="outline-5">
<h5 id="orgheadline837">Leiningen project.clj&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline837">
<div class="org-src-container">

<pre class="src src-clojure">(defproject my-project <span class="org-string">"0.1.0-SNAPSHOT"</span>
  <span class="org-constant">:description</span> <span class="org-string">"This is the best project ever"</span>
  <span class="org-constant">:dependencies</span> [[org.clojure/clojure <span class="org-string">"1.10.0-beta8"</span>]
                 [org.clojure/math.combinatorics <span class="org-string">"0.1.4"</span>]])
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline838" class="outline-5">
<h5 id="orgheadline838">Leiningen Dependencies&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline838">
<ul class="org-ul">
<li>Vector of <i>symbol</i> and version <i>string</i></li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;;  </span><span class="org-comment">group ID      artifact ID      version</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">----------- ------------------  -------</span>
[  org.clojure/math.combinatorics  <span class="org-string">"0.1.4"</span> ]

<span class="org-comment-delimiter">;; </span><span class="org-comment">Same group &amp; artifact ID        version</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">------------------------        -------</span>
[  compojure                       <span class="org-string">"1.6.0"</span> ]
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline839" class="outline-5">
<h5 id="orgheadline839">Leiningen AOT-compile&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline839">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">In project.clj</span>
(defproject myproject <span class="org-string">"0.1.0-SNAPSHOT"</span>
  <span class="org-comment-delimiter">;; </span><span class="org-comment">...</span>
  <span class="org-comment-delimiter">;; </span><span class="org-comment">AOT-compile these namespaces:</span>
  <span class="org-constant">:aot</span> [com.example.one com.example.two])
</pre>
</div>

<p>
Then in a shell:
</p>

<pre class="example">
lein compile
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline854" class="outline-4">
<h4 id="orgheadline854">Mixing Clojure and Java&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic2">topic2</span>&#xa0;<span class="slide">slide</span></span></h4>
<div class="outline-text-4" id="text-orgheadline854">
</div><div id="outline-container-orgheadline841" class="outline-5">
<h5 id="orgheadline841">Mixing Clojure and Java&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline841">
<ul class="org-ul">
<li>Two basic models
<ul class="org-ul">
<li>Clojure consuming Java library</li>
<li>Java consuming Clojure library</li>
</ul></li>
<li>Order of Compilation
<ul class="org-ul">
<li>Clojure compiler is not integrated with <code>javac</code></li>
<li>Cannot have circular dependencies in the same compilation unit</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline842" class="outline-5">
<h5 id="orgheadline842">Consuming Java from Clojure&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline842">
<ul class="org-ul">
<li>Excellent support for calling Java from Clojure
<ul class="org-ul">
<li>Native data types</li>
<li>Simple interop forms</li>
</ul></li>
<li>What about invoking Java code that needs to callback?
<ul class="org-ul">
<li>E.g., a thread function, async response handler, etc.</li>
</ul></li>
<li>Can implement callbacks a number of ways&#x2026;</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline843" class="outline-5">
<h5 id="orgheadline843">Clojure Function Interfaces&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline843">
<ul class="org-ul">
<li>Functions implement <code>java.lang.Runnable</code> and <code>java.util.concurrent.Callable</code></li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">java.lang.Thread takes a Runnable</span>
(<span class="org-preprocessor">.start</span> (<span class="org-preprocessor">Thread.</span> #(<span class="org-variable-name">println</span> <span class="org-string">"Hello, World!"</span>)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline844" class="outline-5">
<h5 id="orgheadline844">Implementing Other Java Interfaces&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline844">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">import</span> (some.package <span class="org-preprocessor">IFoo</span>))

(<span class="org-keyword">deftype</span> <span class="org-function-name">Bar</span> [a b]
  <span class="org-preprocessor">IFoo</span>    <span class="org-comment">; class Bar implements IFoo</span>
  (foo [this arg] ...))

(<span class="org-keyword">defrecord</span> <span class="org-function-name">Rab</span> [a b]
  <span class="org-preprocessor">IFoo</span>    <span class="org-comment">; class Rab implements IFoo</span>
  (foo [this arg] ...))

(<span class="org-variable-name">reify</span>    <span class="org-comment">; instance of anonymous class </span>
  <span class="org-preprocessor">IFoo</span>    <span class="org-comment">; which implements IFoo</span>
  (foo [this arg] ...))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline845" class="outline-5">
<h5 id="orgheadline845"><code>proxy</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline845">
<ul class="org-ul">
<li>Can extend classes
<ul class="org-ul">
<li>Provide arguments to base class constructor</li>
</ul></li>
<li>Can access super (via reflection)</li>
<li>For interop only</li>
<li>Prefer <code>reify</code> when you only need interfaces</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">proxy</span> [class-and-interfaces*]
    [constructor-arguments*]
  (method [args*] ...))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline846" class="outline-5">
<h5 id="orgheadline846"><code>proxy</code> Example&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline846">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-variable-name">proxy</span> [<span class="org-preprocessor">JTable</span>]  <span class="org-comment">; extend JTable</span>
    []   <span class="org-comment">; base class constructor arguments</span>
  (<span class="org-preprocessor">prepareRenderer</span> [renderer row col]  <span class="org-comment">; override method</span>
    <span class="org-comment-delimiter">;; </span><span class="org-comment">invoke superclass method:</span>
    (<span class="org-builtin">doto</span> (<span class="org-variable-name">proxy-super</span> <span class="org-preprocessor">prepareRenderer</span> renderer row col)
      (<span class="org-preprocessor">.setBackground</span> (<span class="org-builtin">if</span> (<span class="org-variable-name">even?</span> row)
                        <span class="org-preprocessor">Color/lightGray</span>
                        <span class="org-preprocessor">Color/white</span>)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline847" class="outline-5">
<h5 id="orgheadline847">Consuming Clojure from Java&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline847">
<ul class="org-ul">
<li>Two approaches
<ul class="org-ul">
<li>Bind and invoke functions</li>
<li>Instantiate records/types and invoke protocol methods</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline848" class="outline-5">
<h5 id="orgheadline848">Clojure Functions from Java&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline848">
<ul class="org-ul">
<li>Clojure 1.6.0 added a Clojure Java API
<ul class="org-ul">
<li><code>clojure.java.api.Clojure</code></li>
<li><a href="http://clojure.github.io/clojure/javadoc/">http://clojure.github.io/clojure/javadoc/</a></li>
</ul></li>
<li>Two methods to invoke anything in Clojure
<ul class="org-ul">
<li><code>Clojure.var</code> gets an IFn by name</li>
<li><code>IFn.invoke</code> calls function bound to the Var</li>
</ul></li>
<li>Easy to wrap in a Java facade class</li>
</ul>

<div class="org-src-container">

<pre class="src src-fundamental">import clojure.java.api.Clojure;
import clojure.lang.IFn;

IFn PRINTLN = Clojure.var(<span class="org-string">"clojure.core"</span>, <span class="org-string">"println"</span>);
PRINTLN.invoke(<span class="org-string">"Hello, world!"</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline849" class="outline-5">
<h5 id="orgheadline849">Clojure Types from Java&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline849">
<ul class="org-ul">
<li>AOT-compile a namespace containing deftype/defrecord
<ul class="org-ul">
<li>Type will be accessible by name in Java code</li>
<li>Constructor takes type fields in order</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline850" class="outline-5">
<h5 id="orgheadline850">Clojure Types from Java&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline850">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">Clojure</span>
(<span class="org-builtin">ns</span> com.example.my-project)

(<span class="org-keyword">deftype</span> <span class="org-function-name">Foo</span> [a b])
</pre>
</div>

<div class="org-src-container">

<pre class="src src-fundamental">// Java
import com.example.my_project.Foo;

Foo f = new Foo(1, 2);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline851" class="outline-5">
<h5 id="orgheadline851">Clojure Protocols from Java&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline851">
<div class="org-src-container">

<pre class="src src-clojure"><span class="org-comment-delimiter">;; </span><span class="org-comment">Clojure</span>
(<span class="org-builtin">ns</span> com.example.my-app)

(<span class="org-keyword">defprotocol</span> <span class="org-function-name">IFoo</span>
  (do-stuff [this a b] <span class="org-string">"Do stuff"</span>))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-fundamental">// Java
import com.example.my_app.IFoo;

public class Bar implements IFoo {
    public Object do_stuff(Object a, Object b) {
        ...
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline852" class="outline-5">
<h5 id="orgheadline852"><code>gen-class</code>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline852">
<ul class="org-ul">
<li>Does nothing unless AOT-compiling</li>
<li>Generates Java class
<ul class="org-ul">
<li>Can extend/implement classes/interfaces</li>
<li>Methods dispatch to Clojure functions</li>
<li>Can produce Java <code>main</code> method</li>
</ul></li>
<li>For Java interop only</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline853" class="outline-5">
<h5 id="orgheadline853"><code>gen-class</code> Example&#xa0;&#xa0;&#xa0;<span class="tag"><span class="slide">slide</span></span></h5>
<div class="outline-text-5" id="text-orgheadline853">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">ns</span> com.example.my-app
  (<span class="org-constant">:gen-class</span>))

(<span class="org-keyword">defn</span> <span class="org-function-name">-main</span>
  [&amp; greetees]
  (<span class="org-builtin">doseq</span> [name greetees]
    (<span class="org-variable-name">println</span> (<span class="org-variable-name">str</span> <span class="org-string">"Hi "</span> name <span class="org-string">"!"</span>))))
</pre>
</div>

<pre class="example">
java -cp .:clojure.jar com.example.my_app Bob Sally

Hi Bob!
Hi Sally!
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline855" class="outline-3">
<h3 id="orgheadline855">LAB: Type Hints and Primitive Arithmetic&#xa0;&#xa0;&#xa0;<span class="tag"><span class="topic1">topic1</span>&#xa0;<span class="slide">slide</span></span></h3>
<div class="outline-text-3" id="text-orgheadline855">
</div>

<div id="outline-container-orgheadline856" class="outline-4">
<h4 id="orgheadline856">Description</h4>
<div class="outline-text-4" id="text-orgheadline856">
<p>
In this lab, we will do some simple image processing as a way to
explore some of the optimizations built into the Clojure compiler.
Both image processing and optimization are complex topics, so you
should focus on simply becoming familiar with the available
techniques; the performance effects they have here will <b>not</b> be the
same in your projects.
</p>

<p>
You may find the documentation for the <a href="http://docs.oracle.com/javase/7/docs/api/java/awt/image/BufferedImage.html">BufferedImage</a> class helpful for this lab.
</p>
</div>
</div>

<div id="outline-container-orgheadline857" class="outline-4">
<h4 id="orgheadline857">Setup</h4>
<div class="outline-text-4" id="text-orgheadline857">
<p>
You will need an image to work with in this lab. You can use anything
you like, but if you don't have one, feel free to use this one of John
McCarthy, the creator of Lisp:
</p>


<div class="figure">
<p><img src="slide-assets/john-mccarthy.jpg" alt="john-mccarthy.jpg" />
</p>
</div>

<p>
Whatever image you choose, save it to your hard drive and note the
location. Then evaluate the following code:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-builtin">import</span> (javax.swing <span class="org-preprocessor">JButton</span> <span class="org-preprocessor">JPanel</span> <span class="org-preprocessor">JFrame</span>)
        <span class="org-preprocessor">java.awt.event.ActionListener</span>
        <span class="org-preprocessor">javax.imageio.ImageIO</span>
        <span class="org-preprocessor">java.awt.Color</span>
        <span class="org-preprocessor">java.awt.image.BufferedImage</span>)

<span class="org-comment-delimiter">;; </span><span class="org-comment">TODO: Change the path to point to the image you want to use</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">Supported file types may vary by system, but likely include</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">BMP, JPG, PNG, and GIF. JPG is a safe choice</span>
(<span class="org-keyword">def</span> <span class="org-function-name">image</span> (<span class="org-variable-name">atom</span> (<span class="org-preprocessor">ImageIO/read</span> (<span class="org-preprocessor">java.io.File.</span> <span class="org-string">"/path/to/image.jpg"</span>))))
</pre>
</div>

<p>
Now we need to write a basic Swing app that will display an image and
allow us to transform it. Copy the following code into the REPL and
evaluate it:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">paint</span> [g]
  (<span class="org-builtin">let</span> [bounds (<span class="org-preprocessor">.getClipBounds</span> g)
        width (<span class="org-preprocessor">.getWidth</span> bounds)
        height (<span class="org-preprocessor">.getHeight</span> bounds)]
    (<span class="org-preprocessor">.drawImage</span> g @image 0 0 width height <span class="org-preprocessor">Color/black</span> nil)))

(<span class="org-keyword">defn</span> <span class="org-function-name">transform</span> [image]
  (<span class="org-builtin">let</span> [width (<span class="org-preprocessor">.getWidth</span> image)
        height (<span class="org-preprocessor">.getHeight</span> image)
        <span class="org-preprocessor">newImage</span> (<span class="org-preprocessor">BufferedImage.</span> width height (<span class="org-preprocessor">.getType</span> image))]
    (<span class="org-builtin">doseq</span> [x (<span class="org-variable-name">range</span> 0 width)
            y (<span class="org-variable-name">range</span> 0 height)]
      (<span class="org-preprocessor">.setRGB</span> <span class="org-preprocessor">newImage</span> x (<span class="org-variable-name">-</span> height y 1) (<span class="org-preprocessor">.getRGB</span> image x y)))
    <span class="org-preprocessor">newImage</span>))

(<span class="org-keyword">defn</span> <span class="org-function-name">sample-app</span> []
  (<span class="org-builtin">let</span> [frame (<span class="org-preprocessor">JFrame.</span> <span class="org-string">"Sample Application"</span>)
        panel (<span class="org-variable-name">proxy</span> [<span class="org-preprocessor">JPanel</span> <span class="org-preprocessor">ActionListener</span>] []
                (<span class="org-preprocessor">getPreferredSize</span> [] nil)
                (<span class="org-preprocessor">paintComponent</span> [g]
                  (<span class="org-variable-name">proxy-super</span> <span class="org-preprocessor">paintComponent</span> g)
                  (paint g))
                (<span class="org-preprocessor">actionPerformed</span> [e]
                  (<span class="org-variable-name">println</span> <span class="org-string">"Transforming image"</span>)
                  (<span class="org-variable-name">time</span> (<span class="org-variable-name">swap!</span> image transform))
                  (<span class="org-preprocessor">.repaint</span> this)))
        button (<span class="org-preprocessor">JButton.</span> <span class="org-string">"Transform!"</span>)]
    (<span class="org-preprocessor">.setOpaque</span> panel true)
    (<span class="org-preprocessor">.addActionListener</span> button panel)
    (<span class="org-preprocessor">.add</span> panel button)
    (<span class="org-preprocessor">.setContentPane</span> frame panel)
    (<span class="org-preprocessor">.setSize</span> frame 500 600)
    (<span class="org-preprocessor">.setLocationByPlatform</span> frame true)
    (<span class="org-preprocessor">.setLocation</span> frame 50 50)
    (<span class="org-preprocessor">.setVisible</span> frame true)
    panel))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline858" class="outline-4">
<h4 id="orgheadline858">Run the application</h4>
<div class="outline-text-4" id="text-orgheadline858">
<p>
At this point, you have a simple application that will display an
image. You can run the app by evaluating the following statement:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(sample-app)
</pre>
</div>

<p>
Clicking the "Transform!" button will flip the image top-to-bottom.
You will see the amount of time the computation took printed at the
REPL. Make sure you run it more than once, since the run times may be
different on invocations other than the first.
</p>

<p>
Depending on the image you chose and the capabilities of your
computer, this computation may be quite lengthy. We'll attempt to
change that in the next step.
</p>
</div>
</div>

<div id="outline-container-orgheadline859" class="outline-4">
<h4 id="orgheadline859">Add type hints</h4>
<div class="outline-text-4" id="text-orgheadline859">
<p>
Add type hints to <code>transform</code> so that the compiler no longer needs to
use reflection to call the <code>getRGB</code> and <code>setRGB</code> methods. Evaluate
your new version and click the "Transform!" button (there should be no
need to restart the application). Make sure you click "Transform!"
several times to give the JVM an opportunity to perform runtime
optimizations.
</p>

<p>
Did the computation get any faster? Why or why not?
</p>
</div>

<div id="outline-container-orgheadline860" class="outline-5">
<h5 id="orgheadline860">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline860">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">transform</span> [<span class="org-type">^BufferedImage</span> image]
  (<span class="org-builtin">let</span> [width (<span class="org-preprocessor">.getWidth</span> image)
       height (<span class="org-preprocessor">.getHeight</span> image)
       <span class="org-type">^BufferedImage</span> <span class="org-preprocessor">newImage</span> (<span class="org-preprocessor">BufferedImage.</span> width height (<span class="org-preprocessor">.getType</span> image))]
   (<span class="org-builtin">doseq</span> [x (<span class="org-variable-name">range</span> 0 width)
           y (<span class="org-variable-name">range</span> 0 height)]
     (<span class="org-preprocessor">.setRGB</span> <span class="org-preprocessor">newImage</span> x (<span class="org-variable-name">-</span> height y 1) (<span class="org-preprocessor">.getRGB</span> image x y)))
   <span class="org-preprocessor">newImage</span>))
</pre>
</div>

<p>
On the author's machine, this version of the algorithm runs
approximately 10 times faster than the un-hinted version, due to the
removal of the need to do reflection.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline861" class="outline-4">
<h4 id="orgheadline861">Use primitive arithmetic</h4>
<div class="outline-text-4" id="text-orgheadline861">
<p>
Now update <code>transform</code> so that it uses primitive rather than boxed
numbers in its calculations. (<b>Hint</b>: you will need to use <code>loop</code> and
<code>recur</code> rather than <code>doseq</code>.) Make sure you click "Transform!" several
times to give the JVM an opportunity to perform runtime optimizations.
</p>

<p>
Did the computation get any faster? Why or why not?
</p>
</div>

<div id="outline-container-orgheadline862" class="outline-5">
<h5 id="orgheadline862">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline862">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">transform</span> [<span class="org-type">^BufferedImage</span> image]
  (<span class="org-builtin">let</span> [width (<span class="org-preprocessor">.getWidth</span> image)
        height (<span class="org-preprocessor">.getHeight</span> image)
        <span class="org-type">^BufferedImage</span> <span class="org-preprocessor">newImage</span> (<span class="org-preprocessor">BufferedImage.</span> width height (<span class="org-preprocessor">.getType</span> image))]
    (<span class="org-builtin">loop</span> [x 0 y 0]
      (<span class="org-builtin">when-not</span> (<span class="org-variable-name">=</span> y height)
        (<span class="org-preprocessor">.setRGB</span> <span class="org-preprocessor">newImage</span> x (<span class="org-variable-name">-</span> height y 1) (<span class="org-preprocessor">.getRGB</span> image x y))
        (<span class="org-builtin">if</span> (<span class="org-variable-name">=</span> x (<span class="org-variable-name">-</span> width 1))
          (<span class="org-builtin">recur</span> 0 (<span class="org-variable-name">inc</span> y))
          (<span class="org-builtin">recur</span> (<span class="org-variable-name">inc</span> x) y))))
    <span class="org-preprocessor">newImage</span>))
</pre>
</div>

<p>
On the author's machine, this version of the algorithm runs
approximately 50% faster than the type-hinted version, due to the
removal of boxing and unboxing of integers.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline863" class="outline-4">
<h4 id="orgheadline863">Use array manipulation (optional)</h4>
<div class="outline-text-4" id="text-orgheadline863">
<p>
Our approach of using individual method calls to get at each element
of the image data seems like it can't possibly be the best way.
Instead, let's retrieve the data into a Java array and operate
directly on that.
</p>

<p>
Redefine <code>transform</code> so that it gets the data from the input image
into a primitive Java array, manipulates it there, and creates a new
image from the generated data. Make sure you click "Transform!"
several times to give the JVM an opportunity to perform runtime
optimizations.
</p>

<p>
Did the computation get any faster? Why or why not?
</p>
</div>

<div id="outline-container-orgheadline864" class="outline-5">
<h5 id="orgheadline864">Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="fold">fold</span></span></h5>
<div class="outline-text-5" id="text-orgheadline864">
<div class="org-src-container">

<pre class="src src-clojure">(<span class="org-keyword">defn</span> <span class="org-function-name">transform</span> [<span class="org-type">^BufferedImage</span> image]
  (<span class="org-builtin">let</span> [width (<span class="org-variable-name">int</span> (<span class="org-preprocessor">.getWidth</span> image))
        height (<span class="org-variable-name">int</span> (<span class="org-preprocessor">.getHeight</span> image))
        <span class="org-preprocessor">newImage</span> (<span class="org-preprocessor">BufferedImage.</span> width height (<span class="org-preprocessor">.getType</span> image))
        <span class="org-type">^ints</span> <span class="org-preprocessor">oldData</span> (<span class="org-preprocessor">.getRGB</span> image 0 0 width height nil 0 width)
        <span class="org-type">^ints</span> <span class="org-preprocessor">newData</span> (<span class="org-variable-name">int-array</span> (<span class="org-variable-name">*</span> width height))]
    (<span class="org-builtin">loop</span> [x 0 y 0]
      (<span class="org-builtin">when-not</span> (<span class="org-variable-name">=</span> y height)
        (<span class="org-variable-name">aset</span> <span class="org-preprocessor">newData</span> (<span class="org-variable-name">+</span> x (<span class="org-variable-name">*</span> y width)) (<span class="org-variable-name">aget</span> <span class="org-preprocessor">oldData</span> (<span class="org-variable-name">+</span> x (<span class="org-variable-name">*</span> width (<span class="org-variable-name">-</span> height y 1)))))
        (<span class="org-builtin">if</span> (<span class="org-variable-name">=</span> x (<span class="org-variable-name">-</span> width 1))
          (<span class="org-builtin">recur</span> 0 (<span class="org-variable-name">inc</span> y))
          (<span class="org-builtin">recur</span> (<span class="org-variable-name">inc</span> x) y))))
    (<span class="org-preprocessor">.setRGB</span> <span class="org-preprocessor">newImage</span> 0 0 width height <span class="org-preprocessor">newData</span> 0 width)
    <span class="org-preprocessor">newImage</span>))
</pre>
</div>

<p>
On the author's machine, this version of the algorithm is no faster
than the version that uses primitive arithmetic. This may be somewhat
surprising to you. The truth is that the JVM does a lot of clever
optimizations, and modern machine architectures are quite complicated,
making for a complex relationship between the structure of your code
and its performance.
</p>

<p>
This points out that you should always use a measurement-based
approach to selecting appropriate optimizations.
</p>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline866" class="outline-2">
<h2 id="orgheadline866">The End</h2>
<div class="outline-text-2" id="text-orgheadline866">
<p>
Produced with <a href="https://github.com/relevance/org-html-slideshow">org-html-slideshow</a>
</p>

<p>
#+COMMENT Bulleted lists start at outline level 5
</p>
<p>
#+COMMENT include results of evaluating Clojure source code in exported HTML
</p>
<p>
#+COMMENT org-html-slideshow
</p>
<script type="text/javascript" src="slide-assets/org-html-slideshow.js"></script>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Clojure/core</p>
<p class="date">Created: 2018-11-28 Wed 16:03</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
